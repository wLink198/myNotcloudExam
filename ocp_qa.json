[
  {
    "question": "Which of the following are legal entry point methods that can be run from the command \nline? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "private static void main(String[] args)"
      },
      {
        "key": "B",
        "text": "public static final main(String[] args)"
      },
      {
        "key": "C",
        "text": "public void main(String[] args)"
      },
      {
        "key": "D",
        "text": "public static final void main(String[] args)"
      },
      {
        "key": "E",
        "text": "public static void main(String[] args)"
      },
      {
        "key": "F",
        "text": "public static main(String[] args)\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which answer options represent the order in which the following statements can be assem-\nbled into a program that will compile successfully? (Choose all that apply.)\n    X: class Rabbit {}\n    Y: import java.util.*;\n    Z: package animals;",
    "choices": [
      {
        "key": "A",
        "text": "X, Y, Z"
      },
      {
        "key": "B",
        "text": "Y, Z, X"
      },
      {
        "key": "C",
        "text": "Z, Y, X"
      },
      {
        "key": "D",
        "text": "Y, X"
      },
      {
        "key": "E",
        "text": "Z, X"
      },
      {
        "key": "F",
        "text": "X, Z"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following are true? (Choose all that apply.)\n    public class Bunny {\n       public static void main(String[] x) {\n          Bunny bun = new Bunny();\n    } }",
    "choices": [
      {
        "key": "A",
        "text": "Bunny is a class."
      },
      {
        "key": "B",
        "text": "bun is a class."
      },
      {
        "key": "C",
        "text": "main is a class."
      },
      {
        "key": "D",
        "text": "Bunny is a reference to an object."
      },
      {
        "key": "E",
        "text": "bun is a reference to an object."
      },
      {
        "key": "F",
        "text": "main is a reference to an object."
      },
      {
        "key": "G",
        "text": "The main() method doesn’t run because the parameter name is incorrect.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which of the following are valid Java identifiers? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "_"
      },
      {
        "key": "B",
        "text": "_helloWorld$"
      },
      {
        "key": "C",
        "text": "true"
      },
      {
        "key": "D",
        "text": "java.lang"
      },
      {
        "key": "E",
        "text": "Public"
      },
      {
        "key": "F",
        "text": "1980_s"
      },
      {
        "key": "G",
        "text": "_Q2_\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n    2:  public class Bear {\n    3:     private Bear pandaBear;\n    4:     private void roar(Bear b) {\n    5:        System.out.println(\"Roar!\");\n    6:        pandaBear = b;\n    7:     }\n    8:     public static void main(String[] args) {\n    9:        Bear brownBear = new Bear();\n    10:       Bear polarBear = new Bear();\n    11:       brownBear.roar(polarBear);\n    12:       polarBear = null;\n    13:       brownBear = null;\n    14:       System.gc(); } }",
    "choices": [
      {
        "key": "A",
        "text": "The object created on line 9 is eligible for garbage collection after line 13."
      },
      {
        "key": "B",
        "text": "The object created on line 9 is eligible for garbage collection after line 14."
      },
      {
        "key": "C",
        "text": "The object created on line 10 is eligible for garbage collection after line 12."
      },
      {
        "key": "D",
        "text": "The object created on line 10 is eligible for garbage collection after line 13."
      },
      {
        "key": "E",
        "text": "Garbage collection is guaranteed to run."
      },
      {
        "key": "F",
        "text": "Garbage collection might or might not run."
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Assuming the following class compiles, how many variables defined in the class or method \nare in scope on the line marked on line 14?\n    1:  public class Camel {\n    2:     { int hairs = 3_000_0; }\n    3:     long water, air=2;\n    4:     boolean twoHumps = true;\n    5:     public void spit(float distance) {\n    6:        var path = \"\";\n    7:        { double teeth = 32 + distance++; }\n    8:        while(water > 0) {\n    9:           int age = twoHumps ? 1 : 2;\n    10:          short i=- 1;\n    11:          for(i=0; i<10; i++) {\n    12:             var Private = 2;\n    13:          }\n    14:          // SCOPE\n    15:       }\n    16:    }\n    17: }",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "4"
      },
      {
        "key": "D",
        "text": "5"
      },
      {
        "key": "E",
        "text": "6"
      },
      {
        "key": "F",
        "text": "7"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Which are true about this code? (Choose all that apply.)\n    public class KitchenSink {\n        private int numForks;\n \n        public static void main(String[] args) {\n           int numKnives;\n           System.out.print(\"\"\"\n              \"# forks = \" + numForks +\n               \" # knives = \" + numKnives +\n              # cups = 0\"\"\");\n        }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "The output includes: # forks = 0."
      },
      {
        "key": "B",
        "text": "The output includes: # knives = 0."
      },
      {
        "key": "C",
        "text": "The output includes: # cups = 0."
      },
      {
        "key": "D",
        "text": "The output includes a blank line."
      },
      {
        "key": "E",
        "text": "The output includes one or more lines that begin with whitespace."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following code snippets about var compile without issue when used in a \nmethod? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "var spring = null;"
      },
      {
        "key": "B",
        "text": "var fall = \"leaves\";"
      },
      {
        "key": "C",
        "text": "var evening = 2; evening = null;"
      },
      {
        "key": "D",
        "text": "var night = Integer.valueOf(3);"
      },
      {
        "key": "E",
        "text": "var day = 1/0;"
      },
      {
        "key": "F",
        "text": "var winter = 12, cold;"
      },
      {
        "key": "G",
        "text": "var fall = 2, autumn = 2;"
      },
      {
        "key": "H",
        "text": "var morning = \"\"; morning = null;\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of the following are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An instance variable of type float defaults to 0."
      },
      {
        "key": "B",
        "text": "An instance variable of type char defaults to null."
      },
      {
        "key": "C",
        "text": "A local variable of type double defaults to 0.0."
      },
      {
        "key": "D",
        "text": "A local variable of type int defaults to null."
      },
      {
        "key": "E",
        "text": "A class variable of type String defaults to null."
      },
      {
        "key": "F",
        "text": "A class variable of type String defaults to the empty string \"\"."
      },
      {
        "key": "G",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which of the following expressions, when inserted independently into the blank line, allow \nthe code to compile? (Choose all that apply.)\n    public void printMagicData() {\n       var magic = ;\n       System.out.println(magic);\n    }",
    "choices": [
      {
        "key": "A",
        "text": "3_1"
      },
      {
        "key": "B",
        "text": "1_329_.0"
      },
      {
        "key": "C",
        "text": "3_13.0_"
      },
      {
        "key": "D",
        "text": "5_291._2"
      },
      {
        "key": "E",
        "text": "2_234.0_0"
      },
      {
        "key": "F",
        "text": "9___6"
      },
      {
        "key": "G",
        "text": "_1_3_5_0\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Given the following two class files, what is the maximum number of imports that can be \nremoved and have the code still compile?\n    // Water.java\n    package aquarium;\n    public class Water { }\n \n    // Tank.java\n    package aquarium;\n    import java.lang.*;\n    import java.lang.System;\n    import aquarium.Water;\n    import aquarium.*;\n    public class Tank {\n       public void print(Water water) {\n       System.out.println(water); } }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "Does not compile\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Which statements about the following class are correct? (Choose all that apply.)\n    1: public class ClownFish {\n    2:    int gills = 0, double weight=2;\n    3:    { int fins = gills; }\n    4:    void print(int length = 3) {\n    5:       System.out.println(gills);\n    6:       System.out.println(weight);\n    7:       System.out.println(fins);\n    8:       System.out.println(length);\n    9: } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 2 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 4 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "E",
        "text": "The code prints 0."
      },
      {
        "key": "F",
        "text": "The code prints 2.0."
      },
      {
        "key": "G",
        "text": "The code prints 2."
      },
      {
        "key": "H",
        "text": "The code prints 3.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Given the following classes, which of the following snippets can independently be inserted in \nplace of INSERT IMPORTS HERE and have the code compile? (Choose all that apply.)\n    package aquarium;\n    public class Water {\n       boolean salty = false;\n    }\n \n    package aquarium.jellies;\n    public class Water {\n       boolean salty = true;\n    }\n \n    package employee;\n    INSERT IMPORTS HERE\n    public class WaterFiller {\n       Water water;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.Water;\nimport aquarium.jellies.*;"
      },
      {
        "key": "C",
        "text": "import aquarium.*;\nimport aquarium.jellies.Water;"
      },
      {
        "key": "D",
        "text": "import aquarium.*;\nimport aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.Water;\nimport aquarium.jellies.Water;"
      },
      {
        "key": "F",
        "text": "None of these imports can make the code compile.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following statements about the code snippet are true? (Choose all that apply.)\n    3: short numPets = 5L;\n    4: int numGrains = 2.0;\n    5: String name = \"Scruffy\";\n    6: int d = numPets.length();\n    7: int e = numGrains.length;\n    8: int f = name.length();",
    "choices": [
      {
        "key": "A",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 4 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 5 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "F",
        "text": "Line 8 generates a compiler error.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which of the following statements about garbage collection are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Calling System.gc() is guaranteed to free up memory by destroying objects eligible \nfor garbage collection."
      },
      {
        "key": "B",
        "text": "Garbage collection runs on a set schedule."
      },
      {
        "key": "C",
        "text": "Garbage collection allows the JVM to reclaim memory for other objects."
      },
      {
        "key": "D",
        "text": "Garbage collection runs when your program has used up half the available memory."
      },
      {
        "key": "E",
        "text": "An object may be eligible for garbage collection but never removed from the heap."
      },
      {
        "key": "F",
        "text": "An object is eligible for garbage collection once no references to it are accessible in the \nprogram."
      },
      {
        "key": "G",
        "text": "Marking a variable final means its associated object will never be garbage collected.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Which are true about this code? (Choose all that apply.)\n    var blocky = \"\"\"\n       squirrel \\s\n       pigeon   \\\n       termite\"\"\";\n    System.out.print(blocky);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs two lines."
      },
      {
        "key": "B",
        "text": "It outputs three lines."
      },
      {
        "key": "C",
        "text": "It outputs four lines."
      },
      {
        "key": "D",
        "text": "There is one line with trailing whitespace."
      },
      {
        "key": "E",
        "text": "There are two lines with trailing whitespace."
      },
      {
        "key": "F",
        "text": "If we indented each line five characters, it would change the output.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What lines are printed by the following program? (Choose all that apply.)\n    1:  public class WaterBottle {\n    2:     private String brand;\n    3:     private boolean empty;\n    4:     public static float code;\n    5:     public static void main(String[] args) {\n    6:        WaterBottle wb = new WaterBottle();\n    7:        System.out.println(\"Empty = \" + wb.empty);\n    8:        System.out.println(\"Brand = \" + wb.brand);\n    9:        System.out.println(\"Code = \" + code);\n    10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 8 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 9 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Empty ="
      },
      {
        "key": "D",
        "text": "Empty = false"
      },
      {
        "key": "E",
        "text": "Brand ="
      },
      {
        "key": "F",
        "text": "Brand = null"
      },
      {
        "key": "G",
        "text": "Code = 0.0"
      },
      {
        "key": "H",
        "text": "Code = 0f\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which of the following statements about var are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A var can be used as a constructor parameter."
      },
      {
        "key": "B",
        "text": "The type of a var is known at compile time."
      },
      {
        "key": "C",
        "text": "A var cannot be used as an instance variable."
      },
      {
        "key": "D",
        "text": "A var can be used in a multiple variable assignment statement."
      },
      {
        "key": "E",
        "text": "The value of a var cannot change at runtime."
      },
      {
        "key": "F",
        "text": "The type of a var cannot change at runtime."
      },
      {
        "key": "G",
        "text": "The word var is a reserved word in Java.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which are true about the following code? (Choose all that apply.)\n    var num1 = Long.parseLong(\"100\");\n    var num2 = Long.valueOf(\"100\");\n    System.out.println(Long.max(num1, num2));",
    "choices": [
      {
        "key": "A",
        "text": "The output is 100."
      },
      {
        "key": "B",
        "text": "The output is 200."
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "num1 is a primitive."
      },
      {
        "key": "E",
        "text": "num2 is a primitive.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which statements about the following class are correct? (Choose all that apply.)\n    1:  public class PoliceBox {\n    2:     String color;\n    3:     long age;\n    4:     public void PoliceBox() {\n    5:        color = \"blue\";\n    6:        age = 1200;\n    7:     }\n    8:     public static void main(String []time) {\n    9:        var p = new PoliceBox();\n    10:       var q = new PoliceBox();\n    11:       p.color = \"green\";\n    12:       p.age = 1400;\n    13:       p = q;\n    14:       System.out.println(\"Q1=\"+q.color);\n    15:       System.out.println(\"Q2=\"+q.age);\n    16:       System.out.println(\"P1=\"+p.color);\n    17:       System.out.println(\"P2=\"+p.age);\n    18: } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints Q1=blue."
      },
      {
        "key": "B",
        "text": "It prints Q2=1200."
      },
      {
        "key": "C",
        "text": "It prints P1=null."
      },
      {
        "key": "D",
        "text": "It prints P2=1400."
      },
      {
        "key": "E",
        "text": "Line 4 does not compile."
      },
      {
        "key": "F",
        "text": "Line 12 does not compile."
      },
      {
        "key": "G",
        "text": "Line 13 does not compile."
      },
      {
        "key": "H",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "What is the output of executing the following class?\n    1:  public class Salmon {\n    2:     int count;\n    3:     { System.out.print(count+\"- \"); }\n    4:     { count++; }\n    5:     public Salmon() {\n    6:        count = 4;\n    7:        System.out.print(2+\"- \");\n    8:     }\n    9:     public static void main(String[] args) {\n    10:       System.out.print(7+\"- \");\n    11:       var s = new Salmon();\n    12:       System.out.print(s.count+\"- \"); } }",
    "choices": [
      {
        "key": "A",
        "text": "7- 0- 2- 1- "
      },
      {
        "key": "B",
        "text": "7- 0- 1- "
      },
      {
        "key": "C",
        "text": "0- 7- 2- 1- "
      },
      {
        "key": "D",
        "text": "7- 0- 2- 4- "
      },
      {
        "key": "E",
        "text": "0- 7- 1- "
      },
      {
        "key": "F",
        "text": "The class does not compile because of line 3."
      },
      {
        "key": "G",
        "text": "The class does not compile because of line 4."
      },
      {
        "key": "H",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Given the following class, which of the following lines of code can independently replace \nINSERT CODE HERE to make the code compile? (Choose all that apply.)\n    public class Price {\n       public void admission() {\n          INSERT CODE HERE\n          System.out.print(amount);\n          } }",
    "choices": [
      {
        "key": "A",
        "text": "int Amount = 0b11;"
      },
      {
        "key": "B",
        "text": "int amount = 9L;"
      },
      {
        "key": "C",
        "text": "int amount = 0xE;"
      },
      {
        "key": "D",
        "text": "int amount = 1_2.0;"
      },
      {
        "key": "E",
        "text": "double amount = 1_0_.0;"
      },
      {
        "key": "F",
        "text": "int amount = 0b101;"
      },
      {
        "key": "G",
        "text": "double amount = 9_2.1_2;"
      },
      {
        "key": "H",
        "text": "double amount = 1_2_.0_0;\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "Which statements about the following class are true? (Choose all that apply.)\n    1:  public class River {\n    2:     int Depth = 1;\n    3:     float temp = 50.0;\n    4:     public void flow() {\n    5:        for (int i = 0; i < 1; i++) {\n    6:           int depth = 2;\n    7:           depth++;\n    8:           temp- - ;\n    9:        }\n    10:       System.out.println(depth);\n    11:       System.out.println(temp); }\n    12:    public static void main(String... s) {\n    13:       new River().flow();\n    14: } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 10 generates a compiler error."
      },
      {
        "key": "E",
        "text": "The program prints 3 on line 10."
      },
      {
        "key": "F",
        "text": "The program prints 4 on line 10."
      },
      {
        "key": "G",
        "text": "The program prints 50.0 on line 11."
      },
      {
        "key": "H",
        "text": "The program prints 49.0 on line 11.\n\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "Which of the following Java operators can be used with boolean variables? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "=="
      },
      {
        "key": "B",
        "text": "+"
      },
      {
        "key": "C",
        "text": "- - "
      },
      {
        "key": "D",
        "text": "!"
      },
      {
        "key": "E",
        "text": "%"
      },
      {
        "key": "F",
        "text": "~"
      },
      {
        "key": "G",
        "text": "Cast with (boolean)\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "What data type (or types) will allow the following code snippet to compile? (Choose all \nthat apply.)\n    byte apples = 5;\n    short oranges = 10;\n    _____ bananas = apples + oranges;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "long"
      },
      {
        "key": "C",
        "text": "boolean"
      },
      {
        "key": "D",
        "text": "double"
      },
      {
        "key": "E",
        "text": "short"
      },
      {
        "key": "F",
        "text": "byte\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "What change, when applied independently, would allow the following code snippet to  \ncompile? (Choose all that apply.)\n    3: long ear = 10;\n    4: int hearing = 2 * ear;",
    "choices": [
      {
        "key": "A",
        "text": "No change; it compiles as is."
      },
      {
        "key": "B",
        "text": "Cast ear on line 4 to int."
      },
      {
        "key": "C",
        "text": "Change the data type of ear on line 3 to short."
      },
      {
        "key": "D",
        "text": "Cast 2 * ear on line 4 to int."
      },
      {
        "key": "E",
        "text": "Change the data type of hearing on line 4 to short."
      },
      {
        "key": "F",
        "text": "Change the data type of hearing on line 4 to long.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    3: boolean canine = true, wolf = true;\n    4: int teeth = 20;\n    5: canine = (teeth != 10) ^ (wolf=false);\n    6: System.out.println(canine+\", \"+teeth+\", \"+wolf);",
    "choices": [
      {
        "key": "A",
        "text": "true, 20, true"
      },
      {
        "key": "B",
        "text": "true, 20, false"
      },
      {
        "key": "C",
        "text": "false, 10, true"
      },
      {
        "key": "D",
        "text": "false, 20, false"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which of the following operators are ranked in increasing or the same order of precedence? \nAssume the + operator is binary addition, not the unary form. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "+, *, %, - - "
      },
      {
        "key": "B",
        "text": "++, (int), *"
      },
      {
        "key": "C",
        "text": "=, ==, !"
      },
      {
        "key": "D",
        "text": "(short), =, !, *"
      },
      {
        "key": "E",
        "text": "*, /, %, +, =="
      },
      {
        "key": "F",
        "text": "!, ||, &"
      },
      {
        "key": "G",
        "text": "^, +, =, +=\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "What is the output of the following program?\n    1: public class CandyCounter {\n    2:    static long addCandy(double fruit, float vegetables) {\n    3:       return (int)fruit+vegetables;\n    4:    }\n    5:    \n    6:    public static void main(String[] args) {\n    7:       System.out.print(addCandy(1.4, 2.4f) + \", \");\n    8:       System.out.print(addCandy(1.9, (float)4) + \", \");\n    9:       System.out.print(addCandy((long)(int)(short)2, (float)4)); } }",
    "choices": [
      {
        "key": "A",
        "text": "4, 6, 6.0"
      },
      {
        "key": "B",
        "text": "3, 5, 6"
      },
      {
        "key": "C",
        "text": "3, 6, 6"
      },
      {
        "key": "D",
        "text": "4, 5, 6"
      },
      {
        "key": "E",
        "text": "The code does not compile because of line 9."
      },
      {
        "key": "F",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    int ph = 7, vis = 2;\n    boolean clear = vis > 1 & (vis < 9 || ph < 2);\n    boolean safe = (vis > 2) && (ph++ > 1);\n    boolean tasty = 7 <= - - ph;\n    System.out.println(clear + \"- \" + safe + \"- \" + tasty);",
    "choices": [
      {
        "key": "A",
        "text": "true- true- true"
      },
      {
        "key": "B",
        "text": "true- true- false"
      },
      {
        "key": "C",
        "text": "true- false- true"
      },
      {
        "key": "D",
        "text": "true- false- false"
      },
      {
        "key": "E",
        "text": "false- true- true"
      },
      {
        "key": "F",
        "text": "false- true- false"
      },
      {
        "key": "G",
        "text": "false- false- true"
      },
      {
        "key": "H",
        "text": "false- false- false\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    4: int pig = (short)4;\n    5: pig = pig++;\n    6: long goat = (int)2;\n    7: goat - = 1.0;\n    8: System.out.print(pig + \" -  \" + goat);",
    "choices": [
      {
        "key": "A",
        "text": "4 -  1"
      },
      {
        "key": "B",
        "text": "4 -  2"
      },
      {
        "key": "C",
        "text": "5 -  1"
      },
      {
        "key": "D",
        "text": "5 -  2"
      },
      {
        "key": "E",
        "text": "The code does not compile due to line 7."
      },
      {
        "key": "F",
        "text": "None of the above.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)\n    int a = 2, b = 4, c = 2;\n    System.out.println(a > 2 ? - - c : b++);\n    System.out.println(b = (a!=c ? a : b++));\n    System.out.println(a > b ? b < c ? b : 2 : 1);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)\n    short height = 1, weight = 3;\n    short zebra = (byte) weight * (byte) height;\n    double ox = 1 + height * 2 + weight;\n    long giraffe = 1 + 9 % height + 1;\n    System.out.println(zebra);\n    System.out.println(ox);\n    System.out.println(giraffe);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What is the output of the following code?\n    11: int sample1 = (2 * 4) % 3;\n    12: int sample2 = 3 * 2 % 3;\n    13: int sample3 = 5 * (1 % 2);\n    14: System.out.println(sample1 + \", \" + sample2 + \", \" + sample3);",
    "choices": [
      {
        "key": "A",
        "text": "0, 0, 5"
      },
      {
        "key": "B",
        "text": "1, 2, 10"
      },
      {
        "key": "C",
        "text": "2, 1, 5"
      },
      {
        "key": "D",
        "text": "2, 0, 5"
      },
      {
        "key": "E",
        "text": "3, 1, 10"
      },
      {
        "key": "F",
        "text": "3, 2, 6"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "The _________ operator increases a value and returns the original value, while the _______ \noperator decreases a value and returns the new value.",
    "choices": [
      {
        "key": "A",
        "text": "post- increment, post- increment"
      },
      {
        "key": "B",
        "text": "pre- decrement, post- decrement"
      },
      {
        "key": "C",
        "text": "post- increment, post- decrement"
      },
      {
        "key": "D",
        "text": "post- increment, pre- decrement"
      },
      {
        "key": "E",
        "text": "pre- increment, pre- decrement"
      },
      {
        "key": "F",
        "text": "pre- increment, post- decrement\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    boolean sunny = true, raining = false, sunday = true;\n    boolean goingToTheStore = sunny & raining ^ sunday;\n    boolean goingToTheZoo = sunday && !raining;\n    boolean stayingHome = !(goingToTheStore && goingToTheZoo);\n    System.out.println(goingToTheStore + \"- \" + goingToTheZoo \n       + \"- \" +stayingHome);",
    "choices": [
      {
        "key": "A",
        "text": "true- false- false"
      },
      {
        "key": "B",
        "text": "false- true- false"
      },
      {
        "key": "C",
        "text": "true- true- true"
      },
      {
        "key": "D",
        "text": "false- true- true"
      },
      {
        "key": "E",
        "text": "false- false- false"
      },
      {
        "key": "F",
        "text": "true- true- false"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following statements are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The return value of an assignment operation expression can be void."
      },
      {
        "key": "B",
        "text": "The inequality operator (!=) can be used to compare objects."
      },
      {
        "key": "C",
        "text": "The equality operator (==) can be used to compare a boolean value with a numeric \nvalue."
      },
      {
        "key": "D",
        "text": "During runtime, the & and | operators may cause only the left side of the expression to \nbe evaluated."
      },
      {
        "key": "E",
        "text": "The return value of an assignment operation expression is the value of the newly \nassigned variable."
      },
      {
        "key": "F",
        "text": "In Java, 0 and false may be used interchangeably."
      },
      {
        "key": "G",
        "text": "The logical complement operator (!) cannot be used to flip numeric values.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which operators take three operands or values? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "="
      },
      {
        "key": "B",
        "text": "&&"
      },
      {
        "key": "C",
        "text": "*="
      },
      {
        "key": "D",
        "text": "? :"
      },
      {
        "key": "E",
        "text": "&"
      },
      {
        "key": "F",
        "text": "++"
      },
      {
        "key": "G",
        "text": "/\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "How many lines of the following code contain compiler errors?\n    int note = 1 * 2 + (long)3;\n    short melody = (byte)(double)(note *= 2);\n    double song = melody;\n    float symphony = (float)((song == 1_000f) ? song * 2L : song);",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Given the following code snippet, what are the values of the variables after it is executed? \n(Choose all that apply.)\n    int ticketsTaken = 1;\n    int ticketsSold = 3;\n    ticketsSold += 1 + ticketsTaken++;\n    ticketsTaken *= 2;\n    ticketsSold += (long)1;",
    "choices": [
      {
        "key": "A",
        "text": "ticketsSold is 8."
      },
      {
        "key": "B",
        "text": "ticketsTaken is 2."
      },
      {
        "key": "C",
        "text": "ticketsSold is 6."
      },
      {
        "key": "D",
        "text": "ticketsTaken is 6."
      },
      {
        "key": "E",
        "text": "ticketsSold is 7."
      },
      {
        "key": "F",
        "text": "ticketsTaken is 4."
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which of the following can be used to change the order of operation in an expression? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "[ ]"
      },
      {
        "key": "B",
        "text": "< >"
      },
      {
        "key": "C",
        "text": "( )"
      },
      {
        "key": "D",
        "text": "\\ /"
      },
      {
        "key": "E",
        "text": "{ }"
      },
      {
        "key": "F",
        "text": "\" \"\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the result of executing the following code snippet? (Choose all that apply.)\n    3: int start = 7;\n    4: int end = 4;\n    5: end += ++start;\n    6: start = (byte)(Byte.MAX_VALUE + 1);",
    "choices": [
      {
        "key": "A",
        "text": "start is 0."
      },
      {
        "key": "B",
        "text": "start is - 128."
      },
      {
        "key": "C",
        "text": "start is 127."
      },
      {
        "key": "D",
        "text": "end is 8."
      },
      {
        "key": "E",
        "text": "end is 11."
      },
      {
        "key": "F",
        "text": "end is 12."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "The code compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which of the following statements about unary operators are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Unary operators are always executed before any surrounding numeric binary or ternary \noperators."
      },
      {
        "key": "B",
        "text": "The -  operator can be used to flip a boolean value."
      },
      {
        "key": "C",
        "text": "The pre- increment operator (++) returns the value of the variable before the increment is \napplied."
      },
      {
        "key": "D",
        "text": "The post- decrement operator (- - ) returns the value of the variable before the decrement \nis applied."
      },
      {
        "key": "E",
        "text": "The ! operator cannot be used on numeric values."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "What is the result of executing the following code snippet?\n    int myFavoriteNumber = 8;\n    int bird = ~myFavoriteNumber;\n    int plane = - myFavoriteNumber;\n    var superman = bird == plane ? 5 : 10;\n    System.out.println(bird + \",\" + plane + \",\" + - - superman);",
    "choices": [
      {
        "key": "A",
        "text": "- 7,- 8,9"
      },
      {
        "key": "B",
        "text": "- 7,- 8,10"
      },
      {
        "key": "C",
        "text": "- 8,- 8,4"
      },
      {
        "key": "D",
        "text": "- 8,- 8,5"
      },
      {
        "key": "E",
        "text": "- 9,- 8,9"
      },
      {
        "key": "F",
        "text": "- 9,- 8,10"
      },
      {
        "key": "G",
        "text": "None of the above\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which of the following data types can be used in a switch expression? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "enum"
      },
      {
        "key": "B",
        "text": "int"
      },
      {
        "key": "C",
        "text": "Byte"
      },
      {
        "key": "D",
        "text": "long"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "char"
      },
      {
        "key": "G",
        "text": "var"
      },
      {
        "key": "H",
        "text": "double\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    3: int temperature = 4;\n    4: long humidity = - temperature + temperature * 3;\n    5: if (temperature>=4)\n    6: if (humidity < 6) System.out.println(\"Too Low\");\n    7: else System.out.println(\"Just Right\");\n    8: else System.out.println(\"Too High\");",
    "choices": [
      {
        "key": "A",
        "text": "Too Low"
      },
      {
        "key": "B",
        "text": "Just Right"
      },
      {
        "key": "C",
        "text": "Too High"
      },
      {
        "key": "D",
        "text": "A NullPointerException is thrown at runtime."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following data types are permitted on the right side of a for- each expression? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Double[][]"
      },
      {
        "key": "B",
        "text": "Object"
      },
      {
        "key": "C",
        "text": "Map"
      },
      {
        "key": "D",
        "text": "List"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "char[]"
      },
      {
        "key": "G",
        "text": "Exception"
      },
      {
        "key": "H",
        "text": "Set\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "What is the output of calling printReptile(6)?\n    void printReptile(int category) {\n      var type = switch(category) {\n          case 1,2 - > \"Snake\";\n          case 3,4 - > \"Lizard\";\n          case 5,6 - > \"Turtle\";\n          case 7,8 - > \"Alligator\";\n       };\n       System.out.print(type);\n    }",
    "choices": [
      {
        "key": "A",
        "text": "Snake"
      },
      {
        "key": "B",
        "text": "Lizard"
      },
      {
        "key": "C",
        "text": "Turtle"
      },
      {
        "key": "D",
        "text": "Alligator"
      },
      {
        "key": "E",
        "text": "TurtleAlligator"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n     List<Integer> myFavoriteNumbers = new ArrayList<>();\n     myFavoriteNumbers.add(10);\n     myFavoriteNumbers.add(14);\n     for (var a : myFavoriteNumbers) {\n        System.out.print(a + \", \");\n        break;\n     } \n     for (int b : myFavoriteNumbers) {\n        continue;\n        System.out.print(b + \", \");\n     } \n     for (Object c : myFavoriteNumbers)\n        System.out.print(c + \", \");",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue but does not produce any output."
      },
      {
        "key": "B",
        "text": "10, 14,"
      },
      {
        "key": "C",
        "text": "10, 10, 14,"
      },
      {
        "key": "D",
        "text": "10, 10, 14, 10, 14,"
      },
      {
        "key": "E",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "F",
        "text": "Exactly two lines of code do not compile."
      },
      {
        "key": "G",
        "text": "Three or more lines of code do not compile."
      },
      {
        "key": "H",
        "text": "The code contains an infinite loop and does not terminate.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which statements about decision structures are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A for- each loop can be executed on any Collections Framework object."
      },
      {
        "key": "B",
        "text": "The body of a while loop is guaranteed to be executed at least once."
      },
      {
        "key": "C",
        "text": "The conditional expression of a for loop is evaluated before the first execution of the \nloop body."
      },
      {
        "key": "D",
        "text": "A switch expression that takes a String and assigns the result to a variable requires a \ndefault branch."
      },
      {
        "key": "E",
        "text": "The body of a do/while loop is guaranteed to be executed at least once."
      },
      {
        "key": "F",
        "text": "An if statement can have multiple corresponding else statements.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Assuming weather is a well- formed nonempty array, which code snippet, when inserted \nindependently into the blank in the following code, prints all of the elements of weather? \n(Choose all that apply.)\n     private void print(int[] weather) {\n        for( ) {\n           System.out.println(weather[i]);\n        }\n     }",
    "choices": [
      {
        "key": "A",
        "text": "int i=weather.length; i>0; i- - "
      },
      {
        "key": "B",
        "text": "int i=0; i<=weather.length- 1; ++i"
      },
      {
        "key": "C",
        "text": "var w : weather"
      },
      {
        "key": "D",
        "text": "int i=weather.length- 1; i>=0; i- - "
      },
      {
        "key": "E",
        "text": "int i=0, int j=3; i<weather.length; ++i"
      },
      {
        "key": "F",
        "text": "int i=0; ++i<10 && i<weather.length;"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "What is the output of calling printType(11)?\n    31: void printType(Object o) {\n    32:    if(o instanceof Integer bat) {\n    33:       System.out.print(\"int\");\n    34:    } else if(o instanceof Integer bat && bat < 10) {\n    35:       System.out.print(\"small int\");\n    36:    } else if(o instanceof Long bat || bat <= 20) {\n    37:       System.out.print(\"long\");\n    38:    } default {\n    39:       System.out.print(\"unknown\");\n    40:    }\n    41: }",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "small int"
      },
      {
        "key": "C",
        "text": "long"
      },
      {
        "key": "D",
        "text": "unknown"
      },
      {
        "key": "E",
        "text": "Nothing is printed."
      },
      {
        "key": "F",
        "text": "The code contains one line that does not compile."
      },
      {
        "key": "G",
        "text": "The code contains two lines that do not compile."
      },
      {
        "key": "H",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which statements, when inserted independently into the following blank, will cause the code \nto print 2 at runtime? (Choose all that apply.)\n     int count = 0;\n     BUNNY: for(int row = 1; row <=3; row++)\n        RABBIT: for(int col = 0; col <3 ; col++) {\n           if((col + row) % 2 == 0)\n              ;\n           count++;\n        }\n     System.out.println(count);",
    "choices": [
      {
        "key": "A",
        "text": "break BUNNY"
      },
      {
        "key": "B",
        "text": "break RABBIT"
      },
      {
        "key": "C",
        "text": "continue BUNNY"
      },
      {
        "key": "D",
        "text": "continue RABBIT"
      },
      {
        "key": "E",
        "text": "break"
      },
      {
        "key": "F",
        "text": "continue"
      },
      {
        "key": "G",
        "text": "None of the above, as the code contains a compiler error.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Given the following method, how many lines contain compilation errors? (Choose all \nthat apply.)\n    10: private DayOfWeek getWeekDay(int day, final int thursday) {\n    11:    int otherDay = day;\n    12:    int Sunday = 0;\n    13:    switch(otherDay) {\n    14:       default:\n    15:       case 1: continue; \n    16:       case thursday: return DayOfWeek.THURSDAY;\n    17:       case 2,10: break;\n    18:       case Sunday: return DayOfWeek.SUNDAY;\n    19:       case DayOfWeek.MONDAY: return DayOfWeek.MONDAY;\n    20:    }\n    21:    return DayOfWeek.FRIDAY;\n    22: }",
    "choices": [
      {
        "key": "A",
        "text": "None, the code compiles without issue."
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      },
      {
        "key": "G",
        "text": "6"
      },
      {
        "key": "H",
        "text": "The code compiles but may produce an error at runtime.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What is the output of calling printLocation(Animal.MAMMAL)?\n    10: class Zoo {\n    11:    enum Animal {BIRD, FISH, MAMMAL}\n    12:    void printLocation(Animal a) {\n    13:       long type = switch(a) {\n    14:          case BIRD - > 1;\n    15:          case FISH - > 2;\n    16:          case MAMMAL - > 3;\n    17:          default - > 4;\n    18:       };\n    19:       System.out.print(type);\n    20:    } }",
    "choices": [
      {
        "key": "A",
        "text": "3"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "34"
      },
      {
        "key": "D",
        "text": "The code does not compile because of line 13."
      },
      {
        "key": "E",
        "text": "The code does not compile because of line 17."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "What is the result of the following code snippet?\n    3: int sing = 8, squawk = 2, notes = 0;\n    4: while(sing > squawk) {\n    5:    sing- - ;\n    6:    squawk += 2;\n    7:    notes += sing + squawk;\n    8: }\n    9: System.out.println(notes);",
    "choices": [
      {
        "key": "A",
        "text": "11"
      },
      {
        "key": "B",
        "text": "13"
      },
      {
        "key": "C",
        "text": "23"
      },
      {
        "key": "D",
        "text": "33"
      },
      {
        "key": "E",
        "text": "50"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 7.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    2: boolean keepGoing = true;\n    3: int result = 15, meters = 10;\n    4: do {\n    5:    meters- - ;\n    6:    if(meters==8) keepGoing = false;\n    7:    result - = 2;\n    8: } while keepGoing;\n    9: System.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "11"
      },
      {
        "key": "E",
        "text": "15"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "G",
        "text": "The code does not compile for a different reason.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which statements about the following code snippet are correct? (Choose all that apply.)\n     for(var penguin : new int[2])\n        System.out.println(penguin); \n     var ostrich = new Character[3];\n     for(var emu : ostrich)\n        System.out.println(emu); \n     List<Integer> parrots = new ArrayList<Integer>();\n     for(var macaw  : parrots)\n        System.out.println(macaw);",
    "choices": [
      {
        "key": "A",
        "text": "The data type of penguin is Integer."
      },
      {
        "key": "B",
        "text": "The data type of penguin is int."
      },
      {
        "key": "C",
        "text": "The data type of emu is undefined."
      },
      {
        "key": "D",
        "text": "The data type of emu is Character."
      },
      {
        "key": "E",
        "text": "The data type of macaw is List."
      },
      {
        "key": "F",
        "text": "The data type of macaw is Integer."
      },
      {
        "key": "G",
        "text": "None of the above, as the code does not compile.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "What is the result of the following code snippet?\n     final char a = 'A', e = 'E';\n     char grade = 'B';\n     switch (grade) {\n        default:\n        case a:\n        case 'B': 'C': System.out.print(\"great \");\n        case 'D': System.out.print(\"good \"); break;\n        case e:\n        case 'F': System.out.print(\"not good \");\n     }",
    "choices": [
      {
        "key": "A",
        "text": "great"
      },
      {
        "key": "B",
        "text": "great good"
      },
      {
        "key": "C",
        "text": "good"
      },
      {
        "key": "D",
        "text": "not good"
      },
      {
        "key": "E",
        "text": "The code does not compile because the data type of one or more case statements does \nnot match the data type of the switch variable."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Given the following array, which code snippets print the elements in reverse order from how \nthey are declared? (Choose all that apply.)\n     char[] wolf = {'W', 'e', 'b', 'b', 'y'};\nA. \n     int q = wolf.length;\n     for( ; ; ) {\n        System.out.print(wolf[- - q]);\n        if(q==0) break;\n     }\nB. \n     for(int m=wolf.length- 1; m>=0; - - m)\n        System.out.print(wolf[m]);\nC. \n     for(int z=0; z<wolf.length; z++)\n        System.out.print(wolf[wolf.length- z]);\nD. \n     int x = wolf.length- 1;\n     for(int j=0; x>=0 && j==0; x- - )\n        System.out.print(wolf[x]);\nE. \n     final int r = wolf.length;\n     for(int w = r- 1; r>- 1; w = r- 1)\n        System.out.print(wolf[w]);\nF. \n     for(int i=wolf.length; i>0; - - i)\n        System.out.print(wolf[i]);",
    "choices": [
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What distinct numbers are printed when the following method is executed? (Choose all \nthat apply.)\n     private void countAttendees() {\n        int participants = 4, animals = 2, performers = - 1; \n        while((participants = participants+1) < 10) {}\n        do {} while (animals++ <= 1);\n        for( ; performers<2; performers+=2) {} \n        System.out.println(participants);\n        System.out.println(animals);\n        System.out.println(performers);\n     }",
    "choices": [
      {
        "key": "A",
        "text": "6"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "4"
      },
      {
        "key": "D",
        "text": "5"
      },
      {
        "key": "E",
        "text": "10"
      },
      {
        "key": "F",
        "text": "9"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which statements about pattern matching and flow scoping are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Pattern matching with an if statement is implemented using the instance operator."
      },
      {
        "key": "B",
        "text": "Pattern matching with an if statement is implemented using the instanceon operator."
      },
      {
        "key": "C",
        "text": "Pattern matching with an if statement is implemented using the instanceof operator."
      },
      {
        "key": "D",
        "text": "The pattern variable cannot be accessed after the if statement in which it is declared."
      },
      {
        "key": "E",
        "text": "Flow scoping means a pattern variable is only accessible if the compiler can discern its \ntype."
      },
      {
        "key": "F",
        "text": "Pattern matching can be used to declare a variable with an else statement.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    2: double iguana = 0;\n    3: do {\n    4:    int snake = 1;\n    5:    System.out.print(snake++ + \" \");\n    6:    iguana- - ;\n    7: } while (snake <= 5);\n    8: System.out.println(iguana);",
    "choices": [
      {
        "key": "A",
        "text": "1 2 3 4 - 4.0"
      },
      {
        "key": "B",
        "text": "1 2 3 4 - 5.0"
      },
      {
        "key": "C",
        "text": "1 2 3 4 5 - 4.0"
      },
      {
        "key": "D",
        "text": "0 1 2 3 4 5 - 5.0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an infinite loop at runtime."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which statements, when inserted into the following blanks, allow the code to compile and \nrun without entering an infinite loop? (Choose all that apply.)\n    4:  int height = 1;\n    5:  L1: while(height++ <10) {\n    6:     long humidity = 12;\n    7:     L2: do {\n    8:        if(humidity- -  % 12 == 0) ;\n    9:        int temperature = 30;\n    10:       L3: for( ; ; ) {\n    11:          temperature++;\n    12:          if(temperature>50) ;\n    13:       }\n    14:    } while (humidity > 4);\n    15: }",
    "choices": [
      {
        "key": "A",
        "text": "break L2 on line 8; continue L2 on line 12"
      },
      {
        "key": "B",
        "text": "continue on line 8; continue on line 12"
      },
      {
        "key": "C",
        "text": "break L3 on line 8; break L1 on line 12"
      },
      {
        "key": "D",
        "text": "continue L2 on line 8; continue L3 on line 12"
      },
      {
        "key": "E",
        "text": "continue L2 on line 8; continue L2 on line 12"
      },
      {
        "key": "F",
        "text": "None of the above, as the code contains a compiler error\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "A minimum of how many lines need to be corrected before the following method \nwill compile?\n    21: void findZookeeper(Long id) {\n    22:    System.out.print(switch(id) {\n    23:       case 10 - > {\"Jane\"}\n    24:       case 20 - > {yield \"Lisa\";};\n    25:       case 30 - > \"Kelly\";\n    26:       case 30 - > \"Sarah\";\n    27:       default - > \"Unassigned\";\n    28:    });\n    29: }",
    "choices": [
      {
        "key": "A",
        "text": "Zero"
      },
      {
        "key": "B",
        "text": "One"
      },
      {
        "key": "C",
        "text": "Two"
      },
      {
        "key": "D",
        "text": "Three"
      },
      {
        "key": "E",
        "text": "Four"
      },
      {
        "key": "F",
        "text": "Five\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    2: var tailFeathers = 3;\n    3: final var one = 1;\n    4: switch (tailFeathers) {\n    5:    case one: System.out.print(3 + \" \");\n    6:    default: case 3: System.out.print(5 + \" \");\n    7: }\n    8: while (tailFeathers > 1) {\n    9:    System.out.print(- - tailFeathers + \" \"); }",
    "choices": [
      {
        "key": "A",
        "text": "3"
      },
      {
        "key": "B",
        "text": "5 1"
      },
      {
        "key": "C",
        "text": "5 2"
      },
      {
        "key": "D",
        "text": "3 5 1"
      },
      {
        "key": "E",
        "text": "5 2 1"
      },
      {
        "key": "F",
        "text": "The code will not compile because of lines 3–5."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line 6.\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    15: int penguin = 50, turtle = 75;\n    16: boolean older = penguin >= turtle;\n    17: if (older = true) System.out.println(\"Success\");\n    18: else System.out.println(\"Failure\");\n    19: else if(penguin != 50) System.out.println(\"Other\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "Other"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 17."
      },
      {
        "key": "E",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "Which of the following are possible data types for friends that would allow the code to \ncompile? (Choose all that apply.)\n     for(var friend in friends) {\n        System.out.println(friend);\n     }",
    "choices": [
      {
        "key": "A",
        "text": "Set"
      },
      {
        "key": "B",
        "text": "Map"
      },
      {
        "key": "C",
        "text": "String"
      },
      {
        "key": "D",
        "text": "int[]"
      },
      {
        "key": "E",
        "text": "Collection"
      },
      {
        "key": "F",
        "text": "StringBuilder"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "What is the output of the following code snippet?\n    6:  String instrument = \"violin\";\n    7:  final String CELLO = \"cello\";\n    8:  String viola = \"viola\";\n    9:  int p = - 1;\n    10: switch(instrument) {\n    11:    case \"bass\" : break;\n    12:    case CELLO : p++;\n    13:    default: p++;\n    14:    case \"VIOLIN\": p++;\n    15:    case \"viola\" : ++p; break;\n    16: }\n    17: System.out.print(p);",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "1"
      },
      {
        "key": "D",
        "text": "2"
      },
      {
        "key": "E",
        "text": "3"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    9:  int w = 0, r = 1;\n    10: String name = \"\";\n    11: while(w < 2) {\n    12:    name += \"A\";\n    13:    do {\n    14:       name += \"B\";\n    15:       if(name.length()>0) name += \"C\";\n    16:       else break;\n    17:    } while (r <=1);\n    18:    r++; w++; }\n    19: System.out.println(name);",
    "choices": [
      {
        "key": "A",
        "text": "ABC"
      },
      {
        "key": "B",
        "text": "ABCABC"
      },
      {
        "key": "C",
        "text": "ABCABCABC"
      },
      {
        "key": "D",
        "text": "Line 15 contains a compilation error."
      },
      {
        "key": "E",
        "text": "Line 18 contains a compilation error."
      },
      {
        "key": "F",
        "text": "The code compiles but never terminates at runtime."
      },
      {
        "key": "G",
        "text": "The code compiles but throws a NullPointerException at runtime.\n2 7. What is printed by the following code snippet?\n    23: byte amphibian = 1;\n    24: String name = \"Frog\";\n    25: String color = switch(amphibian) {\n    26:    case 1 - > { yield \"Red\"; } \n    27:    case 2 - > { if(name.equals(\"Frog\")) yield \"Green\"; }\n    28:    case 3 - > { yield \"Purple\"; }\n    29:    default - > throw new RuntimeException();\n    30: };\n    31: System.out.print(color);"
      },
      {
        "key": "A",
        "text": "Red"
      },
      {
        "key": "B",
        "text": "Green"
      },
      {
        "key": "C",
        "text": "Purple"
      },
      {
        "key": "D",
        "text": "RedPurple"
      },
      {
        "key": "E",
        "text": "An exception is thrown at runtime."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The try block is not capable of throwing an IOException, making the catch block \nunreachable code and option A incorrect. Options B and F are correct, as both are unchecked \nexceptions that do not extend or inherit from IllegalArgumentException. Remember, \nit is not a good idea to catch Error in practice, although because it is possible, it may come \nup on the exam. Option C is incorrect because the variable c is declared already in the \nmethod declaration. Option D is incorrect because the IllegalArgumentException\ninherits from RuntimeException, making the first declaration unnecessary. \nSimilarly, option E is incorrect because NumberFormatException inherits from \nIllegalArgumentException, making the second declaration unnecessary. Since options \nB and F are correct, option G is incorrect.\nChapter 12: Modules 949\nChapter 12: Modules\n"
  },
  {
    "question": "What is the output of calling getFish(\"goldie\")?\n    40: void getFish(Object fish) {\n    41:    if (!(fish instanceof String guppy))\n    42:       System.out.print(\"Eat!\");\n    43:    else if (!(fish instanceof String guppy)) {\n    44:       throw new RuntimeException();\n    45:    }\n    46:    System.out.print(\"Swim!\");\n    47: }",
    "choices": [
      {
        "key": "A",
        "text": "Eat!"
      },
      {
        "key": "B",
        "text": "Swim!"
      },
      {
        "key": "C",
        "text": "Eat! followed by an exception."
      },
      {
        "key": "D",
        "text": "Eat!Swim!"
      },
      {
        "key": "E",
        "text": "An exception is printed."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Camel does not compile because the travel() method does not declare a \nbody, nor is it marked abstract, making option A correct. EatsGrass also does not \ncompile because an interface method cannot be marked both private and abstract, \nmaking option B correct. Finally, Eagle does not compile because it declares an abstract \nmethod soar() in a concrete class, making option D correct. The other classes compile \nwithout issue.\n\n"
  },
  {
    "question": "What is the result of the following code?\n    1: public class PrintIntegers {\n    2:    public static void main(String[] args) {\n    3:       int y = - 2;\n    4:       do System.out.print(++y + \" \"); \n    5:       while(y <= 5);\n    6: } }",
    "choices": [
      {
        "key": "A",
        "text": "- 2 - 1 0 1 2 3 4 5"
      },
      {
        "key": "B",
        "text": "- 2 - 1 0 1 2 3 4"
      },
      {
        "key": "C",
        "text": "- 1 0 1 2 3 4 5 6"
      },
      {
        "key": "D",
        "text": "- 1 0 1 2 3 4 5"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code contains an infinite loop and does not terminate.\n\n"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile, so options A through C are incorrect. Both lines 5 and 12 do \nnot compile, as this() is used instead of this. Remember, this() refers to calling a con\u0002structor, whereas this is a reference to the current instance. Next, the compiler does not \nallow casting to an unrelated class type. Since Orangutan is not a subclass of Primate, the \ncast on line 15 is invalid, and the code does not compile. Due to these three lines containing \ncompilation errors, option F is the correct answer.\n"
  },
  {
    "question": "What is output by the following code? (Choose all that apply.)\n1: public class Fish {\n2:    public static void main(String[] args) {\n3:       int numFish = 4;\n4:       String fishType = \"tuna\";\n5:       String anotherFish = numFish + 1;\n6:       System.out.println(anotherFish + \" \" + fishType);\n7:       System.out.println(numFish + \" \" + 1);\n8: } }",
    "choices": [
      {
        "key": "A",
        "text": "4 1"
      },
      {
        "key": "B",
        "text": "5"
      },
      {
        "key": "C",
        "text": "5 tuna"
      },
      {
        "key": "D",
        "text": "5tuna"
      },
      {
        "key": "E",
        "text": "51tuna"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which of these array declarations are not legal? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "int[][] scores = new int[5][];"
      },
      {
        "key": "B",
        "text": "Object[][][] cubbies = new Object[3][0][5];"
      },
      {
        "key": "C",
        "text": "String beans[] = new beans[6];"
      },
      {
        "key": "D",
        "text": "java.util.Date[] dates[] = new java.util.Date[2][];"
      },
      {
        "key": "E",
        "text": "int[][] types = new int[];"
      },
      {
        "key": "F",
        "text": "int[][] java = new int[][];\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Note that March 13, 2022 is the weekend when we spring forward, and November 6, 2022 \nis when we fall back for daylight saving time. Which of the following can fill in the blank \nwithout the code throwing an exception? (Choose all that apply.)\nvar zone = ZoneId.of(\"US/Eastern\");\nvar date =                                ;\nvar time = LocalTime.of(2, 15);\nvar z = ZonedDateTime.of(date, time, zone);",
    "choices": [
      {
        "key": "A",
        "text": "LocalDate.of(2022, 3, 13)"
      },
      {
        "key": "B",
        "text": "LocalDate.of(2022, 3, 40)"
      },
      {
        "key": "C",
        "text": "LocalDate.of(2022, 11, 6)"
      },
      {
        "key": "D",
        "text": "LocalDate.of(2022, 11, 7)"
      },
      {
        "key": "E",
        "text": "LocalDate.of(2023, 2, 29)"
      },
      {
        "key": "F",
        "text": "LocalDate.of(2022, MonthEnum.MARCH, 13);\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which of the following are output by this code? (Choose all that apply.)\n3: var s = \"Hello\";\n4: var t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.intern() == s) System.out.println(\"three\");\n8: if (\"Hello\" == s) System.out.println(\"four\");\n9: if (\"Hello\".intern() == t) System.out.println(\"five\");",
    "choices": [
      {
        "key": "A",
        "text": "one"
      },
      {
        "key": "B",
        "text": "two"
      },
      {
        "key": "C",
        "text": "three"
      },
      {
        "key": "D",
        "text": "four"
      },
      {
        "key": "E",
        "text": "five"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "What is the result of the following code?\n7: var sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
    "choices": [
      {
        "key": "A",
        "text": "abbaaccc"
      },
      {
        "key": "B",
        "text": "abbaccca"
      },
      {
        "key": "C",
        "text": "bbaaaccc"
      },
      {
        "key": "D",
        "text": "bbaaccca"
      },
      {
        "key": "E",
        "text": "An empty line"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "How many of these lines contain a compiler error? (Choose all that apply.)\n23: double one = Math.pow(1, 2);\n24: int two = Math.round(1.0);\n25: float three = Math.random();\n26: var doubles = new double[] {one, two, three};",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Which of these statements is true of the two values? (Choose all that apply.)\n2022–08–28T05:00 GMT- 04:00\n2022–08–28T09:00 GMT- 06:00",
    "choices": [
      {
        "key": "A",
        "text": "The first date/time is earlier."
      },
      {
        "key": "B",
        "text": "The second date/time is earlier."
      },
      {
        "key": "C",
        "text": "Both date/times are the same."
      },
      {
        "key": "D",
        "text": "The date/times are two hours apart."
      },
      {
        "key": "E",
        "text": "The date/times are six hours apart."
      },
      {
        "key": "F",
        "text": "The date/times are 10 hours apart.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following return 5 when run independently? (Choose all that apply.)\nvar string = \"12345\";\nvar builder = new StringBuilder(\"12345\");",
    "choices": [
      {
        "key": "A",
        "text": "builder.charAt(4)"
      },
      {
        "key": "B",
        "text": "builder.replace(2, 4, \"6\").charAt(3)"
      },
      {
        "key": "C",
        "text": "builder.replace(2, 5, \"6\").charAt(2)"
      },
      {
        "key": "D",
        "text": "string.charAt(5)"
      },
      {
        "key": "E",
        "text": "string.length"
      },
      {
        "key": "F",
        "text": "string.replace(\"123\", \"1\").charAt(2)"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of the following are true about arrays? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The first element is index 0."
      },
      {
        "key": "B",
        "text": "The first element is index 1."
      },
      {
        "key": "C",
        "text": "Arrays are fixed size."
      },
      {
        "key": "D",
        "text": "Arrays are immutable."
      },
      {
        "key": "E",
        "text": "Calling equals() on two different arrays containing the same primitive values always \nreturns true."
      },
      {
        "key": "F",
        "text": "Calling equals() on two different arrays containing the same primitive values always \nreturns false."
      },
      {
        "key": "G",
        "text": "Calling equals() on two different arrays containing the same primitive values can return \ntrue or false.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "How many of these lines contain a compiler error? (Choose all that apply.)\n23: int one = Math.min(5, 3);\n24: long two = Math.round(5.5);\n25: double three = Math.floor(6.6);\n26: var doubles = new double[] {one, two, three};",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What is the output of the following code?\nvar date = LocalDate.of(2022, 4, 3);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth()\n    + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 MARCH 4"
      },
      {
        "key": "B",
        "text": "2022 MARCH 6"
      },
      {
        "key": "C",
        "text": "2022 APRIL 3"
      },
      {
        "key": "D",
        "text": "2022 APRIL 5"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "What is output by the following code? (Choose all that apply.)\nvar numbers = \"012345678\".indent(1);\nnumbers = numbers.stripLeading();\nSystem.out.println(numbers.substring(1, 3));\nSystem.out.println(numbers.substring(7, 7));\nSystem.out.print(numbers.substring(7));",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "123"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "78"
      },
      {
        "key": "E",
        "text": "A blank line"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the result of the following code?\npublic class Lion {\n   public void roar(String roar1, StringBuilder roar2) {\n      roar1.concat(\"!!!\");\n      roar2.append(\"!!!\");\n   }\n   public static void main(String[] args) {\n      var roar1 = \"roar\";\n      var roar2 = new StringBuilder(\"roar\");\n      new Lion().roar(roar1, roar2);\n      System.out.println(roar1 + \" \" + roar2);\n} }",
    "choices": [
      {
        "key": "A",
        "text": "roar roar"
      },
      {
        "key": "B",
        "text": "roar roar!!!"
      },
      {
        "key": "C",
        "text": "roar!!! roar"
      },
      {
        "key": "D",
        "text": "roar!!! roar!!!"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Given the following, which can correctly fill in the blank? (Choose all that apply.)\nvar date = LocalDate.now();\nvar time = LocalTime.now();\nvar dateTime = LocalDateTime.now();\nvar zoneId = ZoneId.systemDefault();\nvar zonedDateTime = ZonedDateTime.of(dateTime, zoneId);\nInstant instant =                               ;",
    "choices": [
      {
        "key": "A",
        "text": "Instant.now()"
      },
      {
        "key": "B",
        "text": "new Instant()"
      },
      {
        "key": "C",
        "text": "date.toInstant()"
      },
      {
        "key": "D",
        "text": "dateTime.toInstant()"
      },
      {
        "key": "E",
        "text": "time.toInstant()"
      },
      {
        "key": "F",
        "text": "zonedDateTime.toInstant()\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "What is the output of the following? (Choose all that apply.)\nvar arr = new String[] { \"PIG\", \"pig\", \"123\"};\nArrays.sort(arr);\nSystem.out.println(Arrays.toString(arr));\nSystem.out.println(Arrays.binarySearch(arr, \"Pippa\"));",
    "choices": [
      {
        "key": "A",
        "text": "[pig, PIG, 123]"
      },
      {
        "key": "B",
        "text": "[PIG, pig, 123]"
      },
      {
        "key": "C",
        "text": "[123, PIG, pig]"
      },
      {
        "key": "D",
        "text": "[123, pig, PIG]"
      },
      {
        "key": "E",
        "text": "- 3"
      },
      {
        "key": "F",
        "text": "- 2"
      },
      {
        "key": "G",
        "text": "The results of binarySearch() are undefined in this example.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "What is included in the output of the following code? (Choose all that apply.)\nvar base = \"ewe\\nsheep\\\\t\";\nint length = base.length();\nint indent = base.indent(2).length();\nint translate = base.translateEscapes().length();\n \nvar formatted = \"%s %s %s\".formatted(length, indent, translate);\nSystem.out.format(formatted);",
    "choices": [
      {
        "key": "A",
        "text": "10"
      },
      {
        "key": "B",
        "text": "11"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "13"
      },
      {
        "key": "E",
        "text": "14"
      },
      {
        "key": "F",
        "text": "15"
      },
      {
        "key": "G",
        "text": "16\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which of these statements are true? (Choose all that apply.)\nvar letters = new StringBuilder(\"abcdefg\");",
    "choices": [
      {
        "key": "A",
        "text": "letters.substring(1, 2) returns a single- character String."
      },
      {
        "key": "B",
        "text": "letters.substring(2, 2) returns a single- character String."
      },
      {
        "key": "C",
        "text": "letters.substring(6, 5) returns a single- character String."
      },
      {
        "key": "D",
        "text": "letters.substring(6, 6) returns a single- character String."
      },
      {
        "key": "E",
        "text": "letters.substring(1, 2) throws an exception."
      },
      {
        "key": "F",
        "text": "letters.substring(2, 2) throws an exception."
      },
      {
        "key": "G",
        "text": "letters.substring(6, 5) throws an exception."
      },
      {
        "key": "H",
        "text": "letters.substring(6, 6) throws an exception.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "What is the result of the following code? (Choose all that apply.)\n13: String s1 = \"\"\"\n14:    purr\"\"\";\n15: String s2 = \"\";\n16:\n17: s1.toUpperCase();\n18: s1.trim();\n19: s1.substring(1, 3);\n20: s1 += \"two\";\n21:\n22: s2 += 2;\n23: s2 += 'c';\n24: s2 += false;\n25:\n26: if ( s2 == \"2cfalse\") System.out.println(\"==\");\n27: if ( s2.equals(\"2cfalse\")) System.out.println(\"equals\");\n28: System.out.println(s1.length());",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "10"
      },
      {
        "key": "E",
        "text": "=="
      },
      {
        "key": "F",
        "text": "equals"
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      },
      {
        "key": "H",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which of the following fill in the blank to print a positive integer? (Choose all that apply.)\nString[] s1 = { \"Camel\", \"Peacock\", \"Llama\"};\nString[] s2 = { \"Camel\", \"Llama\", \"Peacock\"};\nString[] s3 = { \"Camel\"};\nString[] s4 = { \"Camel\", null};\nSystem.out.println(Arrays.                      );",
    "choices": [
      {
        "key": "A",
        "text": "compare(s1, s2)"
      },
      {
        "key": "B",
        "text": "mismatch(s1, s2)"
      },
      {
        "key": "C",
        "text": "compare(s3, s4)"
      },
      {
        "key": "D",
        "text": "mismatch (s3, s4)"
      },
      {
        "key": "E",
        "text": "compare(s4, s4)"
      },
      {
        "key": "F",
        "text": "mismatch (s4, s4)\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Note that March 13, 2022 is the weekend that clocks spring ahead for daylight saving time. \nWhat is the output of the following? (Choose all that apply.)\nvar date = LocalDate.of(2022, Month.MARCH, 13);\nvar time = LocalTime.of(1, 30);\nvar zone = ZoneId.of(\"US/Eastern\");\nvar dateTime1 = ZonedDateTime.of(date, time, zone);\nvar dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);\n \nlong diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);\nint hour = dateTime2.getHour();\nboolean offset = dateTime1.getOffset() \n   == dateTime2.getOffset();\nSystem.out.println(\"diff = \" + diff);\nSystem.out.println(\"hour = \" + hour);\nSystem.out.println(\"offset = \" + offset);",
    "choices": [
      {
        "key": "A",
        "text": "diff = 1"
      },
      {
        "key": "B",
        "text": "diff = 2"
      },
      {
        "key": "C",
        "text": "hour = 2"
      },
      {
        "key": "D",
        "text": "hour = 3"
      },
      {
        "key": "E",
        "text": "offset = true"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Which of the following can fill in the blank to print avaJ? (Choose all that apply.)\n3: var puzzle = new StringBuilder(\"Java\");\n4: puzzle.                        ;\n5: System.out.println(puzzle);",
    "choices": [
      {
        "key": "A",
        "text": "reverse()"
      },
      {
        "key": "B",
        "text": "append(\"vaJ$\").substring(0, 4)"
      },
      {
        "key": "C",
        "text": "append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() -  1)"
      },
      {
        "key": "D",
        "text": "append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length())"
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "What is the output of the following code?\nvar date = LocalDate.of(2022, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() \n   + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 APRIL 30"
      },
      {
        "key": "B",
        "text": "2022 MAY 2"
      },
      {
        "key": "C",
        "text": "2025 APRIL 2"
      },
      {
        "key": "D",
        "text": "2025 APRIL 30"
      },
      {
        "key": "E",
        "text": "2025 MAY 2"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown.\n\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "Which statements about the final modifier are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Instance and static variables can be marked final."
      },
      {
        "key": "B",
        "text": "A variable is effectively final only if it is marked final."
      },
      {
        "key": "C",
        "text": "An object that is marked final cannot be modified."
      },
      {
        "key": "D",
        "text": "Local variables cannot be declared with type var and the final modifier."
      },
      {
        "key": "E",
        "text": "A primitive that is marked final cannot be modified.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which of the following can fill in the blank in this code to make it compile? (Choose all \nthat apply.)\npublic class Ant {\n         void method() {}\n}",
    "choices": [
      {
        "key": "A",
        "text": "default"
      },
      {
        "key": "B",
        "text": "final"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "Public"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "zzz:\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "final static void rain() {}"
      },
      {
        "key": "B",
        "text": "public final int void snow() {}"
      },
      {
        "key": "C",
        "text": "private void int hail() {}"
      },
      {
        "key": "D",
        "text": "static final void sleet() {}"
      },
      {
        "key": "E",
        "text": "void final ice() {}"
      },
      {
        "key": "F",
        "text": "void public slush() {}\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which of the following can fill in the blank and allow the code to compile? (Choose all that apply.)\nfinal          song = 6;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "Integer"
      },
      {
        "key": "C",
        "text": "long"
      },
      {
        "key": "D",
        "text": "Long"
      },
      {
        "key": "E",
        "text": "double"
      },
      {
        "key": "F",
        "text": "Double\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void january() { return; }"
      },
      {
        "key": "B",
        "text": "public int february() { return null;}"
      },
      {
        "key": "C",
        "text": "public void march() {}"
      },
      {
        "key": "D",
        "text": "public int april() { return 9;}"
      },
      {
        "key": "E",
        "text": "public int may() { return 9.0;}"
      },
      {
        "key": "F",
        "text": "public int june() { return;}\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void violin(int... nums) {}"
      },
      {
        "key": "B",
        "text": "public void viola(String values, int... nums) {}"
      },
      {
        "key": "C",
        "text": "public void cello(int... nums, String values) {}"
      },
      {
        "key": "D",
        "text": "public void bass(String... values, int... nums) {}"
      },
      {
        "key": "E",
        "text": "public void flute(String[] values, ...int nums) {}"
      },
      {
        "key": "F",
        "text": "public void oboe(String[] values, int[] nums) {}\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Given the following method, which of the method calls return 2? (Choose all that apply.)\npublic int juggle(boolean b, boolean... b2) {\n   return b2.length;\n}",
    "choices": [
      {
        "key": "A",
        "text": "juggle();"
      },
      {
        "key": "B",
        "text": "juggle(true);"
      },
      {
        "key": "C",
        "text": "juggle(true, true);"
      },
      {
        "key": "D",
        "text": "juggle(true, true, true);"
      },
      {
        "key": "E",
        "text": "juggle(true, {true, true});"
      },
      {
        "key": "F",
        "text": "juggle(true, new boolean[2]);\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following statements is correct?",
    "choices": [
      {
        "key": "A",
        "text": "Package access is more lenient than protected access."
      },
      {
        "key": "B",
        "text": "A public class that has private fields and package methods is not visible to classes \noutside the package."
      },
      {
        "key": "C",
        "text": "You can use access modifiers so only some of the classes in a package see a particular \npackage class."
      },
      {
        "key": "D",
        "text": "You can use access modifiers to allow access to all methods and not any instance vari-\nables."
      },
      {
        "key": "E",
        "text": "You can use access modifiers to restrict access to all classes that begin with the word \nTest.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Given the following class definitions, which lines in the main() method generate a compiler \nerror? (Choose all that apply.)\n// Classroom.java\npackage my.school;\npublic class Classroom {\n   private int roomNumber;\n   protected static String teacherName;\n   static int globalKey = 54321;\n   public static int floor = 3;\n   Classroom(int r, String t) {\n      roomNumber = r;\n      teacherName = t; } }\n \n// School.java\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4:    public static void main(String[] args) {\n5:       System.out.println(Classroom.globalKey);\n6:       Classroom room = new Classroom(101, \"Mrs. Anderson\");\n7:       System.out.println(room.roomNumber);\n8:       System.out.println(Classroom.floor);\n9:       System.out.println(Classroom.teacherName); } }",
    "choices": [
      {
        "key": "A",
        "text": "None: the code compiles fine."
      },
      {
        "key": "B",
        "text": "Line 5"
      },
      {
        "key": "C",
        "text": "Line 6"
      },
      {
        "key": "D",
        "text": "Line 7"
      },
      {
        "key": "E",
        "text": "Line 8"
      },
      {
        "key": "F",
        "text": "Line 9\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "What is the output of executing the Chimp program?\n// Rope.java\n1: package rope;\n2: public class Rope {\n3:    public static int LENGTH = 5;\n4:    static { \n5:       LENGTH = 10;\n6:    }\n7:    public static void swing() {\n8:       System.out.print(\"swing \");\n9:    } }\n \n// Chimp.java\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4:    public static void main(String[] args) {\n5:       Rope.swing();\n6:       new Rope().swing();\n7:       System.out.println(LENGTH);\n8:    } }",
    "choices": [
      {
        "key": "A",
        "text": "swing swing 5"
      },
      {
        "key": "B",
        "text": "swing swing 10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 2 of Chimp"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5 of Chimp"
      },
      {
        "key": "E",
        "text": "Compiler error on line 6 of Chimp"
      },
      {
        "key": "F",
        "text": "Compiler error on line 7 of Chimp\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Which statements are true of the following code? (Choose all that apply.)\n1:  public class Rope {\n2:     public static void swing() {\n3:        System.out.print(\"swing\");\n4:     }\n5:     public void climb() {\n6:        System.out.println(\"climb\");\n7:     }\n8:     public static void play() {\n9:        swing();\n10:       climb();\n11:    }\n12:    public static void main(String[] args) {\n13:       Rope rope = new Rope();\n14:       rope.play();\n15:       Rope rope2 = null;\n16:       System.out.print(\"- \");\n17:       rope2.play();\n18:    } }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles as is."
      },
      {
        "key": "B",
        "text": "There is exactly one compiler error in the code."
      },
      {
        "key": "C",
        "text": "There are exactly two compiler errors in the code."
      },
      {
        "key": "D",
        "text": "If the line(s) with compiler errors are removed, the output is swing- climb."
      },
      {
        "key": "E",
        "text": "If the line(s) with compiler errors are removed, the output is swing- swing."
      },
      {
        "key": "F",
        "text": "If the line(s) with compile errors are removed, the code throws a NullPointerException.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "How many variables in the following method are effectively final?\n10: public void feed() {\n11:    int monkey = 0;\n12:    if(monkey > 0) {\n13:       var giraffe = monkey++;\n14:       String name;\n15:       name = \"geoffrey\";\n16:    }\n17:    String name = \"milly\";\n18:    var food = 10;\n19:    while(monkey <= 10) {\n20:       food = 0;\n21:    }\n22:    name = null;\n23: }",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "None of the above. The code does not compile.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the output of the following code?\n// RopeSwing.java\nimport rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n   private static Rope rope1 = new Rope();\n   private static Rope rope2 = new Rope();\n   {\n      System.out.println(rope1.length);\n   }\n   public static void main(String[] args) {\n      rope1.length = 2;\n      rope2.length = 8;\n      System.out.println(rope1.length);\n   }\n}\n \n// Rope.java\npackage rope;\npublic class Rope {\n   public static int length = 0;\n}",
    "choices": [
      {
        "key": "A",
        "text": "02"
      },
      {
        "key": "B",
        "text": "08"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "How many lines in the following code have compiler errors?\n1:  public class RopeSwing {\n2:     private static final String leftRope;\n3:     private static final String rightRope;\n4:     private static final String bench;\n5:     private static final String name = \"name\";\n6:     static {\n7:        leftRope = \"left\";\n8:        rightRope = \"right\";\n9:     }\n10:    static {\n11:       name = \"name\";\n12:       rightRope = \"right\";\n13:    }\n14:    public static void main(String[] args) {\n15:       bench = \"bench\";\n16:    }\n17: }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which of the following can replace line 2 to make this code compile? (Choose all that apply.)\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4:    public void method(ArrayList<String> list) {\n5:       sort(list);\n6:    }\n7: }",
    "choices": [
      {
        "key": "A",
        "text": "import static java.util.Collections;"
      },
      {
        "key": "B",
        "text": "import static java.util.Collections.*;"
      },
      {
        "key": "C",
        "text": "import static java.util.Collections.sort(ArrayList<String>);"
      },
      {
        "key": "D",
        "text": "static import java.util.Collections;"
      },
      {
        "key": "E",
        "text": "static import java.util.Collections.*;"
      },
      {
        "key": "F",
        "text": "static import java.util.Collections.sort(ArrayList<String>);\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "What is the result of the following statements?\n1:  public class Test {\n2:     public void print(byte x) {\n3:        System.out.print(\"byte- \");\n4:     }\n5:     public void print(int x) {\n6:        System.out.print(\"int- \");\n7:     }\n8:     public void print(float x) {\n9:        System.out.print(\"float- \");\n10:    }\n11:    public void print(Object x) {\n12:       System.out.print(\"Object- \");\n13:    }\n14:    public static void main(String[] args) {\n15:       Test t = new Test();\n16:       short s = 123;\n17:       t.print(s);\n18:       t.print(true);\n19:       t.print(6.789);\n20:    }\n21: }",
    "choices": [
      {
        "key": "A",
        "text": "byte- float- Object- "
      },
      {
        "key": "B",
        "text": "int- float- Object- "
      },
      {
        "key": "C",
        "text": "byte- Object- float- "
      },
      {
        "key": "D",
        "text": "int- Object- float- "
      },
      {
        "key": "E",
        "text": "int- Object- Object- "
      },
      {
        "key": "F",
        "text": "byte- Object- Object- \n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What is the result of the following program?\n1:  public class Squares {\n2:     public static long square(int x) {\n3:        var y = x * (long) x;\n4:        x = - 1;\n5:        return y;\n6:     }\n7:     public static void main(String[] args) {\n8:        var value = 9;\n9:        var result = square(value);\n10:       System.out.println(value);\n11:    } }",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "81"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9"
      },
      {
        "key": "E",
        "text": "Compiler error on a different line\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which of the following are output by the following code? (Choose all that apply.)\npublic class StringBuilders {\n   public static StringBuilder work(StringBuilder a, \n      StringBuilder b) {\n      a = new StringBuilder(\"a\");\n      b.append(\"b\");\n      return a;\n   }\n   public static void main(String[] args) {\n      var s1 = new StringBuilder(\"s1\");\n      var s2 = new StringBuilder(\"s2\");\n      var s3 = work(s1, s2);\n      System.out.println(\"s1 = \" + s1);\n      System.out.println(\"s2 = \" + s2);\n      System.out.println(\"s3 = \" + s3);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "s1 = a"
      },
      {
        "key": "B",
        "text": "s1 = s1"
      },
      {
        "key": "C",
        "text": "s2 = s2"
      },
      {
        "key": "D",
        "text": "s2 = s2b"
      },
      {
        "key": "E",
        "text": "s3 = a"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which of the following will compile when independently inserted in the following code? \n(Choose all that apply.)\n1:  public class Order3 {\n2:     final String value1 = \"red\";\n3:     static String value2 = \"blue\";\n4:     String value3 = \"yellow\";\n5:     {\n6:        // CODE SNIPPET 1\n7:     }\n8:     static {\n9:        // CODE SNIPPET 2\n10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Insert at line 6: value1 = \"green\";"
      },
      {
        "key": "B",
        "text": "Insert at line 6: value2 = \"purple\";"
      },
      {
        "key": "C",
        "text": "Insert at line 6: value3 = \"orange\";"
      },
      {
        "key": "D",
        "text": "Insert at line 9: value1 = \"magenta\";"
      },
      {
        "key": "E",
        "text": "Insert at line 9: value2 = \"cyan\";"
      },
      {
        "key": "F",
        "text": "Insert at line 9: value3 = \"turquoise\";\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which of the following are true about the following code? (Choose all that apply.)\npublic class Run {\n   static void execute() {\n      System.out.print(\"1- \");\n   }\n   static void execute(int num) {\n      System.out.print(\"2- \");\n   }\n   static void execute(Integer num) {\n      System.out.print(\"3- \");\n   }\n   static void execute(Object num) {\n      System.out.print(\"4- \");\n   }\n   static void execute(int... nums) {\n      System.out.print(\"5- \");\n   }\n   public static void main(String[] args) {\n      Run.execute(100);\n      Run.execute(100L);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code prints out 2- 4- ."
      },
      {
        "key": "B",
        "text": "The code prints out 3- 4- ."
      },
      {
        "key": "C",
        "text": "The code prints out 4- 2- ."
      },
      {
        "key": "D",
        "text": "The code prints out 4- 4- ."
      },
      {
        "key": "E",
        "text": "The code prints 3- 4-  if you remove the method static void execute(int num)."
      },
      {
        "key": "F",
        "text": "The code prints 4- 4-  if you remove the method static void execute(int num).\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Which method signatures are valid overloads of the following method signature? (Choose all \nthat apply.)\npublic void moo(int m, int... n)",
    "choices": [
      {
        "key": "A",
        "text": "public void moo(int a, int... b)"
      },
      {
        "key": "B",
        "text": "public int moo(char ch)"
      },
      {
        "key": "C",
        "text": "public void moooo(int... z)"
      },
      {
        "key": "D",
        "text": "private void moo(int... x)"
      },
      {
        "key": "E",
        "text": "public void moooo(int y)"
      },
      {
        "key": "F",
        "text": "public void moo(int... c, int d)"
      },
      {
        "key": "G",
        "text": "public void moo(int... i, int j...)\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which code can be inserted to have the code print 2?\npublic class BirdSeed {\n   private int numberBags;\n   boolean call;\n \n   public BirdSeed() {\n      // LINE 1\n      call = false;\n      // LINE 2\n   }\n \n   public BirdSeed(int numberBags) {\n      this.numberBags = numberBags;\n   }\n \n   public static void main(String[] args) {\n      var seed = new BirdSeed();\n      System.out.print(seed.numberBags);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Replace line 1 with BirdSeed(2);."
      },
      {
        "key": "B",
        "text": "Replace line 2 with BirdSeed(2);."
      },
      {
        "key": "C",
        "text": "Replace line 1 with new BirdSeed(2);."
      },
      {
        "key": "D",
        "text": "Replace line 2 with new BirdSeed(2);."
      },
      {
        "key": "E",
        "text": "Replace line 1 with this(2);."
      },
      {
        "key": "F",
        "text": "Replace line 2 with this(2);."
      },
      {
        "key": "G",
        "text": "The code prints 2 without any changes.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which modifier pairs can be used together in a method declaration? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "static and final"
      },
      {
        "key": "B",
        "text": "private and static"
      },
      {
        "key": "C",
        "text": "static and abstract"
      },
      {
        "key": "D",
        "text": "private and abstract"
      },
      {
        "key": "E",
        "text": "abstract and final"
      },
      {
        "key": "F",
        "text": "private and final\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following statements about methods are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Overloaded methods must have the same signature."
      },
      {
        "key": "B",
        "text": "Overridden methods must have the same signature."
      },
      {
        "key": "C",
        "text": "Hidden methods must have the same signature."
      },
      {
        "key": "D",
        "text": "Overloaded methods must have the same return type."
      },
      {
        "key": "E",
        "text": "Overridden methods must have the same return type."
      },
      {
        "key": "F",
        "text": "Hidden methods must have the same return type.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "What is the output of the following program?\n1:  class Mammal {\n2:     private void sneeze() {}\n3:     public Mammal(int age) {\n4:        System.out.print(\"Mammal\");\n5:     } }\n6:  public class Platypus extends Mammal {\n7:     int sneeze() { return 1; }\n8:     public Platypus() {\n9:        System.out.print(\"Platypus\");\n10:    }\n11:    public static void main(String[] args) {\n12:       new Mammal(5);\n13:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Platypus"
      },
      {
        "key": "B",
        "text": "Mammal"
      },
      {
        "key": "C",
        "text": "PlatypusMammal"
      },
      {
        "key": "D",
        "text": "MammalPlatypus"
      },
      {
        "key": "E",
        "text": "The code will compile if line 7 is changed."
      },
      {
        "key": "F",
        "text": "The code will compile if line 9 is changed.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which of the following complete the constructor so that this code prints out 50? (Choose all \nthat apply.)\nclass Speedster {\n   int numSpots;\n}\npublic class Cheetah extends Speedster {\n   int numSpots;\n \n   public Cheetah(int numSpots) {\n      // INSERT CODE HERE\n   }\n \n   public static void main(String[] args) {\n      Speedster s = new Cheetah(50);\n      System.out.print(s.numSpots);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "numSpots = numSpots;"
      },
      {
        "key": "B",
        "text": "numSpots = this.numSpots;"
      },
      {
        "key": "C",
        "text": "this.numSpots = numSpots;"
      },
      {
        "key": "D",
        "text": "numSpots = super.numSpots;"
      },
      {
        "key": "E",
        "text": "super.numSpots = numSpots;"
      },
      {
        "key": "F",
        "text": "The code does not compile regardless of the code inserted into the constructor."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following declare immutable classes? (Choose all that apply.)\npublic final class Moose {\n   private final int antlers; \n}\n \npublic class Caribou {\n   private int antlers = 10; \n}\n \npublic class Reindeer {\n   private final int antlers = 5; \n}\n \npublic final class Elk {}\n \npublic final class Deer {\n   private final Object o = new Object();\n}",
    "choices": [
      {
        "key": "A",
        "text": "Moose"
      },
      {
        "key": "B",
        "text": "Caribou"
      },
      {
        "key": "C",
        "text": "Reindeer"
      },
      {
        "key": "D",
        "text": "Elk"
      },
      {
        "key": "E",
        "text": "Deer"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "What is the output of the following code?\n1:  class Arthropod {\n2:     protected void printName(long input) {\n3:        System.out.print(\"Arthropod\");\n4:     }\n5:     void printName(int input) {\n6:        System.out.print(\"Spooky\");\n7:     } }\n8:  public class Spider extends Arthropod {\n9:     protected void printName(int input) {\n10:       System.out.print(\"Spider\");\n11:    }\n12:    public static void main(String[] args) {\n13:       Arthropod a = new Spider();\n14:       a.printName((short)4);\n15:       a.printName(4);\n16:       a.printName(5L);\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "SpiderSpiderArthropod"
      },
      {
        "key": "B",
        "text": "SpiderSpiderSpider"
      },
      {
        "key": "C",
        "text": "SpiderSpookyArthropod"
      },
      {
        "key": "D",
        "text": "SpookySpiderArthropod"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 9."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "What is the result of the following code?\n1:  abstract class Bird {\n2:     private final void fly() { System.out.println(\"Bird\"); }\n3:     protected Bird() { System.out.print(\"Wow- \"); }\n4:  }\n5:  public class Pelican extends Bird {\n6:     public Pelican() { System.out.print(\"Oh- \"); }\n7:     protected void fly() { System.out.println(\"Pelican\"); }\n8:     public static void main(String[] args) {\n9:        var chirp = new Pelican();\n10:       chirp.fly();\n11: } }",
    "choices": [
      {
        "key": "A",
        "text": "Oh- Bird"
      },
      {
        "key": "B",
        "text": "Oh- Pelican"
      },
      {
        "key": "C",
        "text": "Wow- Oh- Bird"
      },
      {
        "key": "D",
        "text": "Wow- Oh- Pelican"
      },
      {
        "key": "E",
        "text": "The code contains a compilation error."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of the following statements about overridden methods are true? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An overridden method must contain method parameters that are the same or covariant \nwith the method parameters in the inherited method."
      },
      {
        "key": "B",
        "text": "An overridden method may declare a new exception, provided it is not checked."
      },
      {
        "key": "C",
        "text": "An overridden method must be more accessible than the method in the parent class."
      },
      {
        "key": "D",
        "text": "An overridden method may declare a broader checked exception than the method in the \nparent class."
      },
      {
        "key": "E",
        "text": "If an inherited method returns void, then the overridden version of the method must \nreturn void."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which of the following pairs, when inserted into the blanks, allow the code to compile? \n(Choose all that apply.)\n1:  public class Howler {\n2:     public Howler(long shadow) {\n3:        ;\n4:     }\n5:     private Howler(int moon) {\n6:        super();\n7:     }\n8:  }\n9:  class Wolf extends Howler {\n10:    protected Wolf(String stars) {\n11:       super(2L);\n12:    }\n13:    public Wolf() {\n14:       ;\n15:    }\n16: }",
    "choices": [
      {
        "key": "A",
        "text": "this(3) at line 3, this(\"\") at line 14"
      },
      {
        "key": "B",
        "text": "this() at line 3, super(1) at line 14"
      },
      {
        "key": "C",
        "text": "this((short)1) at line 3, this(null) at line 14"
      },
      {
        "key": "D",
        "text": "super() at line 3, super() at line 14"
      },
      {
        "key": "E",
        "text": "this(2L) at line 3, super((short)2) at line 14"
      },
      {
        "key": "F",
        "text": "this(5) at line 3, super(null) at line 14"
      },
      {
        "key": "G",
        "text": "Remove lines 3 and 14.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What is the result of the following?\n1:  public class PolarBear {\n2:     StringBuilder value = new StringBuilder(\"t\");\n3:     { value.append(\"a\"); }\n4:     { value.append(\"c\"); }\n5:     private PolarBear() {\n6:        value.append(\"b\");\n7:     }\n8:     public PolarBear(String s) {\n9:        this();\n10:       value.append(s);\n11:    }\n12:    public PolarBear(CharSequence p) {\n13:       value.append(p);\n14:    }\n15:    public static void main(String[] args) {\n16:       Object bear = new PolarBear();\n17:       bear = new PolarBear(\"f\");\n18:       System.out.println(((PolarBear)bear).value);\n19:    } }",
    "choices": [
      {
        "key": "A",
        "text": "tacb"
      },
      {
        "key": "B",
        "text": "tacf"
      },
      {
        "key": "C",
        "text": "tacbf"
      },
      {
        "key": "D",
        "text": "tcafb"
      },
      {
        "key": "E",
        "text": "taftacb"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "How many lines of the following program contain a compilation error?\n1:  public class Rodent {\n2:     public Rodent(Integer x) {}\n3:     protected static Integer chew() throws Exception {\n4:        System.out.println(\"Rodent is chewing\");\n5:        return 1;\n6:     }\n7:  }\n8:  class Beaver extends Rodent {\n9:     public Number chew() throws RuntimeException {\n10:       System.out.println(\"Beaver is chewing on wood\");\n11:       return 2;\n12:    } }",
    "choices": [
      {
        "key": "A",
        "text": "None"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of these classes compile and will include a default constructor created by the  \ncompiler? (Choose all that apply.)\nA. \npublic class Bird {}\nB. \npublic class Bird {\n   public bird() {}\n}\nC. \npublic class Bird {\n   public bird(String name) {}\n}\nD. \npublic class Bird {\n   public Bird() {}\n}\nE. \npublic class Bird {\n   Bird(String name) {}\n}\nF. \npublic class Bird {\n   private Bird(int age) {}\n}\nG. \npublic class Bird {\n   public Bird bird() { return null; }\n}",
    "choices": [],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following statements about inheritance are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A class can directly extend any number of classes."
      },
      {
        "key": "B",
        "text": "A class can implement any number of interfaces."
      },
      {
        "key": "C",
        "text": "All variables inherit java.lang.Object."
      },
      {
        "key": "D",
        "text": "If class A is extended by B, then B is a superclass of A."
      },
      {
        "key": "E",
        "text": "If class C implements interface D, then C is a subtype of D."
      },
      {
        "key": "F",
        "text": "Multiple inheritance is the property of a class to have multiple direct superclasses.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1: abstract class Nocturnal {\n2:    boolean isBlind();\n3: }\n4: public class Owl extends Nocturnal {\n5:    public boolean isBlind() { return false; }\n6:    public static void main(String[] args) {\n7:       var nocturnal = (Nocturnal)new Owl();\n8:       System.out.println(nocturnal.isBlind());\n9: } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and prints true."
      },
      {
        "key": "B",
        "text": "It compiles and prints false."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "What is the result of the following?\n1:  class Arachnid {\n2:     static StringBuilder sb = new StringBuilder();\n3:     { sb.append(\"c\"); }\n4:     static\n5:     { sb.append(\"u\"); }\n6:     { sb.append(\"r\"); }\n7:  }\n8:  public class Scorpion extends Arachnid {\n9:     static\n10:    { sb.append(\"q\"); }\n11:    { sb.append(\"m\"); }\n12:    public static void main(String[] args) {\n13:       System.out.print(Scorpion.sb + \" \");\n14:       System.out.print(Scorpion.sb + \" \");\n15:       new Arachnid();\n16:       new Scorpion();\n17:       System.out.print(Scorpion.sb);\n18:    } }",
    "choices": [
      {
        "key": "A",
        "text": "qu qu qumrcrc"
      },
      {
        "key": "B",
        "text": "u u ucrcrm"
      },
      {
        "key": "C",
        "text": "uq uq uqmcrcr"
      },
      {
        "key": "D",
        "text": "uq uq uqcrcrm"
      },
      {
        "key": "E",
        "text": "qu qu qumcrcr"
      },
      {
        "key": "F",
        "text": "qu qu qucrcrm"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which of the following are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "this() can be called from anywhere in a constructor."
      },
      {
        "key": "B",
        "text": "this() can be called from anywhere in an instance method."
      },
      {
        "key": "C",
        "text": "this.variableName can be called from any instance method in the class."
      },
      {
        "key": "D",
        "text": "this.variableName can be called from any static method in the class."
      },
      {
        "key": "E",
        "text": "You can call the default constructor written by the compiler using this()."
      },
      {
        "key": "F",
        "text": "You can access a private constructor with the main() method in the same class.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which statements about the following classes are correct? (Choose all that apply.)\n1:  public class Mammal {\n2:     private void eat() {}\n3:     protected static void drink() {}\n4:     public Integer dance(String p) { return null; }\n5:  }\n6:  class Primate extends Mammal {\n7:     public void eat(String p) {}\n8:  }\n9:  class Monkey extends Primate {\n10:    public static void drink() throws RuntimeException {}\n11:    public Number dance(CharSequence p) { return null; }\n12:    public int eat(String p) {}\n13: }",
    "choices": [
      {
        "key": "A",
        "text": "The eat() method in Mammal is correctly overridden on line 7."
      },
      {
        "key": "B",
        "text": "The eat() method in Mammal is correctly overloaded on line 7."
      },
      {
        "key": "C",
        "text": "The drink() method in Mammal is correctly overridden on line 10."
      },
      {
        "key": "D",
        "text": "The drink() method in Mammal is correctly hidden on line 10."
      },
      {
        "key": "E",
        "text": "The dance() method in Mammal is correctly overridden on line 11."
      },
      {
        "key": "F",
        "text": "The dance() method in Mammal is correctly overloaded on line 11."
      },
      {
        "key": "G",
        "text": "The eat() method in Primate is correctly hidden on line 12."
      },
      {
        "key": "H",
        "text": "The eat() method in Primate is correctly overloaded on line 12.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the output of the following code?\n1:  class Reptile {\n2:     {System.out.print(\"A\");}\n3:     public Reptile(int hatch) {}\n4:     void layEggs() {\n5:        System.out.print(\"Reptile\");\n6:     } }\n7:  public class Lizard extends Reptile {\n8:     static {System.out.print(\"B\");}\n9:     public Lizard(int hatch) {}\n10:    public final void layEggs() {\n11:       System.out.print(\"Lizard\");\n12:    }\n13:    public static void main(String[] args) {\n14:       var reptile = new Lizard(1);\n15:       reptile.layEggs();\n16:    } }",
    "choices": [
      {
        "key": "A",
        "text": "AALizard"
      },
      {
        "key": "B",
        "text": "BALizard"
      },
      {
        "key": "C",
        "text": "BLizardA"
      },
      {
        "key": "D",
        "text": "ALizard"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which statement about the following program is correct?\n1:  class Bird {\n2:     int feathers = 0;\n3:     Bird(int x) { this.feathers = x; }\n4:     Bird fly() {\n5:        return new Bird(1);\n6:     } }\n7:  class Parrot extends Bird {\n8:     protected Parrot(int y) { super(y); }\n9:     protected Parrot fly() {\n10:       return new Parrot(2);\n11:    } }\n12: public class Macaw extends Parrot {\n13:    public Macaw(int z) { super(z); }\n14:    public Macaw fly() {\n15:       return new Macaw(3);\n16:    }\n17:    public static void main(String... sing) {\n18:       Bird p = new Macaw(4);\n19:       System.out.print(((Parrot)p.fly()).feathers);\n20:    } }",
    "choices": [
      {
        "key": "A",
        "text": "One line contains a compiler error."
      },
      {
        "key": "B",
        "text": "Two lines contain compiler errors."
      },
      {
        "key": "C",
        "text": "Three lines contain compiler errors."
      },
      {
        "key": "D",
        "text": "The code compiles but throws a ClassCastException at runtime."
      },
      {
        "key": "E",
        "text": "The program compiles and prints 3."
      },
      {
        "key": "F",
        "text": "The program compiles and prints 0.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Which of the following are properties of immutable classes? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The class can contain setter methods, provided they are marked final."
      },
      {
        "key": "B",
        "text": "The class must not be able to be extended outside the class declaration."
      },
      {
        "key": "C",
        "text": "The class may not contain any instance variables."
      },
      {
        "key": "D",
        "text": "The class must be marked static."
      },
      {
        "key": "E",
        "text": "The class may not contain any static variables."
      },
      {
        "key": "F",
        "text": "The class may only contain private constructors."
      },
      {
        "key": "G",
        "text": "The data for mutable instance variables may be read, provided they cannot be modified \nby the caller.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "What does the following program print?\n1:  class Person {\n2:     static String name;\n3:     void setName(String q) { name = q; } }\n4:  public class Child extends Person {\n5:     static String name;\n6:     void setName(String w) { name = w; }\n7:     public static void main(String[] p) {\n8:        final Child m = new Child();\n9:        final Person t = m;\n10:       m.name = \"Elysia\";\n11:       t.name = \"Sophia\";\n12:       m.setName(\"Webby\");\n13:       t.setName(\"Olivia\");\n14:       System.out.println(m.name + \" \" + t.name);\n15:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Elysia Sophia"
      },
      {
        "key": "B",
        "text": "Webby Olivia"
      },
      {
        "key": "C",
        "text": "Olivia Olivia"
      },
      {
        "key": "D",
        "text": "Olivia Sophia"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "What is the output of the following program?\n1:  class Canine {\n2:     public Canine(boolean t) { logger.append(\"a\"); }\n3:     public Canine() { logger.append(\"q\"); }\n4:     \n5:     private StringBuilder logger = new StringBuilder();\n6:     protected void print(String v) { logger.append(v); }\n7:     protected String view() { return logger.toString(); }\n8:  }\n9:  \n10: class Fox extends Canine {\n11:    public Fox(long x) { print(\"p\"); }\n12:    public Fox(String name) {\n13:       this(2);\n14:       print(\"z\");\n15:    }\n16: }\n17:\n18: public class Fennec extends Fox {\n19:    public Fennec(int e) {\n20:       super(\"tails\");\n21:       print(\"j\");\n22:    }\n23:    public Fennec(short f) {\n24:       super(\"eevee\");\n25:       print(\"m\");\n26:    }\n27: \n28:    public static void main(String... unused) {\n29:       System.out.println(new Fennec(1).view());\n30:    } }",
    "choices": [
      {
        "key": "A",
        "text": "qpz"
      },
      {
        "key": "B",
        "text": "qpzj"
      },
      {
        "key": "C",
        "text": "jzpa"
      },
      {
        "key": "D",
        "text": "apj"
      },
      {
        "key": "E",
        "text": "apjm"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "What is printed by the following program?\n1:  class Antelope {\n2:     public Antelope(int p) {\n3:        System.out.print(\"4\");\n4:     }\n5:     { System.out.print(\"2\"); }\n6:     static { System.out.print(\"1\"); }\n7:  }\n8:  public class Gazelle extends Antelope {\n9:     public Gazelle(int p) {\n10:       super(6);\n11:       System.out.print(\"3\");\n12:    }\n13:    public static void main(String hopping[]) {\n14:       new Gazelle(0);\n15:    }\n16:    static { System.out.print(\"8\"); }\n17:    { System.out.print(\"9\"); }\n18: }",
    "choices": [
      {
        "key": "A",
        "text": "182640"
      },
      {
        "key": "B",
        "text": "182943"
      },
      {
        "key": "C",
        "text": "182493"
      },
      {
        "key": "D",
        "text": "421389"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The output cannot be determined until runtime.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "Which of the following are true about a concrete class? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A concrete class can be declared as abstract."
      },
      {
        "key": "B",
        "text": "A concrete class must implement all inherited abstract methods."
      },
      {
        "key": "C",
        "text": "A concrete class can be marked as final."
      },
      {
        "key": "D",
        "text": "A concrete class must be immutable."
      },
      {
        "key": "E",
        "text": "A concrete method that implements an abstract method must match the method declara-\ntion of the abstract method exactly.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "What is the output of the following code?\n4:  public abstract class Whale {\n5:     public abstract void dive();\n6:     public static void main(String[] args) {\n7:        Whale whale = new Orca();\n8:        whale.dive(3);\n9:     }\n10: }\n11: class Orca extends Whale {\n12:    static public int MAX = 3;\n13:    public void dive() {\n14:       System.out.println(\"Orca diving\");\n15:    }\n16:    public void dive(int... depth) {\n17:       System.out.println(\"Orca diving deeper \"+MAX);\n18: } }",
    "choices": [
      {
        "key": "A",
        "text": "Orca diving"
      },
      {
        "key": "B",
        "text": "Orca diving deeper 3"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 11."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 12."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line 17."
      },
      {
        "key": "H",
        "text": "None of the above\n\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The try block is not capable of throwing an IOException, making the catch block \nunreachable code and option A incorrect. Options B and F are correct, as both are unchecked \nexceptions that do not extend or inherit from IllegalArgumentException. Remember, \nit is not a good idea to catch Error in practice, although because it is possible, it may come \nup on the exam. Option C is incorrect because the variable c is declared already in the \nmethod declaration. Option D is incorrect because the IllegalArgumentException\ninherits from RuntimeException, making the first declaration unnecessary. \nSimilarly, option E is incorrect because NumberFormatException inherits from \nIllegalArgumentException, making the second declaration unnecessary. Since options \nB and F are correct, option G is incorrect.\nChapter 12: Modules 949\nChapter 12: Modules\n"
  },
  {
    "question": "Which of the following are valid record declarations? (Choose all that apply.)\npublic record Iguana(int age) {\n   private static final int age = 10; }\n \npublic final record Gecko() {}\n \npublic abstract record Chameleon()  {\n   private static String name; }\n \npublic record BeardedDragon(boolean fun) {\n   @Override public boolean fun() { return false; } }\n \npublic record Newt(long size) {\n   @Override public boolean equals(Object obj) { return false; }\n   public void setSize(long size) {\n      this.size = size;\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Iguana"
      },
      {
        "key": "B",
        "text": "Gecko"
      },
      {
        "key": "C",
        "text": "Chameleon"
      },
      {
        "key": "D",
        "text": "BeardedDragon"
      },
      {
        "key": "E",
        "text": "Newt"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which of the following statements can be inserted in the blank line so that the code will com-\npile successfully? (Choose all that apply.)\ninterface CanHop {}\npublic class Frog implements CanHop {\n   public static void main(String[] args) {\n       frog = new TurtleFrog();\n   }\n}\nclass BrazilianHornedFrog extends Frog {}\nclass TurtleFrog extends Frog {}",
    "choices": [
      {
        "key": "A",
        "text": "Frog"
      },
      {
        "key": "B",
        "text": "TurtleFrog"
      },
      {
        "key": "C",
        "text": "BrazilianHornedFrog"
      },
      {
        "key": "D",
        "text": "CanHop"
      },
      {
        "key": "E",
        "text": "var"
      },
      {
        "key": "F",
        "text": "Long"
      },
      {
        "key": "G",
        "text": "None of the above; the code contains a compilation error.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "What is the result of the following program?\npublic class Favorites {\n   enum Flavors {\n      VANILLA, CHOCOLATE, STRAWBERRY\n      static final Flavors DEFAULT = STRAWBERRY;\n  }\n   public static void main(String[] args) {\n      for(final var e : Flavors.values())\n         System.out.print(e.ordinal()+\" \");\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0 1 2"
      },
      {
        "key": "B",
        "text": "1 2 3"
      },
      {
        "key": "C",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "D",
        "text": "More than one line of code does not compile."
      },
      {
        "key": "E",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "What is the output of the following program?\npublic sealed class ArmoredAnimal permits Armadillo {\n   public ArmoredAnimal(int size) {}\n   @Override public String toString() { return \"Strong\"; }\n   public static void main(String[] a) {\n      var c = new Armadillo(10, null);\n      System.out.println(c);\n   }\n}\nclass Armadillo extends ArmoredAnimal {\n   @Override public String toString() { return \"Cute\"; }\n   public Armadillo(int size, String name) {\n      super(size);\n   }   \n}",
    "choices": [
      {
        "key": "A",
        "text": "Strong"
      },
      {
        "key": "B",
        "text": "Cute"
      },
      {
        "key": "C",
        "text": "The program does not compile."
      },
      {
        "key": "D",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1:  interface HasExoskeleton {\n2:     double size = 2.0f;\n3:     abstract int getNumberOfSections();\n4:  }\n5:  abstract class Insect implements HasExoskeleton {\n6:     abstract int getNumberOfLegs();\n7:  }\n8:  public class Beetle extends Insect {\n9:     int getNumberOfLegs() { return 6; }\n10:    int getNumberOfSections(int count) { return 1; }\n11: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "The code will produce a ClassCastException if called at runtime."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 10.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1: public abstract interface Herbivore {\n2:    int amount = 10;\n3:    public void eatGrass();\n4:    public abstract int chew() { return 13; }\n5: }\n6:\n7: abstract class IsAPlant extends Herbivore {\n8:    Object eatGrass(int season) { return null; }\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because line 8 contains an invalid method override.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "What is the output of the following program?\n1: interface Aquatic {\n2:    int getNumOfGills(int p);\n3: }\n4: public class ClownFish implements Aquatic {\n5:    String getNumOfGills() { return \"14\"; }\n6:    int getNumOfGills(int input) { return 15; }\n7:    public static void main(String[] args) {\n8:       System.out.println(new ClownFish().getNumOfGills(- 1));\n9: } }",
    "choices": [
      {
        "key": "A",
        "text": "14"
      },
      {
        "key": "B",
        "text": "15"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "When inserted in order, which modifiers can fill in the blank to create a properly encapsu-\nlated class? (Choose all that apply.)\npublic class Rabbits {\n    int numRabbits = 0;\n    void multiply() {\n      numRabbits *= 6;\n   }\n    int getNumberOfRabbits() {\n      return numRabbits;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "private, public, and public"
      },
      {
        "key": "B",
        "text": "private, protected, and private"
      },
      {
        "key": "C",
        "text": "private, private, and protected"
      },
      {
        "key": "D",
        "text": "public, public, and public"
      },
      {
        "key": "E",
        "text": "The class cannot be properly encapsulated since multiply() does not begin with set."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of the following statements can be inserted in the blank so that the code will compile \nsuccessfully? (Choose all that apply.)\nabstract class Snake {}\nclass Cobra extends Snake {}\nclass GardenSnake extends Cobra {}\npublic class SnakeHandler {\n   private Snake snakey;\n   public void setSnake(Snake mySnake) { this.snakey = mySnake; }\n   public static void main(String[] args) {\n      new SnakeHandler().setSnake( );\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "new Cobra()"
      },
      {
        "key": "B",
        "text": "new Snake()"
      },
      {
        "key": "C",
        "text": "new Object()"
      },
      {
        "key": "D",
        "text": "new String(\"Snake\")"
      },
      {
        "key": "E",
        "text": "new GardenSnake()"
      },
      {
        "key": "F",
        "text": "null"
      },
      {
        "key": "G",
        "text": "None of the above. The class does not compile, regardless of the value inserted in the \nblank.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "What types can be inserted in the blanks on the lines marked X and Z that allow the code to \ncompile? (Choose all that apply.)\ninterface Walk { private static List move() { return null; } }\ninterface Run extends Walk { public ArrayList move(); }\nclass Leopard implements Walk {\n   public  move() {  // X\n      return null;\n   }\n}\nclass Panther implements Run {\n   public  move() {  // Z\n      return null;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Integer on the line marked X"
      },
      {
        "key": "B",
        "text": "ArrayList on the line marked X"
      },
      {
        "key": "C",
        "text": "List on the line marked X"
      },
      {
        "key": "D",
        "text": "List on the line marked Z"
      },
      {
        "key": "E",
        "text": "ArrayList on the line marked Z"
      },
      {
        "key": "F",
        "text": "None of the above, since the Run interface does not compile"
      },
      {
        "key": "G",
        "text": "The code does not compile for a different reason.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What is the result of the following code? (Choose all that apply.)\n1:  public class Movie {\n2:     private int butter = 5;\n3:     private Movie() {}\n4:     protected class Popcorn {\n5:        private Popcorn() {}\n6:        public static int butter = 10;\n7:        public void startMovie() {\n8:           System.out.println(butter);\n9:        }\n10:    }\n11:    public static void main(String[] args) {\n12:       var movie = new Movie();\n13:       Movie.Popcorn in = new Movie().new Popcorn();\n14:       in.startMovie();\n15:    } }",
    "choices": [
      {
        "key": "A",
        "text": "The output is 5."
      },
      {
        "key": "B",
        "text": "The output is 10."
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 12 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 13 generates a compiler error."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an exception at runtime.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Which of the following are true about encapsulation? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "It allows getters."
      },
      {
        "key": "B",
        "text": "It allows setters."
      },
      {
        "key": "C",
        "text": "It requires specific naming conventions."
      },
      {
        "key": "D",
        "text": "It requires public instance variables."
      },
      {
        "key": "E",
        "text": "It requires private instance variables.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the result of the following program?\npublic class Weather {\n   enum Seasons {\n      WINTER, SPRING, SUMMER, FALL\n   }\n \n   public static void main(String[] args) {\n      Seasons v = null;\n      switch (v) {\n         case Seasons.SPRING - > System.out.print(\"s\");\n         case Seasons.WINTER - > System.out.print(\"w\");\n         case Seasons.SUMMER - > System.out.print(\"m\");\n         default - > System.out.println(\"missing data\"); }\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "s"
      },
      {
        "key": "B",
        "text": "w"
      },
      {
        "key": "C",
        "text": "m"
      },
      {
        "key": "D",
        "text": "missing data"
      },
      {
        "key": "E",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "F",
        "text": "More than one line of code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but produces an exception at runtime.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which statements about sealed classes are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A sealed interface restricts which subinterfaces may extend it."
      },
      {
        "key": "B",
        "text": "A sealed class cannot be indirectly extended by a class that is not listed in its permits \nclause."
      },
      {
        "key": "C",
        "text": "A sealed class can be extended by an abstract class."
      },
      {
        "key": "D",
        "text": "A sealed class can be extended by a subclass that uses the non-sealed modifier."
      },
      {
        "key": "E",
        "text": "A sealed interface restricts which subclasses may implement it."
      },
      {
        "key": "F",
        "text": "A sealed class cannot contain any nested subclasses."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which lines, when entered independently into the blank, allow the code to print  \nNot scared at runtime? (Choose all that apply.)\npublic class Ghost {\n   public static void boo() {\n      System.out.println(\"Not scared\");\n   }\n   protected final class Spirit {\n      public void boo() {\n         System.out.println(\"Booo!!!\");\n      }\n   }\n   public static void main(String... haunt) {\n      var g = new Ghost().new Spirit() {};\n      ;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "g.boo()"
      },
      {
        "key": "B",
        "text": "g.super.boo()"
      },
      {
        "key": "C",
        "text": "new Ghost().boo()"
      },
      {
        "key": "D",
        "text": "g.Ghost.boo()"
      },
      {
        "key": "E",
        "text": "new Spirit().boo()"
      },
      {
        "key": "F",
        "text": "Ghost.boo()"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "The following code appears in a file named Ostrich.java. What is the result of compiling \nthe source file?\n1: public class Ostrich {\n2:    private int count;\n3:    static class OstrichWrangler {\n4:       public int stampede() {\n5:          return count;\n6:       } } }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles successfully, and one bytecode file is generated: Ostrich.class."
      },
      {
        "key": "B",
        "text": "The code compiles successfully, and two bytecode files are generated: Ostrich.class \nand OstrichWrangler.class."
      },
      {
        "key": "C",
        "text": "The code compiles successfully, and two bytecode files are generated: Ostrich.class \nand Ostrich$OstrichWrangler.class."
      },
      {
        "key": "D",
        "text": "A compiler error occurs on line 3."
      },
      {
        "key": "E",
        "text": "A compiler error occurs on line 5.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which lines of the following interface declarations do not compile? (Choose all that apply.)\n1: public interface Omnivore {\n2:    int amount = 10;\n3:    static boolean gather = true;\n4:    static void eatGrass() {}\n5:    int findMore() { return 2; }\n6:    default float rest() { return 2; }\n7:    protected int chew() { return 13; }\n8:    private static void eatLeaves() {}\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "All of the lines compile without issue."
      },
      {
        "key": "B",
        "text": "Line 2"
      },
      {
        "key": "C",
        "text": "Line 3"
      },
      {
        "key": "D",
        "text": "Line 4"
      },
      {
        "key": "E",
        "text": "Line 5"
      },
      {
        "key": "F",
        "text": "Line 6"
      },
      {
        "key": "G",
        "text": "Line 7"
      },
      {
        "key": "H",
        "text": "Line 8\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "What is printed by the following program?\npublic class Deer {\n   enum Food {APPLES, BERRIES, GRASS}\n   protected class Diet {\n      private Food getFavorite() {\n         return Food.BERRIES;\n      }\n  }\n   public static void main(String[] seasons) {\n      System.out.print(switch(new Diet().getFavorite()) {\n         case APPLES - > \"a\";\n         case BERRIES - > \"b\";\n         default - > \"c\";\n      });\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "a"
      },
      {
        "key": "B",
        "text": "b"
      },
      {
        "key": "C",
        "text": "c"
      },
      {
        "key": "D",
        "text": "The code declaration of the Diet class does not compile."
      },
      {
        "key": "E",
        "text": "The main() method does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which of the following are printed by the Bear program? (Choose all that apply.)\npublic class Bear {\n   enum FOOD {\n      BERRIES, INSECTS {\n         public boolean isHealthy() { return true; }},\n      FISH, ROOTS, COOKIES, HONEY;\n      public abstract boolean isHealthy();\n   }\n   public static void main(String[] args) {\n      System.out.print(FOOD.INSECTS);\n      System.out.print(FOOD.INSECTS.ordinal());\n      System.out.print(FOOD.INSECTS.isHealthy());\n      System.out.print(FOOD.COOKIES.isHealthy());\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "insects"
      },
      {
        "key": "B",
        "text": "INSECTS"
      },
      {
        "key": "C",
        "text": "0"
      },
      {
        "key": "D",
        "text": "1"
      },
      {
        "key": "E",
        "text": "false"
      },
      {
        "key": "F",
        "text": "true"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which statements about polymorphism and method inheritance are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Given an arbitrary instance of a class, it cannot be determined until runtime which over -\nridden method will be executed in a parent class."
      },
      {
        "key": "B",
        "text": "It cannot be determined until runtime which hidden method will be executed in a parent \nclass."
      },
      {
        "key": "C",
        "text": "Marking a method static prevents it from being overridden or hidden."
      },
      {
        "key": "D",
        "text": "Marking a method final prevents it from being overridden or hidden."
      },
      {
        "key": "E",
        "text": "The reference type of the variable determines which overridden method will be called at \nruntime."
      },
      {
        "key": "F",
        "text": "The reference type of the variable determines which hidden method will be called at run-\ntime.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Given the following record declaration, which lines of code can fill in the blank and allow \nthe code to compile? (Choose all that apply.)\npublic record RabbitFood(int size, String brand, LocalDate expires) {\n   public static int MAX_STORAGE = 100;\n   public RabbitFood() {\n      ;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "size = MAX_STORAGE"
      },
      {
        "key": "B",
        "text": "this.size = 10"
      },
      {
        "key": "C",
        "text": "if(expires.isAfter(LocalDate.now())) throw new  \nRuntimeException()"
      },
      {
        "key": "D",
        "text": "if(brand==null) super.brand = \"Unknown\""
      },
      {
        "key": "E",
        "text": "throw new RuntimeException()"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which of the following can be inserted in the rest() method? (Choose all that apply.)\npublic class Lion {\n   class Cub {}\n   static class Den {}\n   static void rest() {\n       ;\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Cub a = Lion.new Cub()"
      },
      {
        "key": "B",
        "text": "Lion.Cub b = new Lion().Cub()"
      },
      {
        "key": "C",
        "text": "Lion.Cub c = new Lion().new Cub()"
      },
      {
        "key": "D",
        "text": "var d = new Den()"
      },
      {
        "key": "E",
        "text": "var e = Lion.new Cub()"
      },
      {
        "key": "F",
        "text": "Lion.Den f = Lion.new Den()"
      },
      {
        "key": "G",
        "text": "Lion.Den g = new Lion.Den()"
      },
      {
        "key": "H",
        "text": "var h = new Cub()\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "Given the following program, what can be inserted into the blank line that would allow it to \nprint Swim! at runtime?\ninterface Swim {\n   default void perform() { System.out.print(\"Swim!\"); }\n}\ninterface Dance {\n   default void perform() { System.out.print(\"Dance!\"); }\n}\npublic class Penguin implements Swim, Dance {\n   public void perform() { System.out.print(\"Smile!\"); }\n   private void doShow() {\n     ;\n   }\n   public static void main(String[] eggs) {\n      new Penguin().doShow();\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "super.perform()"
      },
      {
        "key": "B",
        "text": "Swim.perform()"
      },
      {
        "key": "C",
        "text": "super.Swim.perform()"
      },
      {
        "key": "D",
        "text": "Swim.super.perform()"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is inserted into the blank."
      },
      {
        "key": "F",
        "text": "The code compiles, but due to polymorphism, it is not possible to produce the requested \noutput without creating a new object.\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "Which lines of the following interface do not compile? (Choose all that apply.)\n1: public interface BigCat {\n2:    abstract String getName();\n3:    static int hunt() { getName(); return 5; }\n4:    default void climb() { rest(); }\n5:    private void roar() { getName();  climb(); hunt(); }\n6:    private static boolean sneak() { roar(); return true; }\n7:    private int rest() { return 2; };\n8: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 2"
      },
      {
        "key": "B",
        "text": "Line 3"
      },
      {
        "key": "C",
        "text": "Line 4"
      },
      {
        "key": "D",
        "text": "Line 5"
      },
      {
        "key": "E",
        "text": "Line 6"
      },
      {
        "key": "F",
        "text": "Line 7"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "What does the following program print?\n1:  public class Zebra {\n2:     private int x = 24;\n3:     public int hunt() {\n4:        String message = \"x is \";\n5:        abstract class Stripes {\n6:           private int x = 0;\n7:           public void print() {\n8:              System.out.print(message + Zebra.this.x);\n9:           }\n10:       }\n11:       var s = new Stripes() {};\n12:       s.print();\n13:       return x;\n14:    }\n15:    public static void main(String[] args) {\n16:       new Zebra().hunt();\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "x is 0"
      },
      {
        "key": "B",
        "text": "x is 24"
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 8 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 11 generates a compiler error."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "Which statements about the following enum are true? (Choose all that apply.)\n1:  public enum Animals {\n2:     MAMMAL(true), INVERTEBRATE(Boolean.FALSE), BIRD(false),\n3:     REPTILE(false), AMPHIBIAN(false), FISH(false) {\n4:        public int swim() { return 4; }\n5:     }\n6:     final boolean hasHair;\n7:     public Animals(boolean hasHair) {\n8:        this.hasHair = hasHair;\n9:     }\n10:    public boolean hasHair() { return hasHair; }\n11:    public int swim() { return 0; }\n12: }",
    "choices": [
      {
        "key": "A",
        "text": "Compiler error on line 2"
      },
      {
        "key": "B",
        "text": "Compiler error on line 3"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 8"
      },
      {
        "key": "E",
        "text": "Compiler error on line 10"
      },
      {
        "key": "F",
        "text": "Compiler error on another line"
      },
      {
        "key": "G",
        "text": "The code compiles successfully.\n2 7. Assuming a record is defined with at least one field, which components does the compiler \nalways insert, each of which may be overridden or redeclared? (Choose all that apply.)"
      },
      {
        "key": "A",
        "text": "A no- argument constructor"
      },
      {
        "key": "B",
        "text": "An accessor method for each field"
      },
      {
        "key": "C",
        "text": "The toString() method"
      },
      {
        "key": "D",
        "text": "The equals() method"
      },
      {
        "key": "E",
        "text": "A mutator method for each field"
      },
      {
        "key": "F",
        "text": "A sort method for each field"
      },
      {
        "key": "G",
        "text": "The hashCode() method\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The try block is not capable of throwing an IOException, making the catch block \nunreachable code and option A incorrect. Options B and F are correct, as both are unchecked \nexceptions that do not extend or inherit from IllegalArgumentException. Remember, \nit is not a good idea to catch Error in practice, although because it is possible, it may come \nup on the exam. Option C is incorrect because the variable c is declared already in the \nmethod declaration. Option D is incorrect because the IllegalArgumentException\ninherits from RuntimeException, making the first declaration unnecessary. \nSimilarly, option E is incorrect because NumberFormatException inherits from \nIllegalArgumentException, making the second declaration unnecessary. Since options \nB and F are correct, option G is incorrect.\nChapter 12: Modules 949\nChapter 12: Modules\n"
  },
  {
    "question": "Which of the following classes and interfaces do not compile? (Choose all that apply.)\npublic abstract class Camel { void travel(); }\n \npublic interface EatsGrass { private abstract int chew(); }\n \npublic abstract class Elephant {\n   abstract private class SleepsAlot {\n      abstract int sleep();\n   } }\n \npublic class Eagle { abstract soar(); }\n \npublic interface Spider { default void crawl() {} }",
    "choices": [
      {
        "key": "A",
        "text": "Camel"
      },
      {
        "key": "B",
        "text": "EatsGrass"
      },
      {
        "key": "C",
        "text": "Elephant"
      },
      {
        "key": "D",
        "text": "Eagle"
      },
      {
        "key": "E",
        "text": "Spider"
      },
      {
        "key": "F",
        "text": "None of the classes or interfaces compile.\n"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Camel does not compile because the travel() method does not declare a \nbody, nor is it marked abstract, making option A correct. EatsGrass also does not \ncompile because an interface method cannot be marked both private and abstract, \nmaking option B correct. Finally, Eagle does not compile because it declares an abstract \nmethod soar() in a concrete class, making option D correct. The other classes compile \nwithout issue.\n\n"
  },
  {
    "question": "How many lines of the following program contain a compilation error?\n1:  class Primate {\n2:     protected int age = 2;\n3:     { age = 1; }\n4:     public Primate() {\n5:        this().age = 3;\n6:     }\n7:  }\n8:  public class Orangutan {\n9:     protected int age = 4;\n10:    { age = 5; }\n11:    public Orangutan() {\n12:       this().age = 6;\n13:    }\n14:    public static void main(String[] bananas) {\n15:       final Primate x = (Primate)new Orangutan();\n16:       System.out.println(x.age);\n17:    }\n18: }",
    "choices": [
      {
        "key": "A",
        "text": "None, and the program prints 1 at runtime."
      },
      {
        "key": "B",
        "text": "None, and the program prints 3 at runtime."
      },
      {
        "key": "C",
        "text": "None, but it causes a ClassCastException at runtime."
      },
      {
        "key": "D",
        "text": "1"
      },
      {
        "key": "E",
        "text": "2"
      },
      {
        "key": "F",
        "text": "3"
      },
      {
        "key": "G",
        "text": "4\n"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile, so options A through C are incorrect. Both lines 5 and 12 do \nnot compile, as this() is used instead of this. Remember, this() refers to calling a con\u0002structor, whereas this is a reference to the current instance. Next, the compiler does not \nallow casting to an unrelated class type. Since Orangutan is not a subclass of Primate, the \ncast on line 15 is invalid, and the code does not compile. Due to these three lines containing \ncompilation errors, option F is the correct answer.\n"
  },
  {
    "question": "Assuming the following classes are declared as top- level types in the same file, which classes \ncontain compiler errors? (Choose all that apply.)\nsealed class Bird {\n   public final class Flamingo extends Bird {}   \n}\n \nsealed class Monkey {}\n \nclass EmperorTamarin extends Monkey {}\n \nnon- sealed class Mandrill extends Monkey {}\n \nsealed class Friendly extends Mandrill permits Silly {}\n \nfinal class Silly {}",
    "choices": [
      {
        "key": "A",
        "text": "Bird"
      },
      {
        "key": "B",
        "text": "Monkey"
      },
      {
        "key": "C",
        "text": "EmperorTamarin"
      },
      {
        "key": "D",
        "text": "Mandrill"
      },
      {
        "key": "E",
        "text": "Friendly"
      },
      {
        "key": "F",
        "text": "Silly"
      },
      {
        "key": "G",
        "text": "All of the classes compile without issue.\nLambdas and\n\n"
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Bird and its nested Flamingo subclass compile without issue. The permits clause is \noptional if the subclass is nested or declared in the same file. For this reason, Monkey and its \nsubclass Mandrill also compile without issue. EmperorTamarin does not compile, as it is \nmissing a non-sealed, sealed, or final modifier, making option C correct. Friendly\nalso does not compile, since it lists a subclass Silly that does not extend it, making option \nE correct. While the permits clause is optional, the extends clause is not. Silly compiles \njust fine. Even though it does not extend Friendly, the compiler error is in the sealed class.\nChapter 8: Lambdas and Functional \nInterfaces\n"
  },
  {
    "question": "What is the result of the following class?\n1:  import java.util.function.*;\n2:\n3:  public class Panda {\n4:     int age;\n5:     public static void main(String[] args) {\n6:        Panda p1 = new Panda();\n7:        p1.age = 1;\n8:        check(p1, p - > p.age < 5);\n9:     }\n10:    private static void check(Panda panda,\n11:       Predicate<Panda> pred) {\n12:       String result =\n13:          pred.test(panda) ? \"match\" : \"not match\";\n14:       System.out.print(result);\n15: } }",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8"
      },
      {
        "key": "D",
        "text": "Compiler error on lines 10 and 11"
      },
      {
        "key": "E",
        "text": "Compiler error on lines 12 and 13"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "What is the result of the following code?\n1:  interface Climb {\n2:     boolean isTooHigh(int height, int limit);\n3:  }\n4:\n5:  public class Climber {\n6:     public static void main(String[] args) {\n7:        check((h, m) - > h.append(m).isEmpty(), 5);\n8:     }\n9:     private static void check(Climb climb, int height) {\n10:       if (climb.isTooHigh(height, 10))\n11:          System.out.println(\"too high\");\n12:       else\n13:          System.out.println(\"ok\");\n14:    }\n15: }",
    "choices": [
      {
        "key": "A",
        "text": "ok"
      },
      {
        "key": "B",
        "text": "too high"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on a different line"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which statements about functional interfaces are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A functional interface can contain default and private methods."
      },
      {
        "key": "B",
        "text": "A functional interface can be defined as a class or an interface."
      },
      {
        "key": "C",
        "text": "Abstract methods with signatures that are contained in public methods of \njava.lang.Object do not count toward the abstract method count for a functional \ninterface."
      },
      {
        "key": "D",
        "text": "A functional interface cannot contain static or private static methods."
      },
      {
        "key": "E",
        "text": "A functional interface must be marked with the @FunctionalInterface annotation.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which lambda can replace the MySecret class to return the same value? (Choose all \nthat apply.)\ninterface Secret {\n   String magic(double d);\n}\n \nclass MySecret implements Secret {\n   public String magic(double d) {\n      return \"Poof\";\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "(e) - > \"Poof\""
      },
      {
        "key": "B",
        "text": "(e) - > {\"Poof\"}"
      },
      {
        "key": "C",
        "text": "(e) - > { String e = \"\"; \"Poof\" }"
      },
      {
        "key": "D",
        "text": "(e) - > { String e = \"\"; return \"Poof\"; }"
      },
      {
        "key": "E",
        "text": "(e) - > { String e = \"\"; return \"Poof\" }"
      },
      {
        "key": "F",
        "text": "(e) - > { String f = \"\"; return \"Poof\"; }\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which of the following functional interfaces contain an abstract method that returns a primi-\ntive value? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "BooleanSupplier"
      },
      {
        "key": "B",
        "text": "CharSupplier"
      },
      {
        "key": "C",
        "text": "DoubleSupplier"
      },
      {
        "key": "D",
        "text": "FloatSupplier"
      },
      {
        "key": "E",
        "text": "IntSupplier"
      },
      {
        "key": "F",
        "text": "StringSupplier\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following lambda expressions can be passed to a function of Predicate<String>  \ntype? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "s - > s.isEmpty()"
      },
      {
        "key": "B",
        "text": "s - - > s.isEmpty()"
      },
      {
        "key": "C",
        "text": "(String s) - > s.isEmpty()"
      },
      {
        "key": "D",
        "text": "(String s) - - > s.isEmpty()"
      },
      {
        "key": "E",
        "text": "(StringBuilder s) - > s.isEmpty()"
      },
      {
        "key": "F",
        "text": "(StringBuilder s) - - > s.isEmpty()\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Which of these statements is true about the following code?\npublic void method() {\n   x((var x) - > {}, (var x, var y) - > false);\n}\npublic void x(Consumer<String> x, BinaryOperator<Boolean> y) {}",
    "choices": [
      {
        "key": "A",
        "text": "The code does not compile because of one of the variables named x."
      },
      {
        "key": "B",
        "text": "The code does not compile because of one of the variables named y."
      },
      {
        "key": "C",
        "text": "The code does not compile for another reason."
      },
      {
        "key": "D",
        "text": "The code compiles, and the x in each lambda refers to the same type."
      },
      {
        "key": "E",
        "text": "The code compiles, and the x in each lambda refers to a different type.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following is equivalent to this code? (Choose all that apply.)\nUnaryOperator<Integer> u = x - > x * x;",
    "choices": [
      {
        "key": "A",
        "text": "BiFunction<Integer> f = x - > x*x;"
      },
      {
        "key": "B",
        "text": "BiFunction<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "C",
        "text": "BinaryOperator<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "D",
        "text": "Function<Integer> f = x - > x*x;"
      },
      {
        "key": "E",
        "text": "Function<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The Consumer interface is good for printing out an existing value."
      },
      {
        "key": "B",
        "text": "The Supplier interface is good for printing out an existing value."
      },
      {
        "key": "C",
        "text": "The IntegerSupplier interface returns an int."
      },
      {
        "key": "D",
        "text": "The Predicate interface returns an int."
      },
      {
        "key": "E",
        "text": "The Function interface has a method named test()."
      },
      {
        "key": "F",
        "text": "The Predicate interface has a method named test().\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which of the following can be inserted without causing a compilation error? (Choose all \nthat apply.)\npublic void remove(List<Character> chars) {\n   char end = 'z';\n   Predicate<Character> predicate = c - > {\n      char start = 'a'; return start <= c && c <= end; };\n \n   // INSERT LINE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "char start = 'a';"
      },
      {
        "key": "B",
        "text": "char c = 'x';"
      },
      {
        "key": "C",
        "text": "chars = null;"
      },
      {
        "key": "D",
        "text": "end = '1';"
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "How many times is true printed out by this code?\nimport java.util.function.Predicate;\npublic class Fantasy {\n   public static void scary(String animal) {\n      var dino = s - > \"dino\".equals(animal);\n      var dragon = s - > \"dragon\".equals(animal);\n      var combined = dino.or(dragon);\n      System.out.println(combined.test(animal));\n   }\n   public static void main(String[] args) {\n      scary(\"dino\");\n      scary(\"dragon\");\n      scary(\"unicorn\");\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "One"
      },
      {
        "key": "B",
        "text": "Two"
      },
      {
        "key": "C",
        "text": "Three"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "What does the following code output?\nFunction<Integer, Integer> s = a - > a + 4;\nFunction<Integer, Integer> t = a - > a * 3;\nFunction<Integer, Integer> c = s.compose(t);\nSystem.out.print(c.apply(1));",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "15"
      },
      {
        "key": "C",
        "text": "The code does not compile because of the data types in the lambda expressions."
      },
      {
        "key": "D",
        "text": "The code does not compile because of the compose() call."
      },
      {
        "key": "E",
        "text": "The code does not compile for another reason.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which is true of the following code?\nint length = 3;\n \nfor (int i = 0; i<3; i++) {\n   if (i%2 == 0) {\n      Supplier<Integer> supplier = () - > length; // A\n      System.out.println(supplier.get());        // B\n   } else {\n      int j = i;\n      Supplier<Integer> supplier = () - > j;      // C\n      System.out.println(supplier.get());        // D\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The first compiler error is on line A."
      },
      {
        "key": "B",
        "text": "The first compiler error is on line B."
      },
      {
        "key": "C",
        "text": "The first compiler error is on line C."
      },
      {
        "key": "D",
        "text": "The first compiler error is on line D."
      },
      {
        "key": "E",
        "text": "The code compiles successfully.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following are valid lambda expressions? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "(Wolf w, var c) - > 39"
      },
      {
        "key": "B",
        "text": "(final Camel c) - > {}"
      },
      {
        "key": "C",
        "text": "(a,b,c) - > {int b = 3; return 2;}"
      },
      {
        "key": "D",
        "text": "(x,y) - > new RuntimeException()"
      },
      {
        "key": "E",
        "text": "(var y) - > return 0;"
      },
      {
        "key": "F",
        "text": "() - > {float r}"
      },
      {
        "key": "G",
        "text": "(Cat a, b) - > {}\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which lambda expression, when entered into the blank line in the following code, causes the \nprogram to print hahaha? (Choose all that apply.)\nimport java.util.function.Predicate;\npublic class Hyena {\n   private int age = 1;\n   public static void main(String[] args) {\n      var p = new Hyena();\n      double height = 10;\n      int age = 1;\n      testLaugh(p,  );\n      age = 2;\n   }\n   static void testLaugh(Hyena panda, Predicate<Hyena> joke) {\n      var r = joke.test(panda) ? \"hahaha\" : \"silence\";\n      System.out.print(r);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "var - > p.age <= 10"
      },
      {
        "key": "B",
        "text": "shenzi - > age==1"
      },
      {
        "key": "C",
        "text": "p - > true"
      },
      {
        "key": "D",
        "text": "age==1"
      },
      {
        "key": "E",
        "text": "shenzi - > age==2"
      },
      {
        "key": "F",
        "text": "h - > h.age < 5"
      },
      {
        "key": "G",
        "text": "None of the above, as the code does not compile\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Which of the following can be inserted without causing a compilation error? (Choose all \nthat apply.)\npublic void remove(List<Character> chars) {\n   char end = 'z';\n \n   // INSERT LINE HERE\n \n   Predicate<Character> predicate =  c - > {\n      char start = 'a'; return start <= c && c <= end; };\n}",
    "choices": [
      {
        "key": "A",
        "text": "char start = 'a';"
      },
      {
        "key": "B",
        "text": "char c = 'x';"
      },
      {
        "key": "C",
        "text": "chars = null;"
      },
      {
        "key": "D",
        "text": "end = '1';"
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What is the result of running the following class?\n1:  import java.util.function.*;\n2:\n3:  public class Panda {\n4:     int age;\n5:     public static void main(String[] args) {\n6:        Panda p1 = new Panda();\n7:        p1.age = 1;\n8:        check(p1, p - > {p.age < 5});\n9:     }\n10:    private static void check(Panda panda,\n11:       Predicate<Panda> pred) {\n12:       String result = pred.test(panda)\n13:          ? \"match\" : \"not match\";\n14:       System.out.print(result);\n15: } }",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on line 12"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which functional interfaces complete the following code? For line 7, assume m and n are \ninstances of functional interfaces that exist and have the same type as y. (Choose three.)\n6:  x = String::new;\n7:  y = m.andThen(n);\n8:  z = a - > a + a;",
    "choices": [
      {
        "key": "A",
        "text": "BinaryConsumer<String, String>"
      },
      {
        "key": "B",
        "text": "BiConsumer<String, String>"
      },
      {
        "key": "C",
        "text": "BinaryFunction<String, String>"
      },
      {
        "key": "D",
        "text": "BiFunction<String, String>"
      },
      {
        "key": "E",
        "text": "Predicate<String>"
      },
      {
        "key": "F",
        "text": "Supplier<String>"
      },
      {
        "key": "G",
        "text": "UnaryOperator<String>"
      },
      {
        "key": "H",
        "text": "UnaryOperator<String, String>\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which of the following compiles and prints out the entire set? (Choose all that apply.)\nSet<?> set = Set.of(\"lion\", \"tiger\", \"bear\");\nvar s = Set.copyOf(set);\nConsumer<Object> consumer =  ;\ns.forEach(consumer);",
    "choices": [
      {
        "key": "A",
        "text": "() - > System.out.println(s)"
      },
      {
        "key": "B",
        "text": "s - > System.out.println(s)"
      },
      {
        "key": "C",
        "text": "(s) - > System.out.println(s)"
      },
      {
        "key": "D",
        "text": "System.out.println(s)"
      },
      {
        "key": "E",
        "text": "System::out::println"
      },
      {
        "key": "F",
        "text": "System.out::println\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which lambdas can replace the new Sloth() call in the main() method and produce the \nsame output at runtime? (Choose all that apply.)\nimport java.util.List;\ninterface Yawn {\n   String yawn(double d, List<Integer> time);\n}\nclass Sloth implements Yawn {\n   public String yawn(double zzz, List<Integer> time) {\n      return \"Sleep: \" + zzz;\n   } }\npublic class Vet {\n   public static String takeNap(Yawn y) {\n      return y.yawn(10, null);\n   }\n   public static void main(String... unused) {\n      System.out.print(takeNap(new Sloth()));\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "(z,f) - > { String x = \"\"; return \"Sleep: \" + x }"
      },
      {
        "key": "B",
        "text": "(t,s) - > { String t = \"\"; return \"Sleep: \" + t; }"
      },
      {
        "key": "C",
        "text": "(w,q) - > {\"Sleep: \" + w}"
      },
      {
        "key": "D",
        "text": "(e,u) - > { String g = \"\"; \"Sleep: \" + e }"
      },
      {
        "key": "E",
        "text": "(a,b) - > \"Sleep: \" + (double)(b==null ? a : a)"
      },
      {
        "key": "F",
        "text": "(r,k) - > { String g = \"\"; return \"Sleep:\"; }"
      },
      {
        "key": "G",
        "text": "None of the above, as the program does not compile\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Which of the following are valid functional interfaces? (Choose all that apply.)\npublic interface Transport {\n   public int go();\n   public boolean equals(Object o);\n}\n \npublic abstract class Car {\n   public abstract Object swim(double speed, int duration);\n}\n \npublic interface Locomotive extends Train {\n   public int getSpeed();\n}\n \npublic interface Train extends Transport {}\n \nabstract interface Spaceship extends Transport {\n   default int blastOff();\n}\n \npublic interface Boat {\n   int hashCode();\n   int hashCode(String input);\n}",
    "choices": [
      {
        "key": "A",
        "text": "Boat"
      },
      {
        "key": "B",
        "text": "Car"
      },
      {
        "key": "C",
        "text": "Locomotive"
      },
      {
        "key": "D",
        "text": "Spaceship"
      },
      {
        "key": "E",
        "text": "Transport"
      },
      {
        "key": "F",
        "text": "Train"
      },
      {
        "key": "G",
        "text": "None of these is a valid functional interface.\nCollections\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Suppose you need to display a collection of products for sale, which may contain duplicates. \nAdditionally, you have a collection of sales that you need to track, sorted by the natural order \nof the sale ID, and you need to retrieve the text of each. Which two of the following from the \njava.util package best suit your needs for this scenario? (Choose two.)",
    "choices": [
      {
        "key": "A",
        "text": "ArrayList"
      },
      {
        "key": "B",
        "text": "HashMap"
      },
      {
        "key": "C",
        "text": "HashSet"
      },
      {
        "key": "D",
        "text": "LinkedList"
      },
      {
        "key": "E",
        "text": "TreeMap"
      },
      {
        "key": "F",
        "text": "TreeSet\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which of the following are true? (Choose all that apply.)\n12: List<?> q = List.of(\"mouse\", \"parrot\");\n13: var v = List.of(\"mouse\", \"parrot\");\n14:\n15: q.removeIf(String::isEmpty);\n16: q.removeIf(s - > s.length() == 4);\n17: v.removeIf(String::isEmpty);\n18: v.removeIf(s - > s.length() == 4);",
    "choices": [
      {
        "key": "A",
        "text": "This code compiles and runs without error."
      },
      {
        "key": "B",
        "text": "Exactly one of these lines contains a compiler error."
      },
      {
        "key": "C",
        "text": "Exactly two of these lines contain a compiler error."
      },
      {
        "key": "D",
        "text": "Exactly three of these lines contain a compiler error."
      },
      {
        "key": "E",
        "text": "Exactly four of these lines contain a compiler error."
      },
      {
        "key": "F",
        "text": "If any lines with compiler errors are removed, this code runs without throwing an \nexception."
      },
      {
        "key": "G",
        "text": "If any lines with compiler errors are removed, this code throws an exception.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "What is the result of the following statements?\n3:  var greetings = new ArrayDeque<String>();\n4:  greetings.offerLast(\"hello\");\n5:  greetings.offerLast(\"hi\");\n6:  greetings.offerFirst(\"ola\");\n7:  greetings.pop();\n8:  greetings.peek();\n9:  while (greetings.peek() != null)\n10:    System.out.print(greetings.pop());",
    "choices": [
      {
        "key": "A",
        "text": "hello"
      },
      {
        "key": "B",
        "text": "hellohi"
      },
      {
        "key": "C",
        "text": "hellohiola"
      },
      {
        "key": "D",
        "text": "hiola"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which of these statements compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "HashSet<Number> hs = new HashSet<Integer>();"
      },
      {
        "key": "B",
        "text": "HashSet<? super ClassCastException> set = new \nHashSet<Exception>();"
      },
      {
        "key": "C",
        "text": "List<> list = new ArrayList<String>();"
      },
      {
        "key": "D",
        "text": "List<Object> values = new HashSet<Object>();"
      },
      {
        "key": "E",
        "text": "List<Object> objects = new ArrayList<? extends Object>();"
      },
      {
        "key": "F",
        "text": "Map<String, ? extends Number> hm = new HashMap<String, \nInteger>();\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "What is the result of the following code?\n1: public record Hello<T>(T t) {\n2:    public Hello(T t) { this.t = t; }\n3:    private <T> void println(T message) {\n4:       System.out.print(t + \"- \" + message);\n5:    }\n6:    public static void main(String[] args) {\n7:       new Hello<String>(\"hi\").println(1);\n8:       new Hello(\"hola\").println(true);\n9:    } }",
    "choices": [
      {
        "key": "A",
        "text": "hi followed by a runtime exception"
      },
      {
        "key": "B",
        "text": "hi- 1hola- true"
      },
      {
        "key": "C",
        "text": "The first compiler error is on line 1."
      },
      {
        "key": "D",
        "text": "The first compiler error is on line 3."
      },
      {
        "key": "E",
        "text": "The first compiler error is on line 8."
      },
      {
        "key": "F",
        "text": "The first compiler error is on another line.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following can fill in the blank to print [7, 5, 3]? (Choose all that apply.)\n8:  public record Platypus(String name, int beakLength) {\n9:     @Override public String toString() {return \"\" + beakLength;}\n10:\n11:    public static void main(String[] args) {\n12:       Platypus p1 = new Platypus(\"Paula\", 3);\n13:       Platypus p2 = new Platypus(\"Peter\", 5);\n14:       Platypus p3 = new Platypus(\"Peter\", 7);\n15:\n16:       List<Platypus> list = Arrays.asList(p1, p2, p3);\n17:\n18:       Collections.sort(list, Comparator.comparing      );\n19:\n20:       System.out.println(list);\n21:    }\n22: }\nA. \n(Platypus::beakLength)\nB. \n(Platypus::beakLength).reversed()\nC. \n(Platypus::name)\n   .thenComparing(Platypus::beakLength)\nD. \n(Platypus::name)\n   .thenComparing(\n   Comparator.comparing(Platypus::beakLength)\n   .reversed())\nE. \n(Platypus::name)\n   .thenComparingNumber(Platypus::beakLength)\n   .reversed()\nF. \n(Platypus::name)\n   .thenComparingInt(Platypus::beakLength)\n   .reversed()",
    "choices": [
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Which of the following method signatures are valid overrides of the hairy() method in the \nAlpaca class? (Choose all that apply.)\nimport java.util.*;\n \npublic class Alpaca {\n   public List<String> hairy(List<String> list) { return null; }\n}",
    "choices": [
      {
        "key": "A",
        "text": "public List<String> hairy(List<CharSequence> list) { return null; }"
      },
      {
        "key": "B",
        "text": "public List<String> hairy(ArrayList<String> list) { return null; }"
      },
      {
        "key": "C",
        "text": "public List<String> hairy(List<Integer> list) { return null; }"
      },
      {
        "key": "D",
        "text": "public List<CharSequence> hairy(List<String> list) { return null; }"
      },
      {
        "key": "E",
        "text": "public Object hairy(List<String> list) { return null; }"
      },
      {
        "key": "F",
        "text": "public ArrayList<String> hairy(List<String> list) { return null; }\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "What is the result of the following program?\n3:  public class MyComparator implements Comparator<String> {\n4:     public int compare(String a, String b) {\n5:        return b.toLowerCase().compareTo(a.toLowerCase());\n6:     }\n7:     public static void main(String[] args) {\n8:        String[] values = { \"123\", \"Abb\", \"aab\" };\n9:        Arrays.sort(values, new MyComparator());\n10:       for (var s: values)\n11:          System.out.print(s + \" \");\n12:    }\n13: }",
    "choices": [
      {
        "key": "A",
        "text": "Abb aab 123"
      },
      {
        "key": "B",
        "text": "aab Abb 123"
      },
      {
        "key": "C",
        "text": "123 Abb aab"
      },
      {
        "key": "D",
        "text": "123 aab Abb"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of these statements can fill in the blank so that the Helper class compiles successfully? \n(Choose all that apply.)\n2:  public class Helper {\n3:     public static <U extends Exception>\n4:        void printException(U u) {\n5:\n6:        System.out.println(u.getMessage());\n7:     }\n8:     public static void main(String[] args) {\n9:        Helper.                                    ;\n10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "printException(new FileNotFoundException(\"A\"))"
      },
      {
        "key": "B",
        "text": "printException(new Exception(\"B\"))"
      },
      {
        "key": "C",
        "text": "<Throwable>printException(new Exception(\"C\"))"
      },
      {
        "key": "D",
        "text": "<NullPointerException>printException(new NullPointerException \n(\"D\"))"
      },
      {
        "key": "E",
        "text": "printException(new Throwable(\"E\"))\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which of the following will compile when filling in the blank? (Choose all that apply.)\nvar list = List.of(1, 2, 3);\nvar set = Set.of(1, 2, 3);\nvar map = Map.of(1, 2, 3, 4);\n \n.forEach(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "list"
      },
      {
        "key": "B",
        "text": "set"
      },
      {
        "key": "C",
        "text": "map"
      },
      {
        "key": "D",
        "text": "map.keys()"
      },
      {
        "key": "E",
        "text": "map.keySet()"
      },
      {
        "key": "F",
        "text": "map.values()"
      },
      {
        "key": "G",
        "text": "map.valueSet()\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Which of these statements can fill in the blank so that the Wildcard class compiles success-\nfully? (Choose all that apply.)\n3:  public class Wildcard {\n4:     public void showSize(List<?> list) {\n5:        System.out.println(list.size());\n6:     }\n7:     public static void main(String[] args) {\n8:        Wildcard card = new Wildcard();\n9:        ;\n10:       card.showSize(list);\n11:    } }",
    "choices": [
      {
        "key": "A",
        "text": "List<?> list = new HashSet <String>()"
      },
      {
        "key": "B",
        "text": "ArrayList<? super Date> list = new ArrayList<Date>()"
      },
      {
        "key": "C",
        "text": "List<?> list = new ArrayList<?>()"
      },
      {
        "key": "D",
        "text": "List<Exception> list = new LinkedList<java.io.IOException>()"
      },
      {
        "key": "E",
        "text": "ArrayList <? extends Number> list = new ArrayList <Integer>()"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "What is the result of the following program?\n3:  public record Sorted(int num, String text)\n4:     implements Comparable<Sorted>, Comparator<Sorted> {\n5:\n6:     public String toString() { return \"\" + num; }\n7:     public int compareTo(Sorted s) {\n8:        return text.compareTo(s.text);\n9:     }\n10:    public int compare(Sorted s1, Sorted s2) {\n11:       return s1.num -  s2.num;\n12:    }\n13:    public static void main(String[] args) {\n14:       var s1 = new Sorted(88, \"a\");\n15:       var s2 = new Sorted(55, \"b\");\n16:       var t1 = new TreeSet<Sorted>();\n17:       t1.add(s1); t1.add(s2);\n18:       var t2 = new TreeSet<Sorted>(s1);\n19:       t2.add(s1); t2.add(s2);\n20:       System.out.println(t1 + \" \" + t2);\n21:    } }",
    "choices": [
      {
        "key": "A",
        "text": "[55, 88] [55, 88]"
      },
      {
        "key": "B",
        "text": "[55, 88] [88, 55]"
      },
      {
        "key": "C",
        "text": "[88, 55] [55, 88]"
      },
      {
        "key": "D",
        "text": "[88, 55] [88, 55]"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What is the result of the following code? (Choose all that apply.)\nComparator<Integer> c1 = (o1, o2) - > o2 -  o1;\nComparator<Integer> c2 = Comparator.naturalOrder();\nComparator<Integer> c3 = Comparator.reverseOrder();\n \nvar list = Arrays.asList(5, 4, 7, 2);\nCollections.sort(list,         );\nCollections.reverse(list);\nCollections.reverse(list);\nSystem.out.println(Collections.binarySearch(list, 2));",
    "choices": [
      {
        "key": "A",
        "text": "One or more of the comparators can fill in the blank so that the code prints 0."
      },
      {
        "key": "B",
        "text": "One or more of the comparators can fill in the blank so that the code prints 1."
      },
      {
        "key": "C",
        "text": "One or more of the comparators can fill in the blank so that the code prints 2."
      },
      {
        "key": "D",
        "text": "The result is undefined regardless of which comparator is used."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown regardless of which comparator is used."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following lines can be inserted to make the code compile? (Choose all \nthat apply.)\nclass W {}\nclass X extends W {}\nclass Y extends X {}\nclass Z<Y> {\n   // INSERT CODE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "W w1 = new W();"
      },
      {
        "key": "B",
        "text": "W w2 = new X();"
      },
      {
        "key": "C",
        "text": "W w3 = new Y();"
      },
      {
        "key": "D",
        "text": "Y y1 = new W();"
      },
      {
        "key": "E",
        "text": "Y y2 = new X();"
      },
      {
        "key": "F",
        "text": "Y y1 = new Y();\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which options are true of the following code? (Choose all that apply.)\n3:  q = new LinkedList<>();\n4: q.add(10);\n5: q.add(12);\n6: q.remove(1);\n7: System.out.print(q);",
    "choices": [
      {
        "key": "A",
        "text": "If we fill in the blank with List<Integer>, the output is [10]."
      },
      {
        "key": "B",
        "text": "If we fill in the blank with Queue<Integer>, the output is [10]."
      },
      {
        "key": "C",
        "text": "If we fill in the blank with var, the output is [10]."
      },
      {
        "key": "D",
        "text": "One or more of the scenarios does not compile."
      },
      {
        "key": "E",
        "text": "One or more of the scenarios throws a runtime exception.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "What is the result of the following code?\n4: Map m = new HashMap();\n5: m.put(123, \"456\");\n6: m.put(\"abc\", \"def\");\n7: System.out.println(m.contains(\"123\"));",
    "choices": [
      {
        "key": "A",
        "text": "false"
      },
      {
        "key": "B",
        "text": "true"
      },
      {
        "key": "C",
        "text": "Compiler error on line 4"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5"
      },
      {
        "key": "E",
        "text": "Compiler error on line 7"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What is the result of the following code? (Choose all that apply.)\n48: var map = Map.of(1,2, 3, 6);\n49: var list = List.copyOf(map.entrySet());\n50:\n51: List<Integer> one = List.of(8, 16, 2);\n52: var copy = List.copyOf(one);\n53: var copyOfCopy = List.copyOf(copy);\n54: var thirdCopy = new ArrayList<>(copyOfCopy);\n55:\n56: list.replaceAll(x - > x * 2);\n57: one.replaceAll(x - > x * 2);\n58: thirdCopy.replaceAll(x - > x * 2);\n59:\n60: System.out.println(thirdCopy);",
    "choices": [
      {
        "key": "A",
        "text": "One line fails to compile."
      },
      {
        "key": "B",
        "text": "Two lines fail to compile."
      },
      {
        "key": "C",
        "text": "Three lines fail to compile."
      },
      {
        "key": "D",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "E",
        "text": "If any lines with compiler errors are removed, the code throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "If any lines with compiler errors are removed, the code prints [16, 32, 4]."
      },
      {
        "key": "G",
        "text": "The code compiles and prints [16, 32, 4] without any changes.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "What code change is needed to make the method compile, assuming there is no \nclass named T?\npublic static T identity(T t) {\n   return t;\n}",
    "choices": [
      {
        "key": "A",
        "text": "Add <T> after the public keyword."
      },
      {
        "key": "B",
        "text": "Add <T> after the static keyword."
      },
      {
        "key": "C",
        "text": "Add <T> after T."
      },
      {
        "key": "D",
        "text": "Add <?> after the public keyword."
      },
      {
        "key": "E",
        "text": "Add <?> after the static keyword."
      },
      {
        "key": "F",
        "text": "No change is required. The code already compiles.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the result of the following?\nvar map = new HashMap<Integer, Integer>();\nmap.put(1, 10);\nmap.put(2, 20);\nmap.put(3, null);\nmap.merge(1, 3, (a,b) - > a + b);\nmap.merge(3, 3, (a,b) - > a + b);\nSystem.out.println(map);",
    "choices": [
      {
        "key": "A",
        "text": "{1=10, 2=20}"
      },
      {
        "key": "B",
        "text": "{1=10, 2=20, 3=null}"
      },
      {
        "key": "C",
        "text": "{1=10, 2=20, 3=3}"
      },
      {
        "key": "D",
        "text": "{1=13, 2=20}"
      },
      {
        "key": "E",
        "text": "{1=13, 2=20, 3=null}"
      },
      {
        "key": "F",
        "text": "{1=13, 2=20, 3=3}"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Comparable is in the java.util package."
      },
      {
        "key": "B",
        "text": "Comparator is in the java.util package."
      },
      {
        "key": "C",
        "text": "compare() is in the Comparable interface."
      },
      {
        "key": "D",
        "text": "compare() is in the Comparator interface."
      },
      {
        "key": "E",
        "text": "compare() takes one method parameter."
      },
      {
        "key": "F",
        "text": "compare() takes two method parameters.\n\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "What could be the output of the following?\nvar stream = Stream.iterate(\"\", (s) - > s + \"1\");\nSystem.out.println(stream.limit(2).map(x - > x + \"2\"));",
    "choices": [
      {
        "key": "A",
        "text": "12112"
      },
      {
        "key": "B",
        "text": "212"
      },
      {
        "key": "C",
        "text": "212112"
      },
      {
        "key": "D",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      },
      {
        "key": "G",
        "text": "The code hangs.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "What could be the output of the following?\nPredicate<String> predicate = s - > s.startsWith(\"g\");\nvar stream1 = Stream.generate(() - > \"growl!\");\nvar stream2 = Stream.generate(() - > \"growl!\");\nvar b1 = stream1.anyMatch(predicate);\nvar b2 = stream2.allMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
    "choices": [
      {
        "key": "A",
        "text": "true false"
      },
      {
        "key": "B",
        "text": "true true"
      },
      {
        "key": "C",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code hangs.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "What could be the output of the following?\nPredicate<String> predicate = s - > s.length()> 3;\nvar stream = Stream.iterate(\"- \",\n    s - > ! s.isEmpty(), (s) - > s + s);\nvar b1 = stream.noneMatch(predicate);\nvar b2 = stream.anyMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
    "choices": [
      {
        "key": "A",
        "text": "false false"
      },
      {
        "key": "B",
        "text": "false true"
      },
      {
        "key": "C",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code hangs.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which are true statements about terminal operations in a stream that runs successfully? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "At most one terminal operation can exist in a stream pipeline."
      },
      {
        "key": "B",
        "text": "Terminal operations are a required part of the stream pipeline in order to get a result."
      },
      {
        "key": "C",
        "text": "Terminal operations have Stream as the return type."
      },
      {
        "key": "D",
        "text": "The peek() method is an example of a terminal operation."
      },
      {
        "key": "E",
        "text": "The referenced Stream may be used after calling a terminal operation.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which of the following sets result to 8.0? (Choose all that apply.)\nA. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));\nB. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));\nC. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n    .stream()\n   .collect(Collectors.averagingInt(x - > x));\nD. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));\nE. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));\nF. \ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));",
    "choices": [],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following can fill in the blank so that the code prints out false? (Choose all \nthat apply.)\nvar s = Stream.generate(() - > \"meow\");\nvar match = s. (String::isEmpty);\nSystem.out.println(match);",
    "choices": [
      {
        "key": "A",
        "text": "allMatch"
      },
      {
        "key": "B",
        "text": "anyMatch"
      },
      {
        "key": "C",
        "text": "findAny"
      },
      {
        "key": "D",
        "text": "findFirst"
      },
      {
        "key": "E",
        "text": "noneMatch"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "We have a method that returns a sorted list without changing the original. Which of the fol-\nlowing can replace the method implementation to do the same with streams?\nprivate static List<String> sort(List<String> list) {\n   var copy = new ArrayList<String>(list);\n   Collections.sort(copy, (a, b) - > b.compareTo(a));\n   return copy;\n}\nA. \nreturn list.stream()\n   .compare((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());\nB. \nreturn list.stream()\n   .compare((a, b) - > b.compareTo(a))\n   .sort();\nC. \nreturn list.stream()\n   .compareTo((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());\nD. \nreturn list.stream()\n   .compareTo((a, b) - > b.compareTo(a))\n   .sort();\nE. \nreturn list.stream()\n   .sorted((a, b) - > b.compareTo(a))\n    .collect();\nF. \nreturn list.stream()\n   .sorted((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());",
    "choices": [],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following are true given this declaration? (Choose all that apply.)\nvar is = IntStream.empty();",
    "choices": [
      {
        "key": "A",
        "text": "is.average() returns the type int."
      },
      {
        "key": "B",
        "text": "is.average() returns the type OptionalInt."
      },
      {
        "key": "C",
        "text": "is.findAny() returns the type int."
      },
      {
        "key": "D",
        "text": "is.findAny() returns the type OptionalInt."
      },
      {
        "key": "E",
        "text": "is.sum() returns the type int."
      },
      {
        "key": "F",
        "text": "is.sum() returns the type OptionalInt.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which of the following can we add after line 6 for the code to run without error and not pro-\nduce any output? (Choose all that apply.)\n4: var stream = LongStream.of(1, 2, 3);\n5: var opt = stream.map(n - > n * 10)\n6:    .filter(n - > n < 5).findFirst();\nA. \nif (opt.isPresent())\n   System.out.println(opt.get());\nB. \nif (opt.isPresent())\n   System.out.println(opt.getAsLong());\nC. \nopt.ifPresent(System.out.println);\nD. \nopt.ifPresent(System.out::println);",
    "choices": [
      {
        "key": "E",
        "text": "None of these; the code does not compile."
      },
      {
        "key": "F",
        "text": "None of these; line 6 throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Given the four statements (L, M, N, O), select and order the ones that would complete the \nexpression and cause the code to output 10 lines. (Choose all that apply.)\nStream.generate(() - > \"1\")\n   L: .filter(x - > x.length()> 1)\n   M: .forEach(System.out::println)\n   N: .limit(10)\n   O: .peek(System.out::println)\n;",
    "choices": [
      {
        "key": "A",
        "text": "L, N"
      },
      {
        "key": "B",
        "text": "L, N, O"
      },
      {
        "key": "C",
        "text": "L, N, M"
      },
      {
        "key": "D",
        "text": "L, N, M, O"
      },
      {
        "key": "E",
        "text": "L, O, M"
      },
      {
        "key": "F",
        "text": "N, M"
      },
      {
        "key": "G",
        "text": "N, O\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What changes need to be made together for this code to print the string 12345? (Choose all \nthat apply.)\nStream.iterate(1, x - > x++)\n   .limit(5).map(x - > x)\n   .collect(Collectors.joining());",
    "choices": [
      {
        "key": "A",
        "text": "Change Collectors.joining() to Collectors.joining(\",\")."
      },
      {
        "key": "B",
        "text": "Change map(x - > x) to map(x - > \"\" + x)."
      },
      {
        "key": "C",
        "text": "Change x - > x++ to x - > ++x."
      },
      {
        "key": "D",
        "text": "Add .forEach(System.out::print) after the call to collect()."
      },
      {
        "key": "E",
        "text": "Wrap the entire line in a System.out.print statement."
      },
      {
        "key": "F",
        "text": "None of the above. The code already prints 12345.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Which is true of the following code?\nSet<String> birds = Set.of(\"oriole\", \"flamingo\");\nStream.concat(birds.stream(), birds.stream(), birds.stream())\n   .sorted()       // line X\n   .distinct()\n   .findAny()\n   .ifPresent(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "It is guaranteed to print flamingo as is and when line X is removed."
      },
      {
        "key": "B",
        "text": "It is guaranteed to print oriole as is and when line X is removed."
      },
      {
        "key": "C",
        "text": "It is guaranteed to print flamingo as is, but not when line X is removed."
      },
      {
        "key": "D",
        "text": "It is guaranteed to print oriole as is, but not when line X is removed."
      },
      {
        "key": "E",
        "text": "The output may vary as is."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "It throws an exception because the same list is used as the source for multiple streams.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of the following is true?\nList<Integer> x1 = List.of(1, 2, 3);\nList<Integer> x2 = List.of(4, 5, 6);\nList<Integer> x3 = List.of();\nStream.of(x1, x2, x3).map(x - > x + 1)\n   .flatMap(x - > x.stream())\n   .forEach(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles and prints 123456."
      },
      {
        "key": "B",
        "text": "The code compiles and prints 234567."
      },
      {
        "key": "C",
        "text": "The code compiles but does not print anything."
      },
      {
        "key": "D",
        "text": "The code compiles but prints stream references."
      },
      {
        "key": "E",
        "text": "The code runs infinitely."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code throws an exception.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following are true? (Choose all that apply.)\n4: Stream<Integer> s = Stream.of(1);\n5: IntStream is = s.boxed();\n6: DoubleStream ds = s.mapToDouble(x - > x);\n7: Stream<Integer> s2 = ds.mapToInt(x - > x);\n8: s2.forEach(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "Line 4 causes a compiler error."
      },
      {
        "key": "B",
        "text": "Line 5 causes a compiler error."
      },
      {
        "key": "C",
        "text": "Line 6 causes a compiler error."
      },
      {
        "key": "D",
        "text": "Line 7 causes a compiler error."
      },
      {
        "key": "E",
        "text": "Line 8 causes a compiler error."
      },
      {
        "key": "F",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "G",
        "text": "The code compiles and prints 1.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Given the generic type String, the partitioningBy() collector creates a \nMap<Boolean, List<String>> when passed to collect() by default. When a down-\nstream collector is passed to partitioningBy(), which return types can be created? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Map<boolean, List<String>>"
      },
      {
        "key": "B",
        "text": "Map<Boolean, List<String>>"
      },
      {
        "key": "C",
        "text": "Map<Boolean, Map<String>>"
      },
      {
        "key": "D",
        "text": "Map<Boolean, Set<String>>"
      },
      {
        "key": "E",
        "text": "Map<Long, TreeSet<String>>"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Which of the following statements are true about this code? (Choose all that apply.)\n20: Predicate<String> empty = String::isEmpty;\n21: Predicate<String> notEmpty = empty.negate();\n22:\n23: var result = Stream.generate(() - > \"\")\n24:    .limit(10)\n25:    .filter(notEmpty)\n26:    .collect(Collectors.groupingBy(k - > k))\n27:    .entrySet()\n28:    .stream()\n29:    .map(Entry::getValue)\n30:    .flatMap(Collection::stream)\n31:    .collect(Collectors.partitioningBy(notEmpty));\n32: System.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs {}."
      },
      {
        "key": "B",
        "text": "It outputs {false=[], true=[]}."
      },
      {
        "key": "C",
        "text": "If we changed line 31 from partitioningBy(notEmpty) to  \ngroupingBy(n - > n), it would output {}."
      },
      {
        "key": "D",
        "text": "If we changed line 31 from partitioningBy(notEmpty) to  \ngroupingBy(n - > n), it would output {false=[], true=[]}."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but does not terminate at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "What is the result of the following?\nvar s = DoubleStream.of(1.2, 2.4);\ns.peek(System.out::println).filter(x - > x> 2).count();",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "2.4"
      },
      {
        "key": "D",
        "text": "1.2 and 2.4"
      },
      {
        "key": "E",
        "text": "There is no output."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "What is the output of the following?\n11: public class Paging {\n12:    record Sesame(String name, boolean human)  {\n13:       @Override public String toString() {\n14:          return name();\n15:       }\n16:    } \n17:    record Page(List<Sesame> list, long count)  {}\n18:\n19:    public static void main(String[] args) {\n20:       var monsters = Stream.of(new Sesame(\"Elmo\", false));\n21:       var people = Stream.of(new Sesame(\"Abby\", true));\n22:       printPage(monsters, people);\n23:    }\n24:\n25:    private static void printPage(Stream<Sesame> monsters, \n26:          Stream<Sesame> people) {\n27:       Page page = Stream.concat(monsters, people)\n28:          .collect(Collectors.teeing(\n29:             Collectors.filtering(s - > s.name().startsWith(\"E\"), \n30:                Collectors.toList()),\n31:             Collectors.counting(),\n32:             (l, c) - > new Page(l, c)));\n33:       System.out.println(page);\n34:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Page[list=[Abby], count=1]"
      },
      {
        "key": "B",
        "text": "Page[list=[Abby], count=2]"
      },
      {
        "key": "C",
        "text": "Page[list=[Elmo], count=1]"
      },
      {
        "key": "D",
        "text": "Page[list=[Elmo], count=2]"
      },
      {
        "key": "E",
        "text": "The code does not compile due to Stream.concat()."
      },
      {
        "key": "F",
        "text": "The code does not compile due to Collectors.teeing()."
      },
      {
        "key": "G",
        "text": "The code does not compile for another reason.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the simplest way of rewriting this code?\nList<Integer> x = IntStream.range(1, 6)\n   .mapToObj(i - > i)\n   .collect(Collectors.toList());\nx.forEach(System.out::println);\nA. \nIntStream.range(1, 6);\nB. \nIntStream.range(1, 6)\n   .forEach(System.out::println);\nC. \n IntStream.range(1, 6)\n    .mapToObj(i - > i)\n    .forEach(System.out::println);",
    "choices": [
      {
        "key": "D",
        "text": "None of the above is equivalent."
      },
      {
        "key": "E",
        "text": "The provided code does not compile.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which of the following throw an exception when an Optional is empty? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "opt.orElse(\"\");"
      },
      {
        "key": "B",
        "text": "opt.orElseGet(() - > \"\");"
      },
      {
        "key": "C",
        "text": "opt.orElseThrow();"
      },
      {
        "key": "D",
        "text": "opt.orElseThrow(() - > throw new Exception());"
      },
      {
        "key": "E",
        "text": "opt.orElseThrow(RuntimeException::new);"
      },
      {
        "key": "F",
        "text": "opt.get();"
      },
      {
        "key": "G",
        "text": "opt.get(\"\");\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "What is the output of the following?\nvar spliterator = Stream.generate(() - > \"x\")\n   .spliterator();\n \nspliterator.tryAdvance(System.out::print);  \nvar split = spliterator.trySplit();\nsplit.tryAdvance(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "x"
      },
      {
        "key": "B",
        "text": "xx"
      },
      {
        "key": "C",
        "text": "A long list of x’s"
      },
      {
        "key": "D",
        "text": "There is no output."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but does not terminate at runtime.\nExceptions and\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which of the following can be inserted on line 8 to make this code compile? (Choose all \nthat apply.)\n    7: public void whatHappensNext() throws IOException {\n    8:    // INSERT CODE HERE\n    9: }",
    "choices": [
      {
        "key": "A",
        "text": "System.out.println(\"it's ok\");"
      },
      {
        "key": "B",
        "text": "throw new Exception();"
      },
      {
        "key": "C",
        "text": "throw new IllegalArgumentException();"
      },
      {
        "key": "D",
        "text": "throw new java.io.IOException();"
      },
      {
        "key": "E",
        "text": "throw new RuntimeException();"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which statement about the following class is correct?\n    1:  class Problem extends Exception {\n    2:     public Problem() {}\n    3:  }\n    4:  class YesProblem extends Problem {}\n    5:  public class MyDatabase {\n    6:     public static void connectToDatabase() throw Problem {\n    7:        throws new YesProblem();\n    8:     }\n    9:     public static void main(String[] c) throw Exception {\n    10:       connectToDatabase();\n    11:    }\n    12: }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles and prints a stack trace for YesProblem at runtime."
      },
      {
        "key": "B",
        "text": "The code compiles and prints a stack trace for Problem at runtime."
      },
      {
        "key": "C",
        "text": "The code does not compile because Problem defines a constructor."
      },
      {
        "key": "D",
        "text": "The code does not compile because YesProblem does not define a constructor."
      },
      {
        "key": "E",
        "text": "The code does not compile but would if Problem and YesProblem were switched on lines \n6 and 7."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following are common types to localize? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Dates"
      },
      {
        "key": "B",
        "text": "Lambda expressions"
      },
      {
        "key": "C",
        "text": "Class names"
      },
      {
        "key": "D",
        "text": "Currency"
      },
      {
        "key": "E",
        "text": "Numbers"
      },
      {
        "key": "F",
        "text": "Variable names\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "What is the output of the following snippet, assuming a and b are both 0?\n    3:  try {\n    4:     System.out.print(a / b);\n    5:  } catch (RuntimeException e) {\n    6:     System.out.print(- 1);\n    7:  } catch (ArithmeticException e) {\n    8:     System.out.print(0);\n    9:  } finally {\n    10:    System.out.print(\"done\");\n    11: }",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "done- 1"
      },
      {
        "key": "D",
        "text": "done0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Assuming the current locale uses dollars ($) and the following method is called with a double \nvalue of 100_102.2, which of the following values are printed? (Choose all that apply.)\n    public void print(double t) {\n       System.out.print(NumberFormat.getCompactNumberInstance().format(t));\n \n       System.out.print(\n          NumberFormat.getCompactNumberInstance(\n             Locale.getDefault(), Style.SHORT).format(t));\n \n       System.out.print(NumberFormat.getCurrencyInstance().format(t));\n    }",
    "choices": [
      {
        "key": "A",
        "text": "100"
      },
      {
        "key": "B",
        "text": "$100,000.00"
      },
      {
        "key": "C",
        "text": "100K"
      },
      {
        "key": "D",
        "text": "100 thousand"
      },
      {
        "key": "E",
        "text": "100M"
      },
      {
        "key": "F",
        "text": "$100,102.20"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "What is the output of the following code?\n    LocalDate date = LocalDate.parse(\"2022- 04- 30\", \n       DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    System.out.println(date.getYear() + \" \" \n       + date.getMonth() + \" \"+ date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 APRIL 2"
      },
      {
        "key": "B",
        "text": "2022 APRIL 30"
      },
      {
        "key": "C",
        "text": "2022 MAY 2"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "What does the following method print?\n    11: public void tryAgain(String s) {\n    12:    try (FileReader r = null, p = new FileReader(\"\")) {\n    13:       System.out.print(\"X\");\n    14:       throw new IllegalArgumentException();\n    15:    } catch (Exception s) {\n    16:       System.out.print(\"A\");\n    17:       throw new FileNotFoundException();\n    18:    } finally {\n    19:       System.out.print(\"O\");\n    20:    }\n    21: }",
    "choices": [
      {
        "key": "A",
        "text": "XAO"
      },
      {
        "key": "B",
        "text": "XOA"
      },
      {
        "key": "C",
        "text": "One line of this method contains a compiler error."
      },
      {
        "key": "D",
        "text": "Two lines of this method contain compiler errors."
      },
      {
        "key": "E",
        "text": "Three or more lines of this method contain compiler errors."
      },
      {
        "key": "F",
        "text": "The code compiles, but a NullPointerException is thrown at runtime."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Assume that all of the files mentioned in the answer choices exist and define the same keys. \nWhich one will be used to find the key in line 8?\n    6: Locale.setDefault(new Locale(\"en\", \"US\"));\n    7: var b = ResourceBundle.getBundle(\"Dolphins\");\n    8: System.out.println(b.getString(\"name\"));",
    "choices": [
      {
        "key": "A",
        "text": "Dolphins.properties"
      },
      {
        "key": "B",
        "text": "Dolphins_US.properties"
      },
      {
        "key": "C",
        "text": "Dolphins_en.properties"
      },
      {
        "key": "D",
        "text": "Whales.properties"
      },
      {
        "key": "E",
        "text": "Whales_en_US.properties"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "For what value of pattern will the following print <005.21> <008.49> <1,234.0>?\n    String pattern = \"                 \";\n    var message = DoubleStream.of(5.21, 8.49, 1234)\n       .mapToObj(v - > new DecimalFormat(pattern).format(v))\n       .collect(Collectors.joining(\"> <\"));\n    System.out.println(\"<\"+message+\">\");",
    "choices": [
      {
        "key": "A",
        "text": "##.#"
      },
      {
        "key": "B",
        "text": "0,000.0#"
      },
      {
        "key": "C",
        "text": "#,###.0"
      },
      {
        "key": "D",
        "text": "#,###,000.0#"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which scenario is the best use of an exception?",
    "choices": [
      {
        "key": "A",
        "text": "An element is not found when searching a list."
      },
      {
        "key": "B",
        "text": "An unexpected parameter is passed into a method."
      },
      {
        "key": "C",
        "text": "The computer caught fire."
      },
      {
        "key": "D",
        "text": "You want to loop through a list."
      },
      {
        "key": "E",
        "text": "You don’t know how to code a method.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Which of the following exceptions must be handled or declared in the method in which they \nare thrown? (Choose all that apply.)\n    class Apple extends RuntimeException {}\n    class Orange extends Exception {}\n    class Banana extends Error {}\n    class Pear extends Apple {}\n    class Tomato extends Orange {}\n    class Peach extends Throwable {}",
    "choices": [
      {
        "key": "A",
        "text": "Apple"
      },
      {
        "key": "B",
        "text": "Orange"
      },
      {
        "key": "C",
        "text": "Banana"
      },
      {
        "key": "D",
        "text": "Pear"
      },
      {
        "key": "E",
        "text": "Tomato"
      },
      {
        "key": "F",
        "text": "Peach\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Which of the following changes, when made independently, would make this code compile? \n(Choose all that apply.)\n    1:  import java.io.*; \n    2:  public class StuckTurkeyCage implements AutoCloseable {\n    3:     public void close() throws IOException {\n    4:        throw new FileNotFoundException(\"Cage not closed\");\n    5:     }\n    6:     public static void main(String[] args) {\n    7:        try (StuckTurkeyCage t = new StuckTurkeyCage()) {\n    8:           System.out.println(\"put turkeys in\");\n    9:        }\n    10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Remove throws IOException from the declaration on line 3."
      },
      {
        "key": "B",
        "text": "Add throws Exception to the declaration on line 6."
      },
      {
        "key": "C",
        "text": "Change line 9 to } catch (Exception e) {}."
      },
      {
        "key": "D",
        "text": "Change line 9 to } finally {}."
      },
      {
        "key": "E",
        "text": "The code compiles as is."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of the following are true statements about exception handling in Java? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A traditional try statement without a catch block requires a finally block."
      },
      {
        "key": "B",
        "text": "A traditional try statement without a finally block requires a catch block."
      },
      {
        "key": "C",
        "text": "A traditional try statement with only one statement can omit the {}."
      },
      {
        "key": "D",
        "text": "A try- with- resources statement without a catch block requires a finally block."
      },
      {
        "key": "E",
        "text": "A try- with- resources statement without a finally block requires a catch block."
      },
      {
        "key": "F",
        "text": "A try- with- resources statement with only one statement can omit the {}.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Assuming -g:vars is used when the code is compiled to include debug information, what is \nthe output of the following code snippet?\n    var huey = (String)null;\n    Integer dewey = null;\n    Object louie = null;\n    if(louie == huey.substring(dewey.intValue())) {\n       System.out.println(\"Quack!\");\n    }",
    "choices": [
      {
        "key": "A",
        "text": "A NullPointerException that does not include any variable names in the stack \ntrace"
      },
      {
        "key": "B",
        "text": "A NullPointerException naming huey in the stack trace"
      },
      {
        "key": "C",
        "text": "A NullPointerException naming dewey in the stack trace"
      },
      {
        "key": "D",
        "text": "A NullPointerException naming louie in the stack trace"
      },
      {
        "key": "E",
        "text": "A NullPointerException naming huey and louie in the stack trace"
      },
      {
        "key": "F",
        "text": "A NullPointerException naming huey and dewey in the stack trace"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which of the following, when inserted independently in the blank, use locale parameters that \nare properly formatted? (Choose all that apply.)\n    import java.util.Locale;\n    public class ReadMap implements AutoCloseable {\n       private Locale locale;\n       private boolean closed = false;\n       @Override public void close() {\n          System.out.println(\"Folding map\");\n          locale = null;\n          closed = true;\n       }\n       public void open() {\n          this.locale =                  ;\n       }\n       public void use() {\n          // Implementation omitted\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "new Locale(\"xM\")"
      },
      {
        "key": "B",
        "text": "new Locale(\"MQ\", \"ks\")"
      },
      {
        "key": "C",
        "text": "new Locale(\"qw\")"
      },
      {
        "key": "D",
        "text": "new Locale(\"wp\", \"VW\")"
      },
      {
        "key": "E",
        "text": "Locale.create(\"zp\")"
      },
      {
        "key": "F",
        "text": "new Locale.Builder().setLanguage(\"yw\").setRegion(\"PM\")"
      },
      {
        "key": "G",
        "text": "The code does not compile regardless of what is placed in the blank.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Which of the following can be inserted into the blank to allow the code to compile and run \nwithout throwing an exception? (Choose all that apply.)\n    var f = DateTimeFormatter.ofPattern(\"hh o'clock\");\n    System.out.println(f.format(                 .now()));",
    "choices": [
      {
        "key": "A",
        "text": "ZonedDateTime"
      },
      {
        "key": "B",
        "text": "LocalDate"
      },
      {
        "key": "C",
        "text": "LocalDateTime"
      },
      {
        "key": "D",
        "text": "LocalTime"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which of the following statements about resource bundles are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "All keys must be in the same resource bundle to be used."
      },
      {
        "key": "B",
        "text": "A resource bundle is loaded by calling the new ResourceBundle() constructor."
      },
      {
        "key": "C",
        "text": "Resource bundle values are always read using the Properties class."
      },
      {
        "key": "D",
        "text": "Changing the default locale lasts for only a single run of the program."
      },
      {
        "key": "E",
        "text": "If a resource bundle for a specific locale is requested, then the resource bundle for the \ndefault locale will not be used."
      },
      {
        "key": "F",
        "text": "It is possible to use a resource bundle for a locale without specifying a default locale.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "What is the output of the following code?\n    import java.io.*;\n    public class FamilyCar {\n       static class Door implements AutoCloseable {\n          public void close() {\n             System.out.print(\"D\");\n       } }\n       static class Window implements Closeable {\n          public void close() {\n             System.out.print(\"W\");\n             throw new RuntimeException();\n       } }\n       public static void main(String[] args) {\n          var d = new Door();\n          try (d; var w = new Window()) {\n             System.out.print(\"T\");\n          } catch (Exception e) {\n             System.out.print(\"E\");\n          } finally {\n             System.out.print(\"F\");\n          } } }",
    "choices": [
      {
        "key": "A",
        "text": "TWF"
      },
      {
        "key": "B",
        "text": "TWDF"
      },
      {
        "key": "C",
        "text": "TWDEF"
      },
      {
        "key": "D",
        "text": "TWF followed by an exception"
      },
      {
        "key": "E",
        "text": "TWDF followed by an exception"
      },
      {
        "key": "F",
        "text": "TWEF followed by an exception"
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Suppose that we have the following three properties files and code. Which bundles are used \non lines 8 and 9, respectively?\n    Dolphins.properties\n    name=The Dolphin\n    age=0\n \n    Dolphins_en.properties\n    name=Dolly\n    age=4\n \n    Dolphins_fr.properties\n    name=Dolly\n \n    5: var fr = new Locale(\"fr\");\n    6: Locale.setDefault(new Locale(\"en\", \"US\"));\n    7: var b = ResourceBundle.getBundle(\"Dolphins\", fr);\n    8: b.getString(\"name\");\n    9: b.getString(\"age\");",
    "choices": [
      {
        "key": "A",
        "text": "Dolphins.properties and Dolphins.properties"
      },
      {
        "key": "B",
        "text": "Dolphins.properties and Dolphins_en.properties"
      },
      {
        "key": "C",
        "text": "Dolphins_en.properties and Dolphins_en.properties"
      },
      {
        "key": "D",
        "text": "Dolphins_fr.properties and Dolphins.properties"
      },
      {
        "key": "E",
        "text": "Dolphins_fr.properties and Dolphins_en.properties"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "What is printed by the following program?\n    1:  public class DriveBus {\n    2:     public void go() {\n    3:        System.out.print(\"A\");\n    4:        try {\n    5:           stop();\n    6:        } catch (ArithmeticException e) {\n    7:           System.out.print(\"B\");\n    8:        } finally {\n    9:           System.out.print(\"C\");\n    10:       }\n    11:       System.out.print(\"D\");\n    12:    }\n    13:    public void stop() {\n    14:       System.out.print(\"E\");\n    15:       Object x = null;\n    16:       x.toString();\n    17:       System.out.print(\"F\");\n    18:    }\n    19:    public static void main(String n[]) {\n    20:       new DriveBus().go();\n    21:    } }",
    "choices": [
      {
        "key": "A",
        "text": "AE"
      },
      {
        "key": "B",
        "text": "AEBCD"
      },
      {
        "key": "C",
        "text": "AEC"
      },
      {
        "key": "D",
        "text": "AECD"
      },
      {
        "key": "E",
        "text": "AE followed by a stack trace"
      },
      {
        "key": "F",
        "text": "AEBCD followed by a stack trace"
      },
      {
        "key": "G",
        "text": "AEC followed by a stack trace"
      },
      {
        "key": "H",
        "text": "A stack trace with no other output\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Which changes, when made independently, allow the following program to compile? (Choose \nall that apply.)\n    1: public class AhChoo {\n    2:    static class SneezeException extends Exception {}\n    3:    static class SniffleException extends SneezeException {}\n    4:    public static void main(String[] args) {\n    5:       try {\n    6:          throw new SneezeException();\n    7:       } catch (SneezeException | SniffleException e) {\n    8:       } finally {}\n    9:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Add throws SneezeException to the declaration on line 4."
      },
      {
        "key": "B",
        "text": "Add throws Throwable to the declaration on line 4."
      },
      {
        "key": "C",
        "text": "Change line 7 to } catch (SneezeException e) {."
      },
      {
        "key": "D",
        "text": "Change line 7 to } catch (SniffleException e) {."
      },
      {
        "key": "E",
        "text": "Remove line 7."
      },
      {
        "key": "F",
        "text": "The code compiles correctly as is."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "What is the output of the following code?\n    try {\n       LocalDateTime book = LocalDateTime.of(2022, 4, 5, 12, 30, 20);\n       System.out.print(book.format(DateTimeFormatter.ofPattern(\"m\")));\n       System.out.print(book.format(DateTimeFormatter.ofPattern(\"z\")));\n       System.out.print(DateTimeFormatter.ofPattern(\"y\").format(book));\n    } catch (Throwable e) {}",
    "choices": [
      {
        "key": "A",
        "text": "4"
      },
      {
        "key": "B",
        "text": "30"
      },
      {
        "key": "C",
        "text": "402"
      },
      {
        "key": "D",
        "text": "3002"
      },
      {
        "key": "E",
        "text": "3002022"
      },
      {
        "key": "F",
        "text": "402022"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "Fill in the blank: A class that implements _________________ may be in a try- with- resources \nstatement. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "AutoCloseable"
      },
      {
        "key": "B",
        "text": "Resource"
      },
      {
        "key": "C",
        "text": "Exception"
      },
      {
        "key": "D",
        "text": "AutomaticResource"
      },
      {
        "key": "E",
        "text": "Closeable"
      },
      {
        "key": "F",
        "text": "RuntimeException"
      },
      {
        "key": "G",
        "text": "Serializable\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "What is the output of the following program?\n    public class SnowStorm {\n       static class WalkToSchool implements AutoCloseable {\n          public void close() {\n             throw new RuntimeException(\"flurry\");\n          } }\n       public static void main(String[] args) {\n          WalkToSchool walk1 = new WalkToSchool();\n          try (walk1; WalkToSchool walk2 = new WalkToSchool()) {\n             throw new RuntimeException(\"blizzard\");\n          } catch(Exception e) {\n             System.out.println(e.getMessage()\n                + \" \" + e.getSuppressed().length);\n          }\n          walk1 = null;\n       } }",
    "choices": [
      {
        "key": "A",
        "text": "blizzard 0"
      },
      {
        "key": "B",
        "text": "blizzard 1"
      },
      {
        "key": "C",
        "text": "blizzard 2"
      },
      {
        "key": "D",
        "text": "flurry 0"
      },
      {
        "key": "E",
        "text": "flurry 1"
      },
      {
        "key": "F",
        "text": "flurry 2"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "Assuming U.S. currency is in dollars ($) and German currency is in euros (€), what is the \noutput of the following program?\n    import java.text.NumberFormat;\n    import java.util.Locale;\n    import java.util.Locale.Category;\n    public record Wallet(double money) {\n       private String openWallet() {\n          Locale.setDefault(Category.DISPLAY,\n             new Locale.Builder().setRegion(\"us\").build());\n          Locale.setDefault(Category.FORMAT,\n             new Locale.Builder().setLanguage(\"en\").build());\n          return NumberFormat.getCurrencyInstance(Locale.GERMANY)\n             .format(money);\n       }\n       public void printBalance() {\n          System.out.println(openWallet());\n       }   \n       public static void main(String... unused) {\n          new Wallet(2.4).printBalance();\n       } }",
    "choices": [
      {
        "key": "A",
        "text": "2,40 €"
      },
      {
        "key": "B",
        "text": "$2.40"
      },
      {
        "key": "C",
        "text": "2.4"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "Which lines can fill in the blank to make the following code compile? (Choose all that apply.)\n    void rollOut() throws ClassCastException {}\n \n    public void transform(String c) {\n       try {\n          rollOut();\n       } catch (IllegalArgumentException | ) {\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "IOException a"
      },
      {
        "key": "B",
        "text": "Error b"
      },
      {
        "key": "C",
        "text": "NullPointerException c"
      },
      {
        "key": "D",
        "text": "RuntimeException d"
      },
      {
        "key": "E",
        "text": "NumberFormatException e"
      },
      {
        "key": "F",
        "text": "ClassCastException f"
      },
      {
        "key": "G",
        "text": "None of the above. The code contains a compiler error regardless of what is inserted \ninto the blank.\n\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The try block is not capable of throwing an IOException, making the catch block \nunreachable code and option A incorrect. Options B and F are correct, as both are unchecked \nexceptions that do not extend or inherit from IllegalArgumentException. Remember, \nit is not a good idea to catch Error in practice, although because it is possible, it may come \nup on the exam. Option C is incorrect because the variable c is declared already in the \nmethod declaration. Option D is incorrect because the IllegalArgumentException\ninherits from RuntimeException, making the first declaration unnecessary. \nSimilarly, option E is incorrect because NumberFormatException inherits from \nIllegalArgumentException, making the second declaration unnecessary. Since options \nB and F are correct, option G is incorrect.\nChapter 12: Modules 949\nChapter 12: Modules\n"
  },
  {
    "question": "Which statement is true of the following module?\n    |- - - zoo\n       |- -  staff\n          |- -  Vet.java",
    "choices": [
      {
        "key": "A",
        "text": "The directory structure shown is a valid module."
      },
      {
        "key": "B",
        "text": "The directory structure would be a valid module if module.java were added directly \nunderneath zoo/staff."
      },
      {
        "key": "C",
        "text": "The directory structure would be a valid module if module.java were added directly \nunderneath zoo."
      },
      {
        "key": "D",
        "text": "The directory structure would be a valid module if module- info.java were added \ndirectly underneath zoo/staff."
      },
      {
        "key": "E",
        "text": "The directory structure would be a valid module if module- info.java were added \ndirectly underneath zoo."
      },
      {
        "key": "F",
        "text": "None of these changes would make this directory structure a valid module.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Suppose module puppy depends on module dog and module dog depends on module \nanimal. Fill in the blank so that code in module dog can access the animal.behavior \npackage in module animal.\n    module animal {\n                animal.behavior;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "export"
      },
      {
        "key": "B",
        "text": "exports"
      },
      {
        "key": "C",
        "text": "require"
      },
      {
        "key": "D",
        "text": "requires"
      },
      {
        "key": "E",
        "text": "require transitive"
      },
      {
        "key": "F",
        "text": "requires transitive"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Fill in the blanks so this command to run the program is correct:\n    java\n            zoo.animal.talks/zoo/animal/talks/Peacocks\n            modules",
    "choices": [
      {
        "key": "A",
        "text": "- d and - m"
      },
      {
        "key": "B",
        "text": "- d and –p"
      },
      {
        "key": "C",
        "text": "- m and - d"
      },
      {
        "key": "D",
        "text": "- m and - p"
      },
      {
        "key": "E",
        "text": "- p and - d"
      },
      {
        "key": "F",
        "text": "- p and - m"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which of the following pairs make up a service?",
    "choices": [
      {
        "key": "A",
        "text": "Consumer and service locator"
      },
      {
        "key": "B",
        "text": "Consumer and service provider interface"
      },
      {
        "key": "C",
        "text": "Service locator and service provider"
      },
      {
        "key": "D",
        "text": "Service locator and service provider interface"
      },
      {
        "key": "E",
        "text": "Service provider and service provider interface\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "A(n) _______________ module is on the classpath while a(n) ____________ module is on the \nmodule path. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "automatic, named"
      },
      {
        "key": "B",
        "text": "automatic, unnamed"
      },
      {
        "key": "C",
        "text": "named, automatic"
      },
      {
        "key": "D",
        "text": "named, unnamed"
      },
      {
        "key": "E",
        "text": "unnamed, automatic"
      },
      {
        "key": "F",
        "text": "unnamed, named"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which of the following statements are true in a module- info.java file? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The opens directive allows the use of reflection."
      },
      {
        "key": "B",
        "text": "The opens directive declares that an API is called."
      },
      {
        "key": "C",
        "text": "The use directive allows the use of reflection."
      },
      {
        "key": "D",
        "text": "The use directive declares that an API is called."
      },
      {
        "key": "E",
        "text": "The uses directive allows the use of reflection."
      },
      {
        "key": "F",
        "text": "The uses directive declares that an API is called.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "An automatic module name is generated if one is not supplied. Which of the following JAR \nfilenames and generated automatic module name pairs are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "emily- 1.0.0.jar and emily"
      },
      {
        "key": "B",
        "text": "emily- 1.0.0- SNAPSHOT.jar and emily"
      },
      {
        "key": "C",
        "text": "emily_the_cat- 1.0.0.jar and emily_the_cat"
      },
      {
        "key": "D",
        "text": "emily_the_cat- 1.0.0.jar and emily- the- cat"
      },
      {
        "key": "E",
        "text": "emily.$.jar and emily"
      },
      {
        "key": "F",
        "text": "emily.$.jar and emily."
      },
      {
        "key": "G",
        "text": "emily.$.jar and emily..\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Modules with cyclic dependencies will not compile."
      },
      {
        "key": "B",
        "text": "Packages with a cyclic dependency will not compile."
      },
      {
        "key": "C",
        "text": "A cyclic dependency always involves exactly two modules."
      },
      {
        "key": "D",
        "text": "A cyclic dependency always involves at least two requires statements."
      },
      {
        "key": "E",
        "text": "An unnamed module can be involved in a cyclic dependency with an automatic module.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Suppose you are creating a service provider that contains the following class. Which line of \ncode needs to be in your module- info.java?\n    package dragon;\n    import magic.*;\n     public class Dragon implements Magic {\n       public String getPower() {\n         return \"breathe fire\";\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "provides dragon.Dragon by magic.Magic;"
      },
      {
        "key": "B",
        "text": "provides dragon.Dragon using magic.Magic;"
      },
      {
        "key": "C",
        "text": "provides dragon.Dragon with magic.Magic;"
      },
      {
        "key": "D",
        "text": "provides magic.Magic by dragon.Dragon;"
      },
      {
        "key": "E",
        "text": "provides magic.Magic using dragon.Dragon;"
      },
      {
        "key": "F",
        "text": "provides magic.Magic with dragon.Dragon;\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "What is true of a module containing a file named module- info.java with the following \ncontents? (Choose all that apply.)\n    module com.food.supplier {}",
    "choices": [
      {
        "key": "A",
        "text": "All packages inside the module are automatically exported."
      },
      {
        "key": "B",
        "text": "No packages inside the module are automatically exported."
      },
      {
        "key": "C",
        "text": "A main method inside the module can be run."
      },
      {
        "key": "D",
        "text": "A main method inside the module cannot be run since the class is not exposed."
      },
      {
        "key": "E",
        "text": "The module- info.java file contains a compiler error."
      },
      {
        "key": "F",
        "text": "The module- info.java filename is incorrect.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Suppose module puppy depends on module dog and module dog depends on module \nanimal. Which lines allow module puppy to access the animal.behavior package in \nmodule animal? (Choose all that apply.)\n    module animal {\n       exports animal.behavior;\n    }\n    module dog {\n               animal;  // line S\n    }\n    module puppy {\n               dog;     // line T\n    }",
    "choices": [
      {
        "key": "A",
        "text": "require on line S"
      },
      {
        "key": "B",
        "text": "require on line T"
      },
      {
        "key": "C",
        "text": "requires on line S"
      },
      {
        "key": "D",
        "text": "requires on line T"
      },
      {
        "key": "E",
        "text": "require transitive on line S"
      },
      {
        "key": "F",
        "text": "require transitive on line T"
      },
      {
        "key": "G",
        "text": "requires transitive on line S"
      },
      {
        "key": "H",
        "text": "requires transitive on line T\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Which of the following modules are provided by the JDK? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "java.base"
      },
      {
        "key": "B",
        "text": "java.desktop"
      },
      {
        "key": "C",
        "text": "java.logging"
      },
      {
        "key": "D",
        "text": "java.util"
      },
      {
        "key": "E",
        "text": "jdk.base"
      },
      {
        "key": "F",
        "text": "jdk.compiler"
      },
      {
        "key": "G",
        "text": "jdk.xerces\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of the following compiles and is equivalent to this loop?\n    List<Unicorn> all  = new ArrayList<>();\n    for (Unicorn current : ServiceLoader.load(Unicorn.class))\n       all.add(current);\nA. \n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .getStream()\n    .collect(Collectors.toList());\nB. \n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .stream()\n    .collect(Collectors.toList());\nC. \n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .getStream()\n    .map(Provider::get)\n    .collect(Collectors.toList());\nD. \n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .stream()\n    .map(Provider::get)\n    .collect(Collectors.toList());",
    "choices": [
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Which of the following are legal commands to run a modular program where n is the module \nname and c is the fully qualified class name? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "java --module- path x - m n.c"
      },
      {
        "key": "B",
        "text": "java - - module- path x - p n.c"
      },
      {
        "key": "C",
        "text": "java - - module- path x- x - m n/c"
      },
      {
        "key": "D",
        "text": "java - - module- path x - p n/c"
      },
      {
        "key": "E",
        "text": "java - - module- path x- x - m n- c"
      },
      {
        "key": "F",
        "text": "java - - module- path x - p n- c"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "For a top- down migration, all modules other than named modules are _____________  \nmodules and are on the ____________.",
    "choices": [
      {
        "key": "A",
        "text": "automatic, classpath"
      },
      {
        "key": "B",
        "text": "automatic, module path"
      },
      {
        "key": "C",
        "text": "unnamed, classpath"
      },
      {
        "key": "D",
        "text": "unnamed, module path"
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Suppose you have separate modules for a service provider interface, service provider, service \nlocator, and consumer. If you add a second service provider module, how many of these mod-\nules do you need to recompile?",
    "choices": [
      {
        "key": "A",
        "text": "Zero"
      },
      {
        "key": "B",
        "text": "One"
      },
      {
        "key": "C",
        "text": "Two"
      },
      {
        "key": "D",
        "text": "Three"
      },
      {
        "key": "E",
        "text": "Four\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Suppose we have a JAR file named cat- 1.2.3- RC1.jar, and  \nAutomatic- Module- Name in the MANIFEST.MF is set to dog. What should an unnamed \nmodule referencing this automatic module include in module- info.java?",
    "choices": [
      {
        "key": "A",
        "text": "requires cat;"
      },
      {
        "key": "B",
        "text": "requires cat.RC;"
      },
      {
        "key": "C",
        "text": "requires cat- RC;"
      },
      {
        "key": "D",
        "text": "requires dog;"
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which commands are used to create a smaller Java image and work with native code, \nrespectively?",
    "choices": [
      {
        "key": "A",
        "text": "jimage and jlink"
      },
      {
        "key": "B",
        "text": "jimage and jmod"
      },
      {
        "key": "C",
        "text": "jlink and jimage"
      },
      {
        "key": "D",
        "text": "jlink and jmod"
      },
      {
        "key": "E",
        "text": "jmod and jimage"
      },
      {
        "key": "F",
        "text": "jmod and jmod\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which are true statements about the following module? (Choose all that apply.)\n    class dragon {\n       exports com.dragon.fire;\n       exports com.dragon.scales to castle;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "All modules can reference the com.dragon.fire package."
      },
      {
        "key": "B",
        "text": "All modules can reference the com.dragon.scales package."
      },
      {
        "key": "C",
        "text": "Only the castle module can reference the com.dragon.fire package."
      },
      {
        "key": "D",
        "text": "Only the castle module can reference the com.dragon.scales package."
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which would you expect to see when describing any module?",
    "choices": [
      {
        "key": "A",
        "text": "requires java.base mandated"
      },
      {
        "key": "B",
        "text": "requires java.core mandated"
      },
      {
        "key": "C",
        "text": "requires java.lang mandated"
      },
      {
        "key": "D",
        "text": "requires mandated java.base"
      },
      {
        "key": "E",
        "text": "requires mandated java.core"
      },
      {
        "key": "F",
        "text": "requires mandated java.lang"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Suppose you have separate modules for a service provider interface, service provider, ser -\nvice locator, and consumer. Which module(s) need to specify a requires directive on the ser -\nvice provider?",
    "choices": [
      {
        "key": "A",
        "text": "Service locator"
      },
      {
        "key": "B",
        "text": "Service provider interface"
      },
      {
        "key": "C",
        "text": "Consumer"
      },
      {
        "key": "D",
        "text": "Consumer and service locator"
      },
      {
        "key": "E",
        "text": "Consumer and service provider"
      },
      {
        "key": "F",
        "text": "Service locator and service provider interface"
      },
      {
        "key": "G",
        "text": "Consumer, service locator, and service provider interface"
      },
      {
        "key": "H",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which are true statements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An automatic module exports all packages to named modules."
      },
      {
        "key": "B",
        "text": "An automatic module exports only the specified packages to named modules."
      },
      {
        "key": "C",
        "text": "An automatic module exports no packages to named modules."
      },
      {
        "key": "D",
        "text": "An unnamed module exports only the named packages to named modules."
      },
      {
        "key": "E",
        "text": "An unnamed module exports all packages to named modules."
      },
      {
        "key": "F",
        "text": "An unnamed module exports no packages to named modules.\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "Which is the first line to contain a compiler error?\n    1: module snake {\n    2:    exports com.snake.tail;\n    3:    exports com.snake.fangs to bird;\n    4:    requires skin;\n    5:    requires transitive skin;\n    6: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 1"
      },
      {
        "key": "B",
        "text": "Line 2"
      },
      {
        "key": "C",
        "text": "Line 3"
      },
      {
        "key": "D",
        "text": "Line 4"
      },
      {
        "key": "E",
        "text": "Line 5"
      },
      {
        "key": "F",
        "text": "The code does not contain any compiler errors.\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "Which are true statements about a package in a JAR on the classpath containing a  \nmodule- info.java file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "It is possible to make the package available to all other modules on the classpath."
      },
      {
        "key": "B",
        "text": "It is possible to make the package available to all other modules on the module path."
      },
      {
        "key": "C",
        "text": "It is possible to make the package available to exactly one other specific module on the \nclasspath."
      },
      {
        "key": "D",
        "text": "It is possible to make the package available to exactly one other specific module on the \nmodule path."
      },
      {
        "key": "E",
        "text": "It is possible to make sure the package is not available to any other modules on the \nclasspath.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "Suppose you have separate modules for a service provider interface, service provider, service \nlocator, and consumer. Which statements are true about the directives you need to specify? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The consumer must use the requires directive."
      },
      {
        "key": "B",
        "text": "The consumer must use the uses directive."
      },
      {
        "key": "C",
        "text": "The service locator must use the requires directive."
      },
      {
        "key": "D",
        "text": "The service locator must use the uses directive."
      },
      {
        "key": "E",
        "text": "None of the above\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "Given the following code snippet, which options correctly create a parallel stream? (Choose \nall that apply.)\nvar c = new ArrayList<Thread>();\nvar s = c.stream();\nvar p =                ;",
    "choices": [
      {
        "key": "A",
        "text": "new ParallelStream(s)"
      },
      {
        "key": "B",
        "text": "c.parallel()"
      },
      {
        "key": "C",
        "text": "s.parallelStream()"
      },
      {
        "key": "D",
        "text": "c.parallelStream()"
      },
      {
        "key": "E",
        "text": "new ParallelStream(c)"
      },
      {
        "key": "F",
        "text": "s.parallel()\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Given that the sum of the numbers from 1 (inclusive) to 10 (exclusive) is 45, what are the \npossible results of executing the following program? (Choose all that apply.)\n1:  import java.util.concurrent.locks.*;\n2:  import java.util.stream.*;\n3:  public class Bank {\n4:     private Lock vault = new ReentrantLock();\n5:     private int total = 0;\n6:     public void deposit(int value) {\n7:        try {\n8:           vault.tryLock();\n9:           total += value;\n10:       } finally { vault.unlock(); }\n11:    }\n12:    public static void main(String[] unused) {\n13:       var bank = new Bank();\n14:       IntStream.range(1, 10).parallel()\n15:          .forEach(s - > bank.deposit(s));\n16:       System.out.println(bank.total);\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "45 is printed."
      },
      {
        "key": "B",
        "text": "A number less than 45 is printed."
      },
      {
        "key": "C",
        "text": "A number greater than 45 is printed."
      },
      {
        "key": "D",
        "text": "An exception is thrown."
      },
      {
        "key": "E",
        "text": "None of the above, as the code does not compile.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the following statements about the Callable call() and Runnable run() \nmethods are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Both methods return void."
      },
      {
        "key": "B",
        "text": "Both can throw unchecked exceptions."
      },
      {
        "key": "C",
        "text": "Both can be implemented with lambda expressions."
      },
      {
        "key": "D",
        "text": "Runnable returns a generic type."
      },
      {
        "key": "E",
        "text": "Both can throw checked exceptions."
      },
      {
        "key": "F",
        "text": "Callable returns a generic type.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Which lines need to be changed to make the code compile? (Choose all that apply.)\nExecutorService service =   // w1\n   Executors.newSingleThreadScheduledExecutor();\nservice.scheduleWithFixedDelay(() - > {\n   System.out.println(\"Open Zoo\");\n   return null;   // w2\n}, 0, 1, TimeUnit.MINUTES);\nvar result = service.submit(() - >   // w3\n   System.out.println(\"Wake Staff\"));\nSystem.out.println(result.get());   // w4",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "Line w1"
      },
      {
        "key": "C",
        "text": "Line w2"
      },
      {
        "key": "D",
        "text": "Line w3"
      },
      {
        "key": "E",
        "text": "Line w4"
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "What statement about the following code is true?\nvar value1 = new AtomicLong(0);\nfinal long[] value2 = {0};\nIntStream.iterate(1, i - > 1).limit(100).parallel()\n   .forEach(i - > value1.incrementAndGet());\nIntStream.iterate(1, i - > 1).limit(100).parallel()\n   .forEach(i - > ++value2[0]);\nSystem.out.println(value1+\" \"+value2[0]);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 100 100."
      },
      {
        "key": "B",
        "text": "It outputs 100 99."
      },
      {
        "key": "C",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "It compiles but enters an infinite loop at runtime."
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Which statements about the following code are correct? (Choose all that apply.)\nvar data = List.of(2,5,1,9,8);\ndata.stream().parallel()\n   .mapToInt(s - > s)\n   .peek(System.out::print)\n   .forEachOrdered(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "The peek() method will print the entries in the sorted order: 12589."
      },
      {
        "key": "B",
        "text": "The peek() method will print the entries in the original order: 25198."
      },
      {
        "key": "C",
        "text": "The peek() method will print the entries in an order that cannot be determined ahead \nof time."
      },
      {
        "key": "D",
        "text": "The forEachOrdered() method will print the entries in the sorted order: 12589."
      },
      {
        "key": "E",
        "text": "The forEachOrdered() method will print the entries in the original order: 25198."
      },
      {
        "key": "F",
        "text": "The forEachOrdered() method will print the entries in an order that cannot be \ndetermined ahead of time."
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Fill in the blanks: __________ occur(s) when two or more threads are blocked forever but \nboth appear active. _______ occur(s) when two or more threads try to complete a related task \nat the same time, resulting in invalid or unexpected data.",
    "choices": [
      {
        "key": "A",
        "text": "Livelock, Deadlock"
      },
      {
        "key": "B",
        "text": "Deadlock, Starvation"
      },
      {
        "key": "C",
        "text": "Race conditions, Deadlock"
      },
      {
        "key": "D",
        "text": "Livelock, Race conditions"
      },
      {
        "key": "E",
        "text": "Starvation, Race conditions"
      },
      {
        "key": "F",
        "text": "Deadlock, Livelock\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Assuming this class is accessed by only a single thread at a time, what is the result of calling \nthe countIceCreamFlavors() method?\nimport java.util.stream.LongStream;\npublic class Flavors {\n   private static int counter;\n   public static void countIceCreamFlavors()  {\n      counter = 0;\n      Runnable task = () - > counter++;\n      LongStream.range(0, 500)\n         .forEach(m - > new Thread(task).run());\n      System.out.println(counter);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "The method consistently prints a number less than 500."
      },
      {
        "key": "B",
        "text": "The method consistently prints 500."
      },
      {
        "key": "C",
        "text": "The method compiles and prints a value, but that value cannot be determined ahead of \ntime."
      },
      {
        "key": "D",
        "text": "The method does not compile."
      },
      {
        "key": "E",
        "text": "The method compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Which happens when a new task is submitted to an ExecutorService  in which no threads are \navailable?",
    "choices": [
      {
        "key": "A",
        "text": "The executor throws an exception when the task is submitted."
      },
      {
        "key": "B",
        "text": "The executor discards the task without completing it."
      },
      {
        "key": "C",
        "text": "The executor adds the task to an internal queue and completes when there is an avail-\nable thread."
      },
      {
        "key": "D",
        "text": "The thread submitting the task waits on the submit call until a thread is available before \ncontinuing."
      },
      {
        "key": "E",
        "text": "The executor stops an existing task and starts the newly submitted one.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "What is the result of executing the following code snippet?\nList<Integer> lions = new ArrayList<>(List.of(1,2,3));\nList<Integer> tigers = new CopyOnWriteArrayList<>(lions);\nSet<Integer> bears = new ConcurrentSkipListSet<>();\nbears.addAll(lions);\nfor(Integer item: tigers) tigers.add(4); // x1\nfor(Integer item: bears) bears.add(5);   // x2\nSystem.out.println(lions.size() + \" \" + tigers.size()\n   + \" \" + bears.size());",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 3 6 4."
      },
      {
        "key": "B",
        "text": "It outputs 6 6 6."
      },
      {
        "key": "C",
        "text": "It outputs 6 3 4."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime on line x1."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime on line x2."
      },
      {
        "key": "G",
        "text": "It compiles but enters an infinite loop at runtime.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "What statements about the following code are true? (Choose all that apply.)\nInteger i1 = List.of(1, 2, 3, 4, 5).stream().findAny().get();\nsynchronized(i1) { // y1\n   Integer i2 = List.of(6, 7, 8, 9, 10)\n      .parallelStream()\n      .sorted()\n      .findAny().get(); // y2\n   System.out.println(i1 + \" \" + i2);\n}",
    "choices": [
      {
        "key": "A",
        "text": "The first value printed is always 1."
      },
      {
        "key": "B",
        "text": "The second value printed is always 6."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line y1."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line y2."
      },
      {
        "key": "E",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "G",
        "text": "It compiles but waits forever at runtime.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Assuming each call to takeNap() takes five seconds to execute without throwing an exception, \nwhat is the expected result of executing the following code snippet?\nExecutorService service = Executors.newFixedThreadPool(4);\ntry {\n   service.execute(() - > takeNap());\n   service.execute(() - > takeNap());\n   service.execute(() - > takeNap());\n} finally {\n   service.shutdown();\n}\nservice.awaitTermination(2, TimeUnit.SECONDS);\nSystem.out.println(\"DONE!\");",
    "choices": [
      {
        "key": "A",
        "text": "It will immediately print DONE!."
      },
      {
        "key": "B",
        "text": "It will pause for 2 seconds and then print DONE!."
      },
      {
        "key": "C",
        "text": "It will pause for 5 seconds and then print DONE!."
      },
      {
        "key": "D",
        "text": "It will pause for 15 seconds and then print DONE!."
      },
      {
        "key": "E",
        "text": "It will throw an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above, as the code does not compile.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "What statements about the following code are true? (Choose all that apply.)\nSystem.out.print(List.of(\"duck\",\"flamingo\",\"pelican\")\n   .parallelStream().parallel()   // q1\n   .reduce(0,\n      (c1, c2) - > c1.length() + c2.length(),  // q2\n      (s1, s2) - > s1 + s2));      // q3",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue, outputting the total length of all strings in the stream."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line q1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line q2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line q3."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "What statements about the following code snippet are true? (Choose all that apply.)\nObject o1 = new Object();\nObject o2 = new Object();\nvar service = Executors.newFixedThreadPool(2);\nvar f1 = service.submit(() - > {\n   synchronized (o1) {\n      synchronized (o2) { System.out.print(\"Tortoise\"); }\n   }\n});\nvar f2 = service.submit(() - > {\n   synchronized (o2) {\n      synchronized (o1) { System.out.print(\"Hare\"); }\n   }\n});\nf1.get();\nf2.get();",
    "choices": [
      {
        "key": "A",
        "text": "The code will always output Tortoise followed by Hare."
      },
      {
        "key": "B",
        "text": "The code will always output Hare followed by Tortoise."
      },
      {
        "key": "C",
        "text": "If the code does output anything, the order cannot be determined."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "The code compiles but may produce a deadlock at runtime."
      },
      {
        "key": "F",
        "text": "The code compiles but may produce a livelock at runtime."
      },
      {
        "key": "G",
        "text": "It compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which statement about the following code snippet is correct?\n2: var cats = Stream.of(\"leopard\", \"lynx\", \"ocelot\", \"puma\")\n3:    .parallel();\n4: var bears = Stream.of(\"panda\",\"grizzly\",\"polar\").parallel();\n5: var data = Stream.of(cats,bears).flatMap(s - > s)\n6:    .collect(Collectors.groupingByConcurrent(\n7:       s - > !s.startsWith(\"p\")));\n8: System.out.println(data.get(false).size()\n9:    + \" \" + data.get(true).size());",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 3 4."
      },
      {
        "key": "B",
        "text": "It outputs 4 3."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Assuming one minute is enough time for all the threads within this program to complete, \nwhat are the possible results of executing the following program? (Choose all that apply.)\npublic class RocketShip {\n   private volatile int fuel;\n   private void launch(int checks) {\n      var p = new ArrayList<Thread>();\n      for (int i = 0; i < checks; i++)\n         p.add(new Thread(() - > fuel++));\n      p.forEach(Thread::interrupt);\n      p.forEach(Thread::start);\n      p.forEach(Thread::interrupt);\n   }\n   public static void main(String[] args) throws Exception {\n      var ship = new RocketShip();\n      ship.launch(100);\n      Thread.sleep(60*1000);\n      System.out.print(ship.fuel);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints a number less than 100."
      },
      {
        "key": "B",
        "text": "It prints 100."
      },
      {
        "key": "C",
        "text": "It prints a number greater than 100."
      },
      {
        "key": "D",
        "text": "It does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an InterruptedException at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which statements about methods in ReentrantLock are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The lock() method will attempt to acquire a lock without waiting indefinitely for it."
      },
      {
        "key": "B",
        "text": "The testLock() method will attempt to acquire a lock without waiting indefinitely for it."
      },
      {
        "key": "C",
        "text": "The attemptLock() method will attempt to acquire a lock without waiting indefi-\nnitely for it."
      },
      {
        "key": "D",
        "text": "By default, a ReentrantLock fairly releases to each thread in the order in which it was \nrequested."
      },
      {
        "key": "E",
        "text": "Calling the unlock() method once will release a resource so that other threads can \nobtain the lock."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Which of the following are valid Callable expressions? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "a - > {return 10;}"
      },
      {
        "key": "B",
        "text": "() - > {String s = \"\";}"
      },
      {
        "key": "C",
        "text": "() - > 5"
      },
      {
        "key": "D",
        "text": "() - > {return null}"
      },
      {
        "key": "E",
        "text": "() - > \"The\" + \"Zoo\""
      },
      {
        "key": "F",
        "text": "(int count) - > count+1"
      },
      {
        "key": "G",
        "text": "() - > {System.out.println(\"Giraffe\"); return 10;}\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "What is the result of executing the following application? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintConstants {\n   public static void main(String[] args) {\n      var s = Executors.newScheduledThreadPool(10);\n      DoubleStream.of(3.14159,2.71828)   // b1\n         .forEach(c - > s.submit(         // b2\n            () - > System.out.println(10*c)));  // b3\n      s.execute(() - > System.out.println(\"Printed\"));\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and outputs the two numbers followed by Printed."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line b1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line b2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line b3."
      },
      {
        "key": "E",
        "text": "It compiles, but the output cannot be determined ahead of time."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "G",
        "text": "It compiles but waits forever at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "What is the result of executing the following program? (Choose all that apply.)\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintCounter {\n   static int count = 0;\n   public static void main(String[] args) throws\n                     InterruptedException, ExecutionException {\n      var service = Executors.newSingleThreadExecutor();\n      try {\n         var r = new ArrayList<Future<?>>();\n         IntStream.iterate(0,i - > i+1).limit(5).forEach(\n            i - > r.add(service.execute(() - > {count++;})) // n1\n         );\n         for(Future<?> result : r) {\n            System.out.print(result.get()+\" \"); // n2\n         }\n      } finally { service.shutdown(); }\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints 0 1 2 3 4"
      },
      {
        "key": "B",
        "text": "It prints 1 2 3 4 5"
      },
      {
        "key": "C",
        "text": "It prints null null null null null"
      },
      {
        "key": "D",
        "text": "It hangs indefinitely at runtime."
      },
      {
        "key": "E",
        "text": "The output cannot be determined."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line n1."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line n2.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Given the following code snippet and blank lines on p1 and p2, which values guarantee that \n1 is printed at runtime? (Choose all that apply.)\nvar data = List.of(List.of(1,2),\n   List.of(3,4),\n   List.of(5,6));\ndata.              // p1\n   .flatMap(s - > s.stream())\n   .              // p2\n   .ifPresent(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "stream() on line p1, findFirst() on line p2"
      },
      {
        "key": "B",
        "text": "stream() on line p1, findAny() on line p2"
      },
      {
        "key": "C",
        "text": "parallelStream() on line p1, findAny() on line p2"
      },
      {
        "key": "D",
        "text": "parallelStream() on line p1, findFirst() on line p2"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is inserted into the blanks."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Assuming one minute is enough time for the tasks submitted to the service executor to \ncomplete, what is the result of executing countSheep()? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class BedTime {\n   private AtomicInteger s1 = new AtomicInteger(0); // w1\n   private int s2 = 0;\n \n   private void countSheep() throws InterruptedException {\n      var service = Executors.newSingleThreadExecutor(); // w2\n      try {\n         for (int i = 0; i < 100; i++)\n         service.execute(() - > {\n            s1.getAndIncrement(); s2++; }); // w3\n         Thread.sleep(60*1000);\n         System.out.println(s1 + \" \" + s2);\n      } finally { service.shutdown(); }\n   }\n   public static void main(String... nap) throws InterruptedException {\n      new BedTime().countSheep();\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "The method consistently prints 100 99."
      },
      {
        "key": "B",
        "text": "The method consistently prints 100 100."
      },
      {
        "key": "C",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line w1."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line w2."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line w3."
      },
      {
        "key": "G",
        "text": "It compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "What is the result of executing the following application? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class StockRoomTracker {\n   public static void await(CyclicBarrier cb) { // j1\n      try { cb.await(); } catch (Exception e) {}\n   }\n   public static void main(String[] args) {\n      var cb = new CyclicBarrier(10,\n         () - > System.out.println(\"Stock Room Full!\")); // j2\n      IntStream.iterate(1, i - > 1).limit(9).parallel()\n         .forEach(i - > await(cb)); // j3\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It outputs Stock Room Full!"
      },
      {
        "key": "B",
        "text": "The code will not compile because of line j1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line j2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line j3."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "It compiles but waits forever at runtime.\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "What statements about the following class definition are true? (Choose all that apply.)\npublic final class TicketManager {\n   private int tickets;\n   private static TicketManager instance;\n   private TicketManager() {}\n   static synchronized TicketManager getInstance() {      // k1\n      if (instance==null) instance = new TicketManager(); // k2\n      return instance;\n   }\n \n   public int getTicketCount() { return tickets; }\n   public void addTickets(int value) {tickets += value;}  // k3\n   public void sellTickets(int value) {\n      synchronized (this) {                               // k4\n         tickets - = value;\n      } } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line k2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line k3."
      },
      {
        "key": "D",
        "text": "The locks acquired on k1 and k4 are on the same object."
      },
      {
        "key": "E",
        "text": "The class correctly protects the tickets data from race conditions."
      },
      {
        "key": "F",
        "text": "At most one instance of TicketManager will be created in an application that uses this \nclass.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "Assuming an implementation of the performCount() method is provided prior to runtime, \nwhich of the following are possible results of executing the following application? (Choose \nall that apply.)\nimport java.util.*;\nimport java.util.concurrent.*;\npublic class CountZooAnimals {\n   public static void performCount(int animal) {\n      // IMPLEMENTATION OMITTED\n   }\n   public static void printResults(Future<?> f) {\n      try {\n         System.out.println(f.get(1, TimeUnit.DAYS)); // o1\n      } catch (Exception e) {\n         System.out.println(\"Exception!\");\n      }\n   }\n   public static void main(String[] args) throws Exception {\n      final var r = new ArrayList<Future<?>>();\n      ExecutorService s = Executors.newSingleThreadExecutor();\n      try {\n         for(int i = 0; i < 10; i++) {\n            final int animal = i;\n            r.add(s.submit(() - > performCount(animal))); // o2\n         }\n         r.forEach(f - > printResults(f));\n      } finally { s.shutdown(); }\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It outputs a number 10 times."
      },
      {
        "key": "B",
        "text": "It outputs a Boolean value 10 times."
      },
      {
        "key": "C",
        "text": "It outputs a null value 10 times."
      },
      {
        "key": "D",
        "text": "It outputs Exception! 10 times."
      },
      {
        "key": "E",
        "text": "It hangs indefinitely at runtime."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line o1."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line o2.\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "Which class would be best to use to read a binary file into a Java object?",
    "choices": [
      {
        "key": "A",
        "text": "BufferedStream"
      },
      {
        "key": "B",
        "text": "FileReader"
      },
      {
        "key": "C",
        "text": "ObjectInputStream"
      },
      {
        "key": "D",
        "text": "ObjectReader"
      },
      {
        "key": "E",
        "text": "ObjectOutputStream"
      },
      {
        "key": "F",
        "text": "ObjectWriter"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Assuming that / is the root directory within the file system, which of the following are true \nstatements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "/home/parrot is an absolute path."
      },
      {
        "key": "B",
        "text": "/home/parrot is a directory."
      },
      {
        "key": "C",
        "text": "/home/parrot is a relative path."
      },
      {
        "key": "D",
        "text": "new File(\"/home\") will throw an exception if /home does not exist."
      },
      {
        "key": "E",
        "text": "new File(\"/home\").delete() will throw an exception if /home does not exist."
      },
      {
        "key": "F",
        "text": "A Reader offers character encoding, making it more useful when working with String \ndata than an InputStream."
      },
      {
        "key": "G",
        "text": "A Reader offers multithreading support, making it more useful than an InputStream.\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "What are possible results of executing the following code? (Choose all that apply.)\npublic static void main(String[] args) throws IOException {\n   String line;\n   var c = System.console();\n   Writer w = c.writer();\n   try (w) {\n      if ((line = c.readLine(\"Enter your name: \")) != null)\n         w.append(line);\n         w.flush();\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code runs, but nothing is printed."
      },
      {
        "key": "B",
        "text": "The code prints what was entered by the user."
      },
      {
        "key": "C",
        "text": "The code behaves the same if throws IOException is removed."
      },
      {
        "key": "D",
        "text": "A NullPointerException may be thrown."
      },
      {
        "key": "E",
        "text": "A NullPointerException will always be thrown."
      },
      {
        "key": "F",
        "text": "A NullPointerException will never be thrown."
      },
      {
        "key": "G",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "For which values of path sent to this method would it be possible for the following code to \noutput Success? (Choose all that apply.)\npublic void removeBadFile(Path path) {\n   if(Files.isDirectory(path))\n     System.out.println(Files.deleteIfExists(path)\n        ? \"Success\": \"Try Again\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "path refers to a regular file in the file system."
      },
      {
        "key": "B",
        "text": "path refers to a symbolic link in the file system."
      },
      {
        "key": "C",
        "text": "path refers to an empty directory in the file system."
      },
      {
        "key": "D",
        "text": "path refers to a directory with content in the file system."
      },
      {
        "key": "E",
        "text": "path does not refer to a record that exists within the file system."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Assume that the directory /animals exists and is empty. What is the result of executing the \nfollowing code?\nPath path = Path.of(\"/animals\");\ntry (var z = Files.walk(path)) {\n   boolean b = z\n      .filter((p,a) - > a.isDirectory() && !path.equals(p)) // x\n      .findFirst().isPresent();  // y\n   System.out.print(b ? \"No Sub\": \"Has Sub\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "It prints No Sub."
      },
      {
        "key": "B",
        "text": "It prints Has Sub."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line x."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line y."
      },
      {
        "key": "E",
        "text": "The output cannot be determined."
      },
      {
        "key": "F",
        "text": "It produces an infinite loop at runtime.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "What would be the value of name if the instance of Eagle created in the main() method were \nserialized and then deserialized?\nimport java.io.Serializable;\nclass Bird {\n   protected transient String name;\n   public void setName(String name) { this.name = name; }\n   public String getName() { return name; }\n   public Bird() {\n      this.name = \"Matt\";\n   }\n}\npublic class Eagle extends Bird implements Serializable {\n   { this.name = \"Olivia\"; }\n   public Eagle() {\n      this.name = \"Bridget\";\n   }\n   public static void main(String[] args) {\n      var e = new Eagle();\n      e.name = \"Adeline\";\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Adeline"
      },
      {
        "key": "B",
        "text": "Bridget"
      },
      {
        "key": "C",
        "text": "Matt"
      },
      {
        "key": "D",
        "text": "Olivia"
      },
      {
        "key": "E",
        "text": "null"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Assume that /kang exists as a symbolic link to the directory /mammal/kangaroo within \nthe file system. Which of the following statements are correct about this code snippet? \n(Choose all that apply.)\nvar path = Paths.get(\"/kang\");\nif(Files.isDirectory(path) && Files.isSymbolicLink(path))\n   Files.createDirectory(path.resolve(\"joey\"));",
    "choices": [
      {
        "key": "A",
        "text": "A new directory will always be created."
      },
      {
        "key": "B",
        "text": "A new directory may be created."
      },
      {
        "key": "C",
        "text": "If the code creates a directory, it will be reachable at /kang/joey."
      },
      {
        "key": "D",
        "text": "If the code creates a directory, it will be reachable at /mammal/joey."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code will compile but will always throw an exception at runtime.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Assuming that the /fox/food- schedule.csv file exists with the specified contents, what \nis the expected output of calling printData() on it?\n/fox/food-  schedule.csv\n6am,Breakfast\n9am,SecondBreakfast\n12pm,Lunch\n6pm,Dinner\n \nvoid printData(Path path) throws IOException {\n   Files.readAllLines(path) // r1\n      .flatMap(p - > Stream.of(p.split(\",\"))) // r2\n      .map(q - > q.toUpperCase())  // r3\n      .forEach(System.out::println);\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code will not compile because of line r1."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line r2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line r3."
      },
      {
        "key": "D",
        "text": "It throws an exception at runtime."
      },
      {
        "key": "E",
        "text": "It does not print anything at runtime."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Given the following method, which statements are correct? (Choose all that apply.)\npublic void copyFile(File file1, File file2) throws Exception {\n   var reader = new InputStreamReader(new FileInputStream(file1));\n   try (var writer = new FileWriter(file2)) {\n      char[] buffer = new char[10];\n      while(reader.read(buffer) != - 1) {\n          writer.write(buffer);\n          // n1\n      }\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code does not compile because reader is not a buffered stream."
      },
      {
        "key": "B",
        "text": "The code does not compile because writer is not a buffered stream."
      },
      {
        "key": "C",
        "text": "The code compiles and correctly copies the data between some files."
      },
      {
        "key": "D",
        "text": "The code compiles and correctly copies the data between all files."
      },
      {
        "key": "E",
        "text": "If we check file2 on line n1 within the file system after five iterations of the while \nloop, it may be empty."
      },
      {
        "key": "F",
        "text": "If we check file2 on line n1 within the file system after five iterations, it will contain \nexactly 50 characters."
      },
      {
        "key": "G",
        "text": "This method contains a resource leak.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Which of the following correctly create Path instances? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "new Path(\"jaguar.txt\")"
      },
      {
        "key": "B",
        "text": "FileSystems.getDefault().getPath(\"puma.txt\")"
      },
      {
        "key": "C",
        "text": "Path.get(\"cats\",\"lynx.txt\")"
      },
      {
        "key": "D",
        "text": "new java.io.File(\"tiger.txt\").toPath()"
      },
      {
        "key": "E",
        "text": "new FileSystem().getPath(\"lion\")"
      },
      {
        "key": "F",
        "text": "Paths.getPath(\"ocelot.txt\")"
      },
      {
        "key": "G",
        "text": "Path.of(Path.of(\".\").toUri())\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Which classes will allow the following to compile? (Choose all that apply.)\nvar is = new BufferedInputStream(new FileInputStream(\"z.txt\"));\nInputStream wrapper = new  (is);\ntry (wrapper) {}",
    "choices": [
      {
        "key": "A",
        "text": "BufferedInputStream"
      },
      {
        "key": "B",
        "text": "BufferedReader"
      },
      {
        "key": "C",
        "text": "BufferedWriter"
      },
      {
        "key": "D",
        "text": "FileInputStream"
      },
      {
        "key": "E",
        "text": "ObjectInputStream"
      },
      {
        "key": "F",
        "text": "ObjectOutputStream"
      },
      {
        "key": "G",
        "text": "None of the above, as the first line does not compile\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "What is the result of executing the following code? (Choose all that apply.)\n4: var p = Paths.get(\"sloth.schedule\");\n5: var a = Files.readAttributes(p, BasicFileAttributes.class);\n6: Files.mkdir(p.resolve(\".backup\"));\n7: if(a.size()>0 && a.isDirectory()) {\n8:    a.setTimes(null,null,null);\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of the following are true statements about serialization in Java? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "All non- null instance members of the class must be serializable or marked transient."
      },
      {
        "key": "B",
        "text": "Records are automatically serializable."
      },
      {
        "key": "C",
        "text": "Serialization involves converting data into Java objects."
      },
      {
        "key": "D",
        "text": "Serializable is a functional interface."
      },
      {
        "key": "E",
        "text": "The class must declare a static serialVersionUID variable."
      },
      {
        "key": "F",
        "text": "The class must extend the Serializable class."
      },
      {
        "key": "G",
        "text": "The class must implement the Serializable interface.\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "What is the output of the following code? (Choose three.)\n22: var p1 = Path.of(\"/zoo/./bear\",\"../food.txt\");\n23: p1.normalize().relativize(Path.of(\"/lion\"));\n24: System.out.println(p1);\n25:\n26: var p2 = Paths.get(\"/zoo/animals/bear/koala/food.txt\");\n27: System.out.println(p2.subpath(1,3).getName(1));\n28:\n29: var p3 = Path.of(\"/pets/../cat.txt\");\n30: var p4 = Paths.get(\"./dog.txt\");\n31: System.out.println(p4.resolve(p3));",
    "choices": [
      {
        "key": "A",
        "text": "../../lion"
      },
      {
        "key": "B",
        "text": "/zoo/./bear/../food.txt"
      },
      {
        "key": "C",
        "text": "animal"
      },
      {
        "key": "D",
        "text": "bear"
      },
      {
        "key": "E",
        "text": "/pets/../cat.txt"
      },
      {
        "key": "F",
        "text": "/pets/../cat.txt/./dog.txt\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Suppose that the working directory is /weather and the absolute path  \n/weather/winter/snow.dat represents a file that exists within the file system. Which of \nthe following lines of code create an object that represents the file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "new File(\"/weather\", \"winter\", \"snow.dat\")"
      },
      {
        "key": "B",
        "text": "new File(\"/weather/winter/snow.dat\")"
      },
      {
        "key": "C",
        "text": "new File(\"/weather/winter\", new File(\"snow.dat\"))"
      },
      {
        "key": "D",
        "text": "new File(\"weather\", \"/winter/snow.dat\")"
      },
      {
        "key": "E",
        "text": "new File(new File(\"/weather/winter\"), \"snow.dat\")"
      },
      {
        "key": "F",
        "text": "Path.of(\"/weather/winer/snow.dat\").toFile();"
      },
      {
        "key": "G",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Assuming zoo- data.txt exists and is not empty, what statements about the following \nmethod are correct? (Choose all that apply.)\nprivate void echo() throws IOException {\n   var o = new FileWriter(\"new- zoo.txt\");\n   try (var f = new FileReader(\"zoo- data.txt\");\n      var b = new BufferedReader(f); o) {\n   \n      o.write(b.readLine());\n   }\n   o.write(\"\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "When run, the method creates a new file with one line of text in it."
      },
      {
        "key": "B",
        "text": "When run, the method creates a new file with two lines of text in it."
      },
      {
        "key": "C",
        "text": "When run, the method creates a new file with the same number of lines as the original \nfile."
      },
      {
        "key": "D",
        "text": "The method compiles but will produce an exception at runtime."
      },
      {
        "key": "E",
        "text": "The method does not compile."
      },
      {
        "key": "F",
        "text": "The method uses byte stream classes.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Which are true statements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "NIO.2 includes a method to delete an entire directory tree."
      },
      {
        "key": "B",
        "text": "NIO.2 includes a method to traverse a directory tree."
      },
      {
        "key": "C",
        "text": "NIO.2 includes methods that are aware of symbolic links."
      },
      {
        "key": "D",
        "text": "Files.readAttributes() cannot access file-system dependent attributes."
      },
      {
        "key": "E",
        "text": "Files.readAttributes() is often more performant since it reads multiple attrib-\nutes rather than accessing individual attributes."
      },
      {
        "key": "F",
        "text": "Files.readAttributes() works with the File object.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "Assume that reader is a valid stream whose next characters are PEACOCKS. What is true \nabout the output of the following code snippet? (Choose all that apply.)\nvar sb = new StringBuilder();\nsb.append((char)reader.read());\nreader.mark(10);\nfor(int i=0; i<2; i++) {\n   sb.append((char)reader.read());\n   reader.skip(2);\n}\nreader.reset();\nreader.skip(0);\nsb.append((char)reader.read());\nSystem.out.println(sb.toString());",
    "choices": [
      {
        "key": "A",
        "text": "The code may print PEAE."
      },
      {
        "key": "B",
        "text": "The code may print PEOA."
      },
      {
        "key": "C",
        "text": "The code may print PEOE."
      },
      {
        "key": "D",
        "text": "The code may print PEOS."
      },
      {
        "key": "E",
        "text": "The code will always print PEAE."
      },
      {
        "key": "F",
        "text": "The code will always print PEOA."
      },
      {
        "key": "G",
        "text": "The code will always print PEOE."
      },
      {
        "key": "H",
        "text": "The code will always print PEOS.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Assuming that the directories and files referenced exist and are not symbolic links, what is \nthe result of executing the following code?\nvar p1 = Path.of(\"/lizard\",\".\").resolve(Path.of(\"walking.txt\"));\nvar p2 = new File(\"/lizard/././actions/../walking.txt\").toPath();\nSystem.out.print(Files.isSameFile(p1,p2));\nSystem.out.print(\" \");\nSystem.out.print(p1.equals(p2));\nSystem.out.print(\" \");\nSystem.out.print(Files.mismatch(p1,p2));",
    "choices": [
      {
        "key": "A",
        "text": "true true - 1"
      },
      {
        "key": "B",
        "text": "true true 0"
      },
      {
        "key": "C",
        "text": "true false - 1"
      },
      {
        "key": "D",
        "text": "true false 0"
      },
      {
        "key": "E",
        "text": "false true - 1"
      },
      {
        "key": "F",
        "text": "false true 0"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "The result cannot be determined.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Assume that monkey.txt is a file that exists in the current working directory. Which state-\nments about the following code snippet are correct? (Choose all that apply.)\nFiles.move(Path.of(\"monkey.txt\"), Paths.get(\"/animals\"),\n   StandardCopyOption.ATOMIC_MOVE,\n   LinkOption.NOFOLLOW_LINKS);",
    "choices": [
      {
        "key": "A",
        "text": "If /animals/monkey.txt exists, it will be overwritten at runtime."
      },
      {
        "key": "B",
        "text": "If /animals exists as an empty directory, /animals/monkey.txt will be the new \nlocation of the file."
      },
      {
        "key": "C",
        "text": "If monkey.txt is a symbolic link, the file it points to will be moved at runtime."
      },
      {
        "key": "D",
        "text": "If the move is successful and another process is monitoring the file system, it will not see \nan incomplete file at runtime."
      },
      {
        "key": "E",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Assume that /monkeys exists as a directory containing multiple files, symbolic links, and \nsubdirectories. Which statement about the following code is correct?\nvar f = Path.of(\"/monkeys\");\ntry (var m =\n   Files.find(f, 0, (p,a) - > a.isSymbolicLink())) { // y1\n      m.map(s - > s.toString())\n         .collect(Collectors.toList())\n         .stream()\n         .filter(s - > s.toString().endsWith(\".txt\")) // y2\n         .forEach(System.out::println);\n}",
    "choices": [
      {
        "key": "A",
        "text": "It will print all symbolic links in the directory tree ending in .txt."
      },
      {
        "key": "B",
        "text": "It will print the target of all symbolic links in the directory ending in .txt."
      },
      {
        "key": "C",
        "text": "It will print nothing."
      },
      {
        "key": "D",
        "text": "It does not compile because of line y1."
      },
      {
        "key": "E",
        "text": "It does not compile because of line y2."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  },
  {
    "question": "Which of the following fields will be null after an instance of the class created  \non line 17 is serialized and then deserialized using ObjectOutputStream and \nObjectInputStream? (Choose all that apply.)\n1:  import java.io.Serializable;\n2:  import java.util.List;\n3:  public class Zebra implements Serializable {\n4:     private transient String name = \"George\";\n5:     private static String birthPlace = \"Africa\";\n6:     private transient Integer age;\n7:     List<Zebra> friends = new java.util.ArrayList<>();\n8:     private Object stripes = new Object();\n9:     { age = 10;}\n10:    public Zebra() {\n11:       this.name = \"Sophia\";\n12:    }\n13:    static Zebra writeAndRead(Zebra z) {\n14:       // Implementation omitted\n15:    }\n16:    public static void main(String[] args) {\n17:       var zebra = new Zebra();\n18:       zebra = writeAndRead(zebra);\n19:    }",
    "choices": [
      {
        "key": "A",
        "text": "age"
      },
      {
        "key": "B",
        "text": "birthplace"
      },
      {
        "key": "C",
        "text": "friends"
      },
      {
        "key": "D",
        "text": "name"
      },
      {
        "key": "E",
        "text": "stripes"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "question": "What are some possible results of executing the following code? (Choose all that apply.)\nvar x = Path.of(\"/animals/fluffy/..\");\nFiles.walk(x.toRealPath().getParent())      // u1\n   .map(p - > p.toAbsolutePath().toString()) // u2\n   .filter(s - > s.endsWith(\".java\")) \n   .forEach(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "It prints some files in the root directory."
      },
      {
        "key": "B",
        "text": "It prints all files in the root directory."
      },
      {
        "key": "C",
        "text": "FileSystemLoopException is thrown at runtime."
      },
      {
        "key": "D",
        "text": "Another exception is thrown at runtime."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line u1."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line u2.\n"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\nChapter 15: JDBC 959\n"
  },
  {
    "question": "Assume that the source instance passed to the following method represents a file that exists. \nAlso assume that /flip/sounds.txt exists as a file prior to executing this method. When \nthis method is executed, which statement correctly copies the file to the path specified by  \n/flip/sounds.txt?\nvoid copyIntoFlipDirectory(Path source) throws IOException {\n   var dolphinDir = Path.of(\"/flip\");\n   dolphinDir = Files.createDirectories(dolphinDir);\n   var n = Paths.get(\"sounds.txt\");\n   ;\n}",
    "choices": [
      {
        "key": "A",
        "text": "Files.copy(source, dolphinDir)"
      },
      {
        "key": "B",
        "text": "Files.copy(source, dolphinDir.resolve(n),  \nStandardCopyOption.REPLACE_EXISTING)"
      },
      {
        "key": "C",
        "text": "Files.copy(source, dolphinDir,  \nStandardCopyOption.REPLACE_EXISTING )"
      },
      {
        "key": "D",
        "text": "Files.copy(source, dolphinDir.resolve(n))"
      },
      {
        "key": "E",
        "text": "The method does not compile, regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "The method compiles but throws an exception at runtime, regardless of what is placed \nin the blank.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "question": "Suppose that you need to read text data from a file and want the data to be performant on \nlarge files. Which two java.io stream classes can be chained together to best achieve this \nresult? (Choose two.)",
    "choices": [
      {
        "key": "A",
        "text": "BufferedInputStream"
      },
      {
        "key": "B",
        "text": "BufferedReader"
      },
      {
        "key": "C",
        "text": "FileInputStream"
      },
      {
        "key": "D",
        "text": "FileReader"
      },
      {
        "key": "E",
        "text": "PrintInputStream"
      },
      {
        "key": "F",
        "text": "ObjectInputStream"
      },
      {
        "key": "G",
        "text": "PrintReader\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\nChapter 15: JDBC\n"
  },
  {
    "question": "Which interfaces or classes are in a database- specific JAR file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Driver"
      },
      {
        "key": "B",
        "text": "Driver’s implementation"
      },
      {
        "key": "C",
        "text": "Manager"
      },
      {
        "key": "D",
        "text": "DriverManager’s implementation"
      },
      {
        "key": "E",
        "text": "PreparedStatement"
      },
      {
        "key": "F",
        "text": "PreparedStatement implementation\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "question": "Which of the following is a valid JDBC URL?",
    "choices": [
      {
        "key": "A",
        "text": "jdbc:sybase:localhost:1234/db"
      },
      {
        "key": "B",
        "text": "jdbc::sybase::localhost::/db"
      },
      {
        "key": "C",
        "text": "jdbc::sybase:localhost::1234/db"
      },
      {
        "key": "D",
        "text": "sybase:localhost:1234/db"
      },
      {
        "key": "E",
        "text": "sybase::localhost::/db"
      },
      {
        "key": "F",
        "text": "sybase::localhost::1234/db\n"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "question": "Which of the options can fill in the blank to make the code compile and run without error? \n(Choose all that apply.)\nvar sql = \"\"\"\n   UPDATE habitat SET environment = null \n   WHERE environment = ? \"\"\";\ntry (var ps = conn.prepareStatement(sql)) {\n \n   \n \n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "ps.setString(0, \"snow\");"
      },
      {
        "key": "B",
        "text": "ps.setString(1, \"snow\");"
      },
      {
        "key": "C",
        "text": "ps.setString(\"environment\", \"snow\");"
      },
      {
        "key": "D",
        "text": "ps.setString(1, \"snow\"); ps.setString(1, \"snow\");"
      },
      {
        "key": "E",
        "text": "ps.setString(1, \"snow\"); ps.setString(2, \"snow\");"
      },
      {
        "key": "F",
        "text": "ps.setString(\"environment\", \"snow\"); ps.setString(\"environment\", \n\"snow\");\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "question": "Suppose that you have a table named animal with two rows. What is the result of the fol-\nlowing code?\n6:  var conn = new Connection(url, userName, password);\n7:  var ps = conn.prepareStatement(\n8:     \"SELECT  count(*) FROM animal\");\n9:  var rs = ps.executeQuery();\n10: if (rs.next()) System.out.println(rs.getInt(1));",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "There is a compiler error on line 6."
      },
      {
        "key": "D",
        "text": "There is a compiler error on line 10."
      },
      {
        "key": "E",
        "text": "There is a compiler error on another line."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "question": "Which option can fill in the blanks to make the code compile?\nboolean bool = ps. ();\nint num = ps. ();\nResultSet rs = ps. ();",
    "choices": [
      {
        "key": "A",
        "text": "execute, executeQuery, executeUpdate"
      },
      {
        "key": "B",
        "text": "execute, executeUpdate, executeQuery"
      },
      {
        "key": "C",
        "text": "executeQuery, execute, executeUpdate"
      },
      {
        "key": "D",
        "text": "executeQuery, executeUpdate, execute"
      },
      {
        "key": "E",
        "text": "executeUpdate, execute, executeQuery"
      },
      {
        "key": "F",
        "text": "executeUpdate, executeQuery, execute\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "question": "Suppose there are two rows in the table before this code is run, and executeUpdate() runs \nwithout error. How many rows are in the table after the code completes?\nconn.setAutoCommit(true);\n \nString sql = \"INSERT INTO games VALUES(3, Jenga);\";\n \ntry (PreparedStatement ps = conn.prepareStatement(sql,\n   ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {\n   ps.executeUpdate();\n}\nconn.rollback();",
    "choices": [
      {
        "key": "A",
        "text": "Two"
      },
      {
        "key": "B",
        "text": "Three"
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "The code throws an exception.\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n\n"
  },
  {
    "question": "Suppose that the table names has five rows and the following SQL statement updates all of \nthem. What is the result of this code?\npublic static void main(String[] args) throws SQLException {\n   var sql = \"UPDATE names SET name = 'Animal'\";\n   try (var conn = DriverManager.getConnection(\"jdbc:hsqldb:file:zoo\");\n      var ps = conn.prepareStatement(sql)) {\n \n      var result = ps.executeUpdate();\n      System.out.println(result);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "question": "Suppose learn() is a stored procedure that takes one IN parameter. What is wrong with \nthe following code? (Choose all that apply.)\n18: var sql = \"call learn()\";\n19: try (var cs = conn.prepareCall(sql)) {\n20:    cs.setString(1, \"java\");\n21:    try (var rs = cs.executeQuery()) {\n22:       while (rs.next())\n23:          System.out.println(rs.getString(3));\n24:    }\n25: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 18 is missing braces."
      },
      {
        "key": "B",
        "text": "Line 18 is missing a ?."
      },
      {
        "key": "C",
        "text": "Line 19 is not allowed to use var."
      },
      {
        "key": "D",
        "text": "Line 20 does not compile."
      },
      {
        "key": "E",
        "text": "Line 22 does not compile."
      },
      {
        "key": "F",
        "text": "Something else is wrong with the code."
      },
      {
        "key": "G",
        "text": "None of the above. This code is correct.\n"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "question": "Suppose that the table enrichment has three rows with the animals bat, rat, and snake. How \nmany lines does this code print?\nvar sql = \"SELECT toy FROM enrichment WHERE animal = ?\";\ntry (var ps = conn.prepareStatement(sql)) {\n     try (var rs = ps.executeQuery()) {\n       while (rs.next())\n          System.out.println(rs.getString(1));\n     }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "question": "Suppose that the table food has five rows, and this SQL statement updates all of them. What \nis the result of this code?\npublic static void main(String[] args) {\n   var sql = \"UPDATE food SET amount = amount + 1\";\n   try (var conn = DriverManager.getConnection(\"jdbc:hsqldb:file:zoo\");\n      var ps = conn.prepareStatement(sql)) {\n \n      var result = ps.executeUpdate();\n      System.out.println(result);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "question": "Suppose we have a JDBC program that calls a stored procedure, which returns a set of \nresults. Which is the correct order in which to close database resources for this call?",
    "choices": [
      {
        "key": "A",
        "text": "Connection, ResultSet, CallableStatement"
      },
      {
        "key": "B",
        "text": "Connection, CallableStatement, ResultSet"
      },
      {
        "key": "C",
        "text": "ResultSet, Connection, CallableStatement"
      },
      {
        "key": "D",
        "text": "ResultSet, CallableStatement, Connection"
      },
      {
        "key": "E",
        "text": "CallableStatement, Connection, ResultSet"
      },
      {
        "key": "F",
        "text": "CallableStatement, ResultSet, Connection\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "question": "Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does \nthis code print?\nvar sql = \"SELECT num FROM counts WHERE num> ?\";\ntry (var ps = conn.prepareStatement(sql,\n   ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)) {\n   ps.setInt(1, 3);\n \n   try (var rs = ps.executeQuery()) {\n   while (rs.next())\n      System.out.println(rs.getObject(1));\n   }\n \n   ps.setInt(1, 100);\n \n    try (var rs = ps.executeQuery()) {\n     while (rs.next())\n        System.out.println(rs.getObject(1));\n     }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code throws an exception.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "question": "Which of the following can fill in the blank correctly? (Choose all that apply.)\nvar rs = ps.executeQuery();\nif (rs.next())\n   ;",
    "choices": [
      {
        "key": "A",
        "text": "String s = rs.getString(0)"
      },
      {
        "key": "B",
        "text": "String s = rs.getString(1)"
      },
      {
        "key": "C",
        "text": "String s = rs.getObject(0)"
      },
      {
        "key": "D",
        "text": "String s = rs.getObject(1)"
      },
      {
        "key": "E",
        "text": "Object s = rs.getObject(0)"
      },
      {
        "key": "F",
        "text": "Object s = rs.getObject(1)\n"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "question": "Suppose learn() is a stored procedure that takes one IN parameter and one OUT param-\neter. What is wrong with the following code? (Choose all that apply.)\n18: var sql = \"{?= call learn(?)}\";\n19: try (var cs = conn.prepareCall(sql)) {\n20:    cs.setInt(1, 8);\n21:    cs.execute();\n22:    System.out.println(cs.getInt(1));\n23: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 18 does not call the stored procedure properly."
      },
      {
        "key": "B",
        "text": "The parameter value is not set for input."
      },
      {
        "key": "C",
        "text": "The parameter is not registered for output."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "Something else is wrong with the code."
      },
      {
        "key": "F",
        "text": "None of the above. This code is correct.\n"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "question": "Which can fill in the blank and have the code run without error? (Choose all that apply.)\n17: conn.setAutoCommit(false);\n18: \n19: var larry = conn.setSavepoint();\n20: var curly = conn.setSavepoint();\n21: var moe = conn.setSavepoint();\n22: var shemp = conn.setSavepoint();\n23:\n24: ;\n25:\n26: conn.rollback(curly);",
    "choices": [
      {
        "key": "A",
        "text": "conn.rollback(larry)"
      },
      {
        "key": "B",
        "text": "conn.rollback(curly)"
      },
      {
        "key": "C",
        "text": "conn.rollback(moe)"
      },
      {
        "key": "D",
        "text": "conn.rollback(shemp)"
      },
      {
        "key": "E",
        "text": "conn.rollback()"
      },
      {
        "key": "F",
        "text": "The code does not compile.\n"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "question": "Which of the following can fill in the blank? (Choose all that apply.)\nvar sql = \" \";\ntry (var ps = conn.prepareStatement(sql)) {\n   ps.setObject(3, \"red\");\n   ps.setInt(2, 8);\n   ps.setString(1, \"ball\");\n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "{ call insert_toys(?, ?) }"
      },
      {
        "key": "B",
        "text": "{ call insert_toys(?, ?, ?) }"
      },
      {
        "key": "C",
        "text": "{ call insert_toys(?, ?, ?, ?) }"
      },
      {
        "key": "D",
        "text": "INSERT INTO toys VALUES (?, ?)"
      },
      {
        "key": "E",
        "text": "INSERT INTO toys VALUES (?, ?, ?)"
      },
      {
        "key": "F",
        "text": "INSERT INTO toys VALUES (?, ?, ?, ?)\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "question": "Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does \nthis code print?\nvar sql = \"SELECT num FROM counts WHERE num> ?\";\ntry (var ps = conn.prepareStatement(sql)) {\n   ps.setInt(1, 3);\n \n   try (var rs = ps.executeQuery()) {\n      while (rs.next())\n         System.out.println(rs.getObject(1));\n   }\n   try (var rs = ps.executeQuery()) {\n      while (rs.next())\n         System.out.println(rs.getObject(1));\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code throws an exception.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\nChapter 15: JDBC 961\n"
  },
  {
    "question": "There are currently 100 rows in the table species before inserting a new row. What is the \noutput of the following code?\nString insert = \"INSERT INTO species VALUES (3, 'Ant', .05)\";\nString select = \"SELECT count(*) FROM species\";\ntry (var ps = conn.prepareStatement(insert)) {\n   ps.executeUpdate();\n}\ntry (var ps = conn.prepareStatement(select)) {\n   var rs = ps.executeQuery();\n   System.out.println(rs.getInt(1));\n}",
    "choices": [
      {
        "key": "A",
        "text": "100"
      },
      {
        "key": "B",
        "text": "101"
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "A SQLException is thrown."
      },
      {
        "key": "E",
        "text": "A different exception is thrown.\n"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "question": "Which of the options can fill in the blank to make the code compile and run without error? \n(Choose all that apply.)\nvar sql = \"UPDATE habitat WHERE environment = ?\";\ntry (var ps = conn.prepareCall(sql)) {\n \n   \n \n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "ps.setString(0, \"snow\");"
      },
      {
        "key": "B",
        "text": "ps.setString(1, \"snow\");"
      },
      {
        "key": "C",
        "text": "ps.setString(\"environment\", \"snow\");"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "The code throws an exception at runtime.\n"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "question": "Which is the first line containing a compiler error?\n25: String url = \"jdbc:hsqldb:file:zoo\";\n26: try (var conn = DriverManager.getConnection(url);\n27:    var ps = conn.prepareStatement();\n28:    var rs = ps.executeQuery(\"SELECT * FROM swings\")) {\n29:    while (rs.next()) {\n30:       System.out.println(rs.getInteger(1));\n31:    }\n32: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 26"
      },
      {
        "key": "B",
        "text": "Line 27"
      },
      {
        "key": "C",
        "text": "Line 28"
      },
      {
        "key": "D",
        "text": "Line 29"
      },
      {
        "key": "E",
        "text": "Line 30"
      },
      {
        "key": "F",
        "text": "None of the above\n"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "question": "Suppose conn is a valid connection object and the exhibits table is empty. Which are true? \n(Choose two.)\ntry (conn) {\n   conn.setAutoCommit(false);\n \n  String sql = \"INSERT INTO exhibits VALUES(3, 'Test', 2)\";\n   try (PreparedStatement ps = conn.prepareStatement(sql)) {\n      ps.executeUpdate();\n  }\n \n   conn.setAutoCommit(true);   // line W\n}",
    "choices": [
      {
        "key": "A",
        "text": "As written, the table will remain empty after this code."
      },
      {
        "key": "B",
        "text": "As written, the table will contain one row after this code."
      },
      {
        "key": "C",
        "text": "As written, the code will throw an exception."
      },
      {
        "key": "D",
        "text": "When line W is commented out, the table will remain empty after this code."
      },
      {
        "key": "E",
        "text": "When line W is commented out, the table will contain one row after this code."
      },
      {
        "key": "F",
        "text": "When line W is commented out, the code will throw an exception.\n\n"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  }
]