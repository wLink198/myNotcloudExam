[
  {
    "id": "oca-1",
    "question": "Which of the following are legal entry point methods that can be run from the command \nline? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "private static void main(String[] args)"
      },
      {
        "key": "B",
        "text": "public static final main(String[] args)"
      },
      {
        "key": "C",
        "text": "public void main(String[] args)"
      },
      {
        "key": "D",
        "text": "public static final void main(String[] args)"
      },
      {
        "key": "E",
        "text": "public static void main(String[] args)"
      },
      {
        "key": "F",
        "text": "public static main(String[] args)"
      }
    ],
    "answer": [
      "D",
      "E"
    ],
    "explanation": "Option E is the canonical main() method signature. You need to memorize it. \nOption D is an alternate form with the redundant final. Option A is incorrect because the \nmain() method must be public. Options B and F are incorrect because the main() method \nmust have a void return type. Option C is incorrect because the main() method must \nbe static.\n"
  },
  {
    "id": "oca-2",
    "question": "Which answer options represent the order in which the following statements can be assem-\nbled into a program that will compile successfully? (Choose all that apply.)\n    X: class Rabbit {}\n    Y: import java.util.*;\n    Z: package animals;",
    "choices": [
      {
        "key": "A",
        "text": "X, Y, Z"
      },
      {
        "key": "B",
        "text": "Y, Z, X"
      },
      {
        "key": "C",
        "text": "Z, Y, X"
      },
      {
        "key": "D",
        "text": "Y, X"
      },
      {
        "key": "E",
        "text": "Z, X"
      },
      {
        "key": "F",
        "text": "X, Z"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C",
      "D",
      "E"
    ],
    "explanation": "The package and import statements are both optional. If both are present, the \norder must be package, then import, and then class. Option A is incorrect because \nclass is before package and import. Option B is incorrect because import is before \npackage. Option F is incorrect because class is before package.\n"
  },
  {
    "id": "oca-3",
    "question": "Which of the following are true? (Choose all that apply.)\n    public class Bunny {\n       public static void main(String[] x) {\n          Bunny bun = new Bunny();\n    } }",
    "choices": [
      {
        "key": "A",
        "text": "Bunny is a class."
      },
      {
        "key": "B",
        "text": "bun is a class."
      },
      {
        "key": "C",
        "text": "main is a class."
      },
      {
        "key": "D",
        "text": "Bunny is a reference to an object."
      },
      {
        "key": "E",
        "text": "bun is a reference to an object."
      },
      {
        "key": "F",
        "text": "main is a reference to an object."
      },
      {
        "key": "G",
        "text": "The main() method doesn’t run because the parameter name is incorrect."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Bunny is a class, which can be seen from the declaration: public class Bunny. \nThe variable bun is a reference to an object. The method main() is the standard entry \npoint to a program. Option G is incorrect because the parameter type matters, not the \nparameter name.\n"
  },
  {
    "id": "oca-4",
    "question": "Which of the following are valid Java identifiers? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "_"
      },
      {
        "key": "B",
        "text": "_helloWorld$"
      },
      {
        "key": "C",
        "text": "true"
      },
      {
        "key": "D",
        "text": "java.lang"
      },
      {
        "key": "E",
        "text": "Public"
      },
      {
        "key": "F",
        "text": "1980_s"
      },
      {
        "key": "G",
        "text": "_Q2_"
      }
    ],
    "answer": [
      "B",
      "E",
      "G"
    ],
    "explanation": "Option A is invalid because a single underscore is not allowed. Option C is not a \nvalid identifier because true is a Java reserved word. Option D is not valid because a period \n(.) is not allowed in identifiers. Option F is not valid because the first character is not a \nletter, dollar sign ($), or underscore (_). Options B, E, and G are valid because they contain \nonly valid characters.\n"
  },
  {
    "id": "oca-5",
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n    2:  public class Bear {\n    3:     private Bear pandaBear;\n    4:     private void roar(Bear b) {\n    5:        System.out.println(\"Roar!\");\n    6:        pandaBear = b;\n    7:     }\n    8:     public static void main(String[] args) {\n    9:        Bear brownBear = new Bear();\n    10:       Bear polarBear = new Bear();\n    11:       brownBear.roar(polarBear);\n    12:       polarBear = null;\n    13:       brownBear = null;\n    14:       System.gc(); } }",
    "choices": [
      {
        "key": "A",
        "text": "The object created on line 9 is eligible for garbage collection after line 13."
      },
      {
        "key": "B",
        "text": "The object created on line 9 is eligible for garbage collection after line 14."
      },
      {
        "key": "C",
        "text": "The object created on line 10 is eligible for garbage collection after line 12."
      },
      {
        "key": "D",
        "text": "The object created on line 10 is eligible for garbage collection after line 13."
      },
      {
        "key": "E",
        "text": "Garbage collection is guaranteed to run."
      },
      {
        "key": "F",
        "text": "Garbage collection might or might not run."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A",
      "D",
      "F"
    ],
    "explanation": "Garbage collection is never guaranteed to run, making option F correct and option E \nincorrect. Next, the class compiles and runs without issue, so option G is incorrect. The Bear\nobject created on line 9 is accessible until line 13 via the brownBear reference variable, \nwhich is option A. The Bear object created on line 10 is accessible via both the polarBear\nreference and the brownBear.pandaBear reference. After line 12, the object is still acces\u0002sible via brownBear.pandaBear. After line 13, though, it is no longer accessible since \nbrownBear is no longer accessible, which makes option D the final answer.\n"
  },
  {
    "id": "oca-6",
    "question": "Assuming the following class compiles, how many variables defined in the class or method \nare in scope on the line marked on line 14?\n    1:  public class Camel {\n    2:     { int hairs = 3_000_0; }\n    3:     long water, air=2;\n    4:     boolean twoHumps = true;\n    5:     public void spit(float distance) {\n    6:        var path = \"\";\n    7:        { double teeth = 32 + distance++; }\n    8:        while(water > 0) {\n    9:           int age = twoHumps ? 1 : 2;\n    10:          short i=- 1;\n    11:          for(i=0; i<10; i++) {\n    12:             var Private = 2;\n    13:          }\n    14:          // SCOPE\n    15:       }\n    16:    }\n    17: }",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "4"
      },
      {
        "key": "D",
        "text": "5"
      },
      {
        "key": "E",
        "text": "6"
      },
      {
        "key": "F",
        "text": "7"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "To solve this problem, you need to trace the braces {} and see when variables go in and \nout of scope. The variables on lines 2 and 7 are only in scope for a single line block. The var\u0002iable on line 12 is only in scope for the for loop. None of these are in scope on line 14. By \ncontrast, the three instance variables on lines 3 and 4 are available in all instance methods. \nAdditionally, the variables on lines 6, 9, and 10 are available since the method and while\nloop are still in scope. This is a total of 7 variables, which is option F.\n"
  },
  {
    "id": "oca-7",
    "question": "Which are true about this code? (Choose all that apply.)\n    public class KitchenSink {\n        private int numForks;\n \n        public static void main(String[] args) {\n           int numKnives;\n           System.out.print(\"\"\"\n              \"# forks = \" + numForks +\n               \" # knives = \" + numKnives +\n              # cups = 0\"\"\");\n        }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "The output includes: # forks = 0."
      },
      {
        "key": "B",
        "text": "The output includes: # knives = 0."
      },
      {
        "key": "C",
        "text": "The output includes: # cups = 0."
      },
      {
        "key": "D",
        "text": "The output includes a blank line."
      },
      {
        "key": "E",
        "text": "The output includes one or more lines that begin with whitespace."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The first thing to recognize is that this is a text block and the code inside the \"\"\" is \njust text. Options A and B are incorrect because the numForks and numKnives variables \nare not used. This is convenient since numKnives is not initialized and would not compile if \nit were referenced. Option C is correct as it is matching text. Option D is incorrect because \nthe text block does not have a trailing blank line. Finally, option E is also an answer since \n\" # knives is indented.\n"
  },
  {
    "id": "oca-8",
    "question": "Which of the following code snippets about var compile without issue when used in a \nmethod? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "var spring = null;"
      },
      {
        "key": "B",
        "text": "var fall = \"leaves\";"
      },
      {
        "key": "C",
        "text": "var evening = 2; evening = null;"
      },
      {
        "key": "D",
        "text": "var night = Integer.valueOf(3);"
      },
      {
        "key": "E",
        "text": "var day = 1/0;"
      },
      {
        "key": "F",
        "text": "var winter = 12, cold;"
      },
      {
        "key": "G",
        "text": "var fall = 2, autumn = 2;"
      },
      {
        "key": "H",
        "text": "var morning = \"\"; morning = null;"
      }
    ],
    "answer": [
      "B",
      "D",
      "E",
      "H"
    ],
    "explanation": "A var cannot be initialized with a null value without a type, but it can be \nassigned a null value later if the underlying type is not a primitive. For these reasons, option \nH is correct, but options A and C are incorrect. Options B and D are correct as the under\u0002lying types are String and Integer, respectively. Option E is correct as this is a valid \nnumeric expression. You might know that dividing by zero produces a runtime exception, but \nthe question was only about whether the code compiled. Finally, options F and G are incor\u0002rect as var cannot be used in a multiple-variable assignment.\n"
  },
  {
    "id": "oca-9",
    "question": "Which of the following are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An instance variable of type float defaults to 0."
      },
      {
        "key": "B",
        "text": "An instance variable of type char defaults to null."
      },
      {
        "key": "C",
        "text": "A local variable of type double defaults to 0.0."
      },
      {
        "key": "D",
        "text": "A local variable of type int defaults to null."
      },
      {
        "key": "E",
        "text": "A class variable of type String defaults to null."
      },
      {
        "key": "F",
        "text": "A class variable of type String defaults to the empty string \"\"."
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Options C and D are incorrect because local variables don’t have default values. Option A \nis incorrect because float should have a decimal point. Option B is incorrect because prim\u0002itives do not default to null. Option E is correct and option F incorrect because reference \ntypes in class variables default to null.\n"
  },
  {
    "id": "oca-10",
    "question": "Which of the following expressions, when inserted independently into the blank line, allow \nthe code to compile? (Choose all that apply.)\n    public void printMagicData() {\n       var magic = ;\n       System.out.println(magic);\n    }",
    "choices": [
      {
        "key": "A",
        "text": "3_1"
      },
      {
        "key": "B",
        "text": "1_329_.0"
      },
      {
        "key": "C",
        "text": "3_13.0_"
      },
      {
        "key": "D",
        "text": "5_291._2"
      },
      {
        "key": "E",
        "text": "2_234.0_0"
      },
      {
        "key": "F",
        "text": "9___6"
      },
      {
        "key": "G",
        "text": "_1_3_5_0"
      }
    ],
    "answer": [
      "A",
      "E",
      "F"
    ],
    "explanation": "An underscore (_) can be placed in any numeric literal, as long as it is not at the \nbeginning, at the end, or next to a decimal point (.). Underscores can even be placed next to \neach other. For these reasons, options A, E, and F are correct. Options B and D are incorrect \nas the underscore (_) is next to a decimal point (.). Options C and G are incorrect because \nan underscore (_) cannot be placed at the beginning or end of the literal.\n"
  },
  {
    "id": "oca-11",
    "question": "Given the following two class files, what is the maximum number of imports that can be \nremoved and have the code still compile?\n    // Water.java\n    package aquarium;\n    public class Water { }\n \n    // Tank.java\n    package aquarium;\n    import java.lang.*;\n    import java.lang.System;\n    import aquarium.Water;\n    import aquarium.*;\n    public class Tank {\n       public void print(Water water) {\n       System.out.println(water); } }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The first two imports can be removed because java.lang is automatically imported. The \nfollowing two imports can be removed because Tank and Water are in the same package, \nmaking the correct option E. If Tank and Water were in different packages, exactly one of \nthese two imports could be removed. In that case, the answer would be option D.\n"
  },
  {
    "id": "oca-12",
    "question": "Which statements about the following class are correct? (Choose all that apply.)\n    1: public class ClownFish {\n    2:    int gills = 0, double weight=2;\n    3:    { int fins = gills; }\n    4:    void print(int length = 3) {\n    5:       System.out.println(gills);\n    6:       System.out.println(weight);\n    7:       System.out.println(fins);\n    8:       System.out.println(length);\n    9: } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 2 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 4 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "E",
        "text": "The code prints 0."
      },
      {
        "key": "F",
        "text": "The code prints 2.0."
      },
      {
        "key": "G",
        "text": "The code prints 2."
      },
      {
        "key": "H",
        "text": "The code prints 3."
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Line 2 does not compile as only one type should be specified, making option A \ncorrect. Line 3 compiles without issue as it declares a local variable inside an instance initial\u0002izer that is never used. Line 4 does not compile because Java does not support setting default \nmethod parameter values, making option C correct. Finally, line 7 does not compile because \nfins is in scope and accessible only inside the instance initializer on line 3, making option \nD correct.\n"
  },
  {
    "id": "oca-13",
    "question": "Given the following classes, which of the following snippets can independently be inserted in \nplace of INSERT IMPORTS HERE and have the code compile? (Choose all that apply.)\n    package aquarium;\n    public class Water {\n       boolean salty = false;\n    }\n \n    package aquarium.jellies;\n    public class Water {\n       boolean salty = true;\n    }\n \n    package employee;\n    INSERT IMPORTS HERE\n    public class WaterFiller {\n       Water water;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.Water;\nimport aquarium.jellies.*;"
      },
      {
        "key": "C",
        "text": "import aquarium.*;\nimport aquarium.jellies.Water;"
      },
      {
        "key": "D",
        "text": "import aquarium.*;\nimport aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.Water;\nimport aquarium.jellies.Water;"
      },
      {
        "key": "F",
        "text": "None of these imports can make the code compile."
      }
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Option A is correct because it imports all the classes in the aquarium package \nincluding aquarium.Water. Options B and C are correct because they import Water by \nclass name. Since importing by class name takes precedence over wildcards, these compile. \nOption D is incorrect because Java doesn’t know which of the two wildcard Water classes to \nuse. Option E is incorrect because you cannot specify the same class name in two imports.\n"
  },
  {
    "id": "oca-14",
    "question": "Which of the following statements about the code snippet are true? (Choose all that apply.)\n    3: short numPets = 5L;\n    4: int numGrains = 2.0;\n    5: String name = \"Scruffy\";\n    6: int d = numPets.length();\n    7: int e = numGrains.length;\n    8: int f = name.length();",
    "choices": [
      {
        "key": "A",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 4 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 5 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "F",
        "text": "Line 8 generates a compiler error."
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "Line 3 does not compile because the L suffix makes the literal value a long, \nwhich cannot be stored inside a short directly, making option A correct. Line 4 does not \ncompile because int is an integral type, but 2.0 is a double literal value, making option B \ncorrect. Line 5 compiles without issue. Lines 6 and 7 do not compile because numPets and \nnumGrains are both primitives, and you can call methods only on reference types, not prim\u0002itive values, making options D and E correct, respectively. Finally, line 8 compiles because \nthere is a length() method defined on String.\n"
  },
  {
    "id": "oca-15",
    "question": "Which of the following statements about garbage collection are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Calling System.gc() is guaranteed to free up memory by destroying objects eligible \nfor garbage collection."
      },
      {
        "key": "B",
        "text": "Garbage collection runs on a set schedule."
      },
      {
        "key": "C",
        "text": "Garbage collection allows the JVM to reclaim memory for other objects."
      },
      {
        "key": "D",
        "text": "Garbage collection runs when your program has used up half the available memory."
      },
      {
        "key": "E",
        "text": "An object may be eligible for garbage collection but never removed from the heap."
      },
      {
        "key": "F",
        "text": "An object is eligible for garbage collection once no references to it are accessible in the \nprogram."
      },
      {
        "key": "G",
        "text": "Marking a variable final means its associated object will never be garbage collected."
      }
    ],
    "answer": [
      "C",
      "E",
      "F"
    ],
    "explanation": "In Java, there are no guarantees about when garbage collection will run. The JVM \nis free to ignore calls to System.gc(). For this reason, options A, B, and D are incorrect. \nOption C is correct as the purpose of garbage collection is to reclaim used memory. Option \nE is also correct that an object may never be garbage collected, such as if the program ends \n\nbefore garbage collection runs. Option F is correct and is the primary means by which gar\u0002bage collection algorithms determine whether an object is eligible for garbage collection. \nFinally, option G is incorrect as marking a variable final means it is constant within its \nown scope. For example, a local variable marked final will be eligible for garbage collec\u0002tion after the method ends, assuming there are no other references to the object that exist \noutside the method.\n"
  },
  {
    "id": "oca-16",
    "question": "Which are true about this code? (Choose all that apply.)\n    var blocky = \"\"\"\n       squirrel \\s\n       pigeon   \\\n       termite\"\"\";\n    System.out.print(blocky);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs two lines."
      },
      {
        "key": "B",
        "text": "It outputs three lines."
      },
      {
        "key": "C",
        "text": "It outputs four lines."
      },
      {
        "key": "D",
        "text": "There is one line with trailing whitespace."
      },
      {
        "key": "E",
        "text": "There are two lines with trailing whitespace."
      },
      {
        "key": "F",
        "text": "If we indented each line five characters, it would change the output."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Option A is correct. There are two lines. One starts with squirrel, and the other \nstarts with pigeon. Remember that a backslash means to skip the line break. Option D \nis also correct as \\s means to keep whitespace. In a text block, incidental indentation is \nignored, making option F incorrect.\n"
  },
  {
    "id": "oca-17",
    "question": "What lines are printed by the following program? (Choose all that apply.)\n    1:  public class WaterBottle {\n    2:     private String brand;\n    3:     private boolean empty;\n    4:     public static float code;\n    5:     public static void main(String[] args) {\n    6:        WaterBottle wb = new WaterBottle();\n    7:        System.out.println(\"Empty = \" + wb.empty);\n    8:        System.out.println(\"Brand = \" + wb.brand);\n    9:        System.out.println(\"Code = \" + code);\n    10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 8 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 9 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Empty ="
      },
      {
        "key": "D",
        "text": "Empty = false"
      },
      {
        "key": "E",
        "text": "Brand ="
      },
      {
        "key": "F",
        "text": "Brand = null"
      },
      {
        "key": "G",
        "text": "Code = 0.0"
      },
      {
        "key": "H",
        "text": "Code = 0f"
      }
    ],
    "answer": [
      "D",
      "F",
      "G"
    ],
    "explanation": "The code compiles and runs without issue, so options A and B are incorrect. A \nboolean field initializes to false, making option D correct with Empty = false being \nprinted. Object references initialize to null, not the empty String, so option F is correct \nwith Brand = null being printed. Finally, the default value of floating-point numbers is 0.0.\nAlthough float values can be declared with an f suffix, they are not printed with an f\nsuffix. For these reasons, option G is correct and Code = 0.0 is printed.\n"
  },
  {
    "id": "oca-18",
    "question": "Which of the following statements about var are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A var can be used as a constructor parameter."
      },
      {
        "key": "B",
        "text": "The type of a var is known at compile time."
      },
      {
        "key": "C",
        "text": "A var cannot be used as an instance variable."
      },
      {
        "key": "D",
        "text": "A var can be used in a multiple variable assignment statement."
      },
      {
        "key": "E",
        "text": "The value of a var cannot change at runtime."
      },
      {
        "key": "F",
        "text": "The type of a var cannot change at runtime."
      },
      {
        "key": "G",
        "text": "The word var is a reserved word in Java."
      }
    ],
    "answer": [
      "B",
      "C",
      "F"
    ],
    "explanation": "A var cannot be used for a constructor or method parameter or for an instance or \nclass variable, making option A incorrect and option C correct. The type of a var is known \nat compile-time, and the type cannot be changed at runtime, although its value can change \nat runtime. For these reasons, options B and F are correct, and option E is incorrect. Option \nD is incorrect, as var is not permitted in multiple-variable declarations. Finally, option G is \nincorrect, as var is not a reserved word in Java.\n"
  },
  {
    "id": "oca-19",
    "question": "Which are true about the following code? (Choose all that apply.)\n    var num1 = Long.parseLong(\"100\");\n    var num2 = Long.valueOf(\"100\");\n    System.out.println(Long.max(num1, num2));",
    "choices": [
      {
        "key": "A",
        "text": "The output is 100."
      },
      {
        "key": "B",
        "text": "The output is 200."
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "num1 is a primitive."
      },
      {
        "key": "E",
        "text": "num2 is a primitive."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The first two lines provide a way to convert a String into a number. The first is \na long primitive and the second is a Long reference object, making option D one of the \nanswers. The code is correct and the maximum is 100, which is option A.\n"
  },
  {
    "id": "oca-20",
    "question": "Which statements about the following class are correct? (Choose all that apply.)\n    1:  public class PoliceBox {\n    2:     String color;\n    3:     long age;\n    4:     public void PoliceBox() {\n    5:        color = \"blue\";\n    6:        age = 1200;\n    7:     }\n    8:     public static void main(String []time) {\n    9:        var p = new PoliceBox();\n    10:       var q = new PoliceBox();\n    11:       p.color = \"green\";\n    12:       p.age = 1400;\n    13:       p = q;\n    14:       System.out.println(\"Q1=\"+q.color);\n    15:       System.out.println(\"Q2=\"+q.age);\n    16:       System.out.println(\"P1=\"+p.color);\n    17:       System.out.println(\"P2=\"+p.age);\n    18: } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints Q1=blue."
      },
      {
        "key": "B",
        "text": "It prints Q2=1200."
      },
      {
        "key": "C",
        "text": "It prints P1=null."
      },
      {
        "key": "D",
        "text": "It prints P2=1400."
      },
      {
        "key": "E",
        "text": "Line 4 does not compile."
      },
      {
        "key": "F",
        "text": "Line 12 does not compile."
      },
      {
        "key": "G",
        "text": "Line 13 does not compile."
      },
      {
        "key": "H",
        "text": "None of the above."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The key thing to notice is that line 4 does not define a constructor, but instead a method \nnamed PoliceBox(), since it has a return type of void. This method is never executed \nduring the program run, and color and age are assigned the default values null and 0L, \nrespectively. Lines 11 and 12 change the values for an object associated with p, but then, on \nline 13, the p variable is changed to point to the object associated with q, which still has the \ndefault values. For this reason, the program prints Q1=null, Q2=0, P1=null, and P2=0, \nmaking option C the only correct answer.\n"
  },
  {
    "id": "oca-21",
    "question": "What is the output of executing the following class?\n    1:  public class Salmon {\n    2:     int count;\n    3:     { System.out.print(count+\"- \"); }\n    4:     { count++; }\n    5:     public Salmon() {\n    6:        count = 4;\n    7:        System.out.print(2+\"- \");\n    8:     }\n    9:     public static void main(String[] args) {\n    10:       System.out.print(7+\"- \");\n    11:       var s = new Salmon();\n    12:       System.out.print(s.count+\"- \"); } }",
    "choices": [
      {
        "key": "A",
        "text": "7- 0- 2- 1- "
      },
      {
        "key": "B",
        "text": "7- 0- 1- "
      },
      {
        "key": "C",
        "text": "0- 7- 2- 1- "
      },
      {
        "key": "D",
        "text": "7- 0- 2- 4- "
      },
      {
        "key": "E",
        "text": "0- 7- 1- "
      },
      {
        "key": "F",
        "text": "The class does not compile because of line 3."
      },
      {
        "key": "G",
        "text": "The class does not compile because of line 4."
      },
      {
        "key": "H",
        "text": "None of the above."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "We start with the main() method, which prints 7- on line 10. Next, a new Salmon\ninstance is created on line 11. This calls the two instance initializers on lines 3 and 4 to be \nexecuted in order. The default value of an instance variable of type int is 0, so 0- is printed \nnext and count is assigned a value of 1. Next, the constructor is called. This assigns a value \nof 4 to count and prints 2-. Finally, line 12 prints 4-, since that is the value of count. \nPutting it all together, we have 7-0-2-4-, making option D the correct answer.\n"
  },
  {
    "id": "oca-22",
    "question": "Given the following class, which of the following lines of code can independently replace \nINSERT CODE HERE to make the code compile? (Choose all that apply.)\n    public class Price {\n       public void admission() {\n          INSERT CODE HERE\n          System.out.print(amount);\n          } }",
    "choices": [
      {
        "key": "A",
        "text": "int Amount = 0b11;"
      },
      {
        "key": "B",
        "text": "int amount = 9L;"
      },
      {
        "key": "C",
        "text": "int amount = 0xE;"
      },
      {
        "key": "D",
        "text": "int amount = 1_2.0;"
      },
      {
        "key": "E",
        "text": "double amount = 1_0_.0;"
      },
      {
        "key": "F",
        "text": "int amount = 0b101;"
      },
      {
        "key": "G",
        "text": "double amount = 9_2.1_2;"
      },
      {
        "key": "H",
        "text": "double amount = 1_2_.0_0;"
      }
    ],
    "answer": [
      "C",
      "F",
      "G"
    ],
    "explanation": "First, 0b is the prefix for a binary value, and 0x is the prefix for a hexadecimal \nvalue. These values can be assigned to many primitive types, including int and double, \nmaking options C and F correct. Option A is incorrect because naming the variable Amount\nwill cause the System.out.print(amount) call on the next line to not compile. Option \nB is incorrect because 9L is a long value. If the type was changed to long amount = 9L, \nthen it would compile. Option D is incorrect because 1_2.0 is a double value. If the type \nwas changed to double amount = 1_2.0, then it would compile. Options E and H are \nincorrect because the underscore (_) appears next to the decimal point (.), which is not \nallowed. Finally, option G is correct, and the underscore and assignment usage are valid.\n"
  },
  {
    "id": "oca-23",
    "question": "Which statements about the following class are true? (Choose all that apply.)\n    1:  public class River {\n    2:     int Depth = 1;\n    3:     float temp = 50.0;\n    4:     public void flow() {\n    5:        for (int i = 0; i < 1; i++) {\n    6:           int depth = 2;\n    7:           depth++;\n    8:           temp- - ;\n    9:        }\n    10:       System.out.println(depth);\n    11:       System.out.println(temp); }\n    12:    public static void main(String... s) {\n    13:       new River().flow();\n    14: } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 3 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 10 generates a compiler error."
      },
      {
        "key": "E",
        "text": "The program prints 3 on line 10."
      },
      {
        "key": "F",
        "text": "The program prints 4 on line 10."
      },
      {
        "key": "G",
        "text": "The program prints 50.0 on line 11."
      },
      {
        "key": "H",
        "text": "The program prints 49.0 on line 11."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The first compiler error is on line 3. The variable temp is declared as a float, but the \nassigned value is 50.0, which is a double without the F/f postfix. Since a double doesn’t \nfit inside a float, line 3 does not compile. Next, depth is declared inside the for loop and \nonly has scope inside this loop. Therefore, reading the value on line 10 triggers a compiler \nerror. For these reasons, options A and D are the correct answers.\n"
  },
  {
    "id": "oca-24",
    "question": "Which of the following Java operators can be used with boolean variables? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "=="
      },
      {
        "key": "B",
        "text": "+"
      },
      {
        "key": "C",
        "text": "- - "
      },
      {
        "key": "D",
        "text": "!"
      },
      {
        "key": "E",
        "text": "%"
      },
      {
        "key": "F",
        "text": "~"
      },
      {
        "key": "G",
        "text": "Cast with (boolean)"
      }
    ],
    "answer": [
      "A",
      "D",
      "G"
    ],
    "explanation": "Option A is the equality operator and can be used on primitives and object refer\u0002ences. Options B and C are both arithmetic operators and cannot be applied to a boolean\nvalue. Option D is the logical complement operator and is used exclusively with boolean\nvalues. Option E is the modulus operator, which can be used only with numeric primitives. \nOption F is a bitwise complement operator and can only be applied to integer values. Finally, \noption G is correct, as you can cast a boolean variable since boolean is a type.\n"
  },
  {
    "id": "oca-25",
    "question": "What data type (or types) will allow the following code snippet to compile? (Choose all \nthat apply.)\n    byte apples = 5;\n    short oranges = 10;\n    _____ bananas = apples + oranges;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "long"
      },
      {
        "key": "C",
        "text": "boolean"
      },
      {
        "key": "D",
        "text": "double"
      },
      {
        "key": "E",
        "text": "short"
      },
      {
        "key": "F",
        "text": "byte"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "The expression apples + oranges is automatically promoted to int, so int and \ndata types that can be promoted automatically from int will work. Options A, B, and D \nare such data types. Option C will not work because boolean is not a numeric data type. \nOptions E and F will not work without an explicit cast to a smaller data type.\n"
  },
  {
    "id": "oca-26",
    "question": "What change, when applied independently, would allow the following code snippet to  \ncompile? (Choose all that apply.)\n    3: long ear = 10;\n    4: int hearing = 2 * ear;",
    "choices": [
      {
        "key": "A",
        "text": "No change; it compiles as is."
      },
      {
        "key": "B",
        "text": "Cast ear on line 4 to int."
      },
      {
        "key": "C",
        "text": "Change the data type of ear on line 3 to short."
      },
      {
        "key": "D",
        "text": "Cast 2 * ear on line 4 to int."
      },
      {
        "key": "E",
        "text": "Change the data type of hearing on line 4 to short."
      },
      {
        "key": "F",
        "text": "Change the data type of hearing on line 4 to long."
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The code will not compile as is, so option A is not correct. The value 2 * ear is \nautomatically promoted to long and cannot be automatically stored in hearing, which is \nan int value. Options B, C, and D solve this problem by reducing the long value to int. \nOption E does not solve the problem and actually makes it worse by attempting to place the \nvalue in a smaller data type. Option F solves the problem by increasing the data type of the \nassignment so that long is allowed.\n"
  },
  {
    "id": "oca-27",
    "question": "What is the output of the following code snippet?\n    3: boolean canine = true, wolf = true;\n    4: int teeth = 20;\n    5: canine = (teeth != 10) ^ (wolf=false);\n    6: System.out.println(canine+\", \"+teeth+\", \"+wolf);",
    "choices": [
      {
        "key": "A",
        "text": "true, 20, true"
      },
      {
        "key": "B",
        "text": "true, 20, false"
      },
      {
        "key": "C",
        "text": "false, 10, true"
      },
      {
        "key": "D",
        "text": "false, 20, false"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The code compiles and runs without issue, so option E is not correct. This example \nis tricky because of the second assignment operator embedded in line 5. The expression \n(wolf=false) assigns the value false to wolf and returns false for the entire expres\u0002sion. Since teeth does not equal 10, the left side returns true; therefore, the exclusive or \n(^) of the entire expression assigned to canine is true. The output reflects these assign\u0002ments, with no change to teeth, so option B is the only correct answer.\n"
  },
  {
    "id": "oca-28",
    "question": "Which of the following operators are ranked in increasing or the same order of precedence? \nAssume the + operator is binary addition, not the unary form. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "+, *, %, - - "
      },
      {
        "key": "B",
        "text": "++, (int), *"
      },
      {
        "key": "C",
        "text": "=, ==, !"
      },
      {
        "key": "D",
        "text": "(short), =, !, *"
      },
      {
        "key": "E",
        "text": "*, /, %, +, =="
      },
      {
        "key": "F",
        "text": "!, ||, &"
      },
      {
        "key": "G",
        "text": "^, +, =, +="
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "Options A and C show operators in increasing or the same order of precedence. \nOptions B and E are in decreasing or the same order of precedence. Options D, F, and G are \nin neither increasing nor decreasing order of precedence. In option D, the assignment oper\u0002ator (=) is between two unary operators, with the multiplication operator (*) incorrectly \nbeing in place of highest precedence. In option F, the logical complement operator (!) has the \nhighest order of precedence, so it should be last. In option G, the assignment operators have \nthe lowest order of precedence, not the highest, so the last two operators should be first.\n"
  },
  {
    "id": "oca-29",
    "question": "What is the output of the following program?\n    1: public class CandyCounter {\n    2:    static long addCandy(double fruit, float vegetables) {\n    3:       return (int)fruit+vegetables;\n    4:    }\n    5:    \n    6:    public static void main(String[] args) {\n    7:       System.out.print(addCandy(1.4, 2.4f) + \", \");\n    8:       System.out.print(addCandy(1.9, (float)4) + \", \");\n    9:       System.out.print(addCandy((long)(int)(short)2, (float)4)); } }",
    "choices": [
      {
        "key": "A",
        "text": "4, 6, 6.0"
      },
      {
        "key": "B",
        "text": "3, 5, 6"
      },
      {
        "key": "C",
        "text": "3, 6, 6"
      },
      {
        "key": "D",
        "text": "4, 5, 6"
      },
      {
        "key": "E",
        "text": "The code does not compile because of line 9."
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because line 3 contains a compilation error. The cast (int)\nis applied to fruit, not the expression fruit+vegetables. Since the cast operator has \na higher operator precedence than the addition operator, it is applied to fruit, but the \nexpression is promoted to a float, due to vegetables being float. The result cannot \nbe returned as long in the addCandy() method without a cast. For this reason, option F is \ncorrect. If parentheses were added around fruit+vegetables, then the output would be \n3, 5, 6, and option B would be correct. Remember that casting floating-point numbers to \nintegral values results in truncation, not rounding.\n"
  },
  {
    "id": "oca-30",
    "question": "What is the output of the following code snippet?\n    int ph = 7, vis = 2;\n    boolean clear = vis > 1 & (vis < 9 || ph < 2);\n    boolean safe = (vis > 2) && (ph++ > 1);\n    boolean tasty = 7 <= - - ph;\n    System.out.println(clear + \"- \" + safe + \"- \" + tasty);",
    "choices": [
      {
        "key": "A",
        "text": "true- true- true"
      },
      {
        "key": "B",
        "text": "true- true- false"
      },
      {
        "key": "C",
        "text": "true- false- true"
      },
      {
        "key": "D",
        "text": "true- false- false"
      },
      {
        "key": "E",
        "text": "false- true- true"
      },
      {
        "key": "F",
        "text": "false- true- false"
      },
      {
        "key": "G",
        "text": "false- false- true"
      },
      {
        "key": "H",
        "text": "false- false- false"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "In the first boolean expression, vis is 2 and ph is 7, so this expression evaluates to \ntrue & (true || false), which reduces to true. The second boolean expression \nuses the conditional operator, and since (vis > 2) is false, the right side is not evaluated, \nleaving ph at 7. In the last assignment, ph is 7, and the pre-decrement operator is applied \nfirst, reducing the expression to 7 <= 6 and resulting in an assignment of false. For these \nreasons, option D is the correct answer.\n"
  },
  {
    "id": "oca-31",
    "question": "What is the output of the following code snippet?\n    4: int pig = (short)4;\n    5: pig = pig++;\n    6: long goat = (int)2;\n    7: goat - = 1.0;\n    8: System.out.print(pig + \" -  \" + goat);",
    "choices": [
      {
        "key": "A",
        "text": "4 -  1"
      },
      {
        "key": "B",
        "text": "4 -  2"
      },
      {
        "key": "C",
        "text": "5 -  1"
      },
      {
        "key": "D",
        "text": "5 -  2"
      },
      {
        "key": "E",
        "text": "The code does not compile due to line 7."
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so option E is incorrect. Line 7 does not \nproduce a compilation error since the compound operator applies casting automatically. \nLine 5 increments pig by 1, but it returns the original value of 4 since it is using the post\u0002increment operator. The pig variable is then assigned this value, and the increment operation \nis discarded. Line 7 just reduces the value of goat by 1, resulting in an output of 4 - 1 and \nmaking option A the correct answer.\n"
  },
  {
    "id": "oca-32",
    "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)\n    int a = 2, b = 4, c = 2;\n    System.out.println(a > 2 ? - - c : b++);\n    System.out.println(b = (a!=c ? a : b++));\n    System.out.println(a > b ? b < c ? b : 2 : 1);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "The code compiles without issue, so option G is incorrect. In the first expression, \na > 2 is false, so b is incremented to 5; but since the post-increment operator is used, \n4 is printed, making option D correct. The --c was not applied, because only one of the \nright-hand expressions was evaluated. In the second expression, a!=c is false since c was \nnever modified. Since b is 5 due to the previous line and the post-increment operator is used, \nb++ returns 5. The result is then assigned to b using the assignment operator, overriding \nthe incremented value for b and printing 5, making option E correct. In the last expression, \nparentheses are not required, but lack of parentheses can make ternary expressions difficult \nto read. From the previous lines, a is 2, b is 5, and c is 2. We can rewrite this expression \nwith parentheses as (2 > 5 ? (5 < 2 ? 5 : 2) : 1). The second ternary expres\u0002sion is never evaluated since 2 > 5 is false, and the expression returns 1, making option \nA correct.\n"
  },
  {
    "id": "oca-33",
    "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)\n    short height = 1, weight = 3;\n    short zebra = (byte) weight * (byte) height;\n    double ox = 1 + height * 2 + weight;\n    long giraffe = 1 + 9 % height + 1;\n    System.out.println(zebra);\n    System.out.println(ox);\n    System.out.println(giraffe);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code does not compile due to an error on the second line. Even though both height\nand weight are cast to byte, the multiplication operator automatically promotes them to \nint, resulting in an attempt to store an int in a short variable. For this reason, the code \ndoes not compile, and option G is the only correct answer. This line contains the only compi\u0002lation error.\n"
  },
  {
    "id": "oca-34",
    "question": "What is the output of the following code?\n    11: int sample1 = (2 * 4) % 3;\n    12: int sample2 = 3 * 2 % 3;\n    13: int sample3 = 5 * (1 % 2);\n    14: System.out.println(sample1 + \", \" + sample2 + \", \" + sample3);",
    "choices": [
      {
        "key": "A",
        "text": "0, 0, 5"
      },
      {
        "key": "B",
        "text": "1, 2, 10"
      },
      {
        "key": "C",
        "text": "2, 1, 5"
      },
      {
        "key": "D",
        "text": "2, 0, 5"
      },
      {
        "key": "E",
        "text": "3, 1, 10"
      },
      {
        "key": "F",
        "text": "3, 2, 6"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "First, * and % have the same operator precedence, so the expression is evaluated from left \nto right unless parentheses are present. The first expression evaluates to 8 % 3, which leaves \na remainder of 2. The second expression is evaluated left to right since * and % have the \nsame operator precedence, and it reduces to 6 % 3, which is 0. The last expression reduces \nto 5 * 1, which is 5. Therefore, the output on line 14 is 2, 0, 5, making option D the \ncorrect answer.\n"
  },
  {
    "id": "oca-35",
    "question": "The _________ operator increases a value and returns the original value, while the _______ \noperator decreases a value and returns the new value.",
    "choices": [
      {
        "key": "A",
        "text": "post- increment, post- increment"
      },
      {
        "key": "B",
        "text": "pre- decrement, post- decrement"
      },
      {
        "key": "C",
        "text": "post- increment, post- decrement"
      },
      {
        "key": "D",
        "text": "post- increment, pre- decrement"
      },
      {
        "key": "E",
        "text": "pre- increment, pre- decrement"
      },
      {
        "key": "F",
        "text": "pre- increment, post- decrement"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The pre- prefix indicates the operation is applied first, and the new value is returned, \nwhile the post- prefix indicates the original value is returned prior to the operation. Next, \nincrement increases the value, while decrement decreases the value. For these reasons, option \nD is the correct answer.\n"
  },
  {
    "id": "oca-36",
    "question": "What is the output of the following code snippet?\n    boolean sunny = true, raining = false, sunday = true;\n    boolean goingToTheStore = sunny & raining ^ sunday;\n    boolean goingToTheZoo = sunday && !raining;\n    boolean stayingHome = !(goingToTheStore && goingToTheZoo);\n    System.out.println(goingToTheStore + \"- \" + goingToTheZoo \n       + \"- \" +stayingHome);",
    "choices": [
      {
        "key": "A",
        "text": "true- false- false"
      },
      {
        "key": "B",
        "text": "false- true- false"
      },
      {
        "key": "C",
        "text": "true- true- true"
      },
      {
        "key": "D",
        "text": "false- true- true"
      },
      {
        "key": "E",
        "text": "false- false- false"
      },
      {
        "key": "F",
        "text": "true- true- false"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The first expression is evaluated from left to right since the operator precedence of & and \n^ is the same, letting us reduce it to false ^ sunday, which is true, because sunday\nis true. In the second expression, we apply the negation operator (!) first, reducing the \nexpression to sunday && true, which evaluates to true. In the last expression, both vari\u0002ables are true, so they reduce to !(true && true), which further reduces to !true, aka \nfalse. For these reasons, option F is the correct answer.\n"
  },
  {
    "id": "oca-37",
    "question": "Which of the following statements are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The return value of an assignment operation expression can be void."
      },
      {
        "key": "B",
        "text": "The inequality operator (!=) can be used to compare objects."
      },
      {
        "key": "C",
        "text": "The equality operator (==) can be used to compare a boolean value with a numeric \nvalue."
      },
      {
        "key": "D",
        "text": "During runtime, the & and | operators may cause only the left side of the expression to \nbe evaluated."
      },
      {
        "key": "E",
        "text": "The return value of an assignment operation expression is the value of the newly \nassigned variable."
      },
      {
        "key": "F",
        "text": "In Java, 0 and false may be used interchangeably."
      },
      {
        "key": "G",
        "text": "The logical complement operator (!) cannot be used to flip numeric values."
      }
    ],
    "answer": [
      "B",
      "E",
      "G"
    ],
    "explanation": "The return value of an assignment operation in the expression is the same as the \nvalue of the newly assigned variable. For this reason, option A is incorrect, and option E is \ncorrect. Option B is correct, as the equality (==) and inequality (!=) operators can both be \nused with objects. Option C is incorrect, as boolean and numeric types are not comparable. \nFor example, you can’t say true == 3 without a compilation error. Option D is incorrect, \nas logical operators evaluate both sides of the expression. The (|) operator will cause both \nsides to be evaluated. Option F is incorrect, as Java does not accept numbers for boolean\nvalues. Finally, option G is correct, as you need to use the negation operator (-) to flip or \nnegate numeric values, not the logical complement operator (!).\n"
  },
  {
    "id": "oca-38",
    "question": "Which operators take three operands or values? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "="
      },
      {
        "key": "B",
        "text": "&&"
      },
      {
        "key": "C",
        "text": "*="
      },
      {
        "key": "D",
        "text": "? :"
      },
      {
        "key": "E",
        "text": "&"
      },
      {
        "key": "F",
        "text": "++"
      },
      {
        "key": "G",
        "text": "/"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The ternary operator is the only operator that takes three values, making option D the \nonly correct choice. Options A, B, C, E, and G are all binary operators. While they can be \nstrung together in longer expressions, each operation uses only two values at a time. Option \nF is a unary operator and takes only one value.\n"
  },
  {
    "id": "oca-39",
    "question": "How many lines of the following code contain compiler errors?\n    int note = 1 * 2 + (long)3;\n    short melody = (byte)(double)(note *= 2);\n    double song = melody;\n    float symphony = (float)((song == 1_000f) ? song * 2L : song);",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line contains a compilation error. The value 3 is cast to long. The 1 * 2 value \nis evaluated as int but promoted to long when added to the 3. Trying to store a long\nvalue in an int variable triggers a compiler error. The other lines do not contain any compi\u0002lation errors, as they store smaller values in larger or same-size data types, with lines 2 and 4 \nusing casting to do so. Since only one line does not compile, option B is correct.\n"
  },
  {
    "id": "oca-40",
    "question": "Given the following code snippet, what are the values of the variables after it is executed? \n(Choose all that apply.)\n    int ticketsTaken = 1;\n    int ticketsSold = 3;\n    ticketsSold += 1 + ticketsTaken++;\n    ticketsTaken *= 2;\n    ticketsSold += (long)1;",
    "choices": [
      {
        "key": "A",
        "text": "ticketsSold is 8."
      },
      {
        "key": "B",
        "text": "ticketsTaken is 2."
      },
      {
        "key": "C",
        "text": "ticketsSold is 6."
      },
      {
        "key": "D",
        "text": "ticketsTaken is 6."
      },
      {
        "key": "E",
        "text": "ticketsSold is 7."
      },
      {
        "key": "F",
        "text": "ticketsTaken is 4."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "The starting values of ticketsTaken and ticketsSold are 1 and 3, respectively. \nAfter the first compound assignment, ticketsTaken is incremented to 2. The \nticketsSold value is increased from 3 to 5; since the post-increment operator was used, \nthe value of ticketsTaken++ returns 1. On the next line, ticketsTaken is doubled to 4.\nOn the final line, ticketsSold is increased by 1 to 6. The final values of the variables \nare 4 and 6, for ticketsTaken and ticketsSold, respectively, making options C and F \nthe correct answers. Note the last line does not trigger a compilation error as the compound \noperator automatically casts the right-hand operand.\n"
  },
  {
    "id": "oca-41",
    "question": "Which of the following can be used to change the order of operation in an expression? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "[ ]"
      },
      {
        "key": "B",
        "text": "< >"
      },
      {
        "key": "C",
        "text": "( )"
      },
      {
        "key": "D",
        "text": "\\ /"
      },
      {
        "key": "E",
        "text": "{ }"
      },
      {
        "key": "F",
        "text": "\" \""
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Only parentheses, ( ), can be used to change the order of operation in an expression, \nmaking option C correct. The other operators, such as [ ], < >, and { }, cannot be used as \nparentheses in Java.\n"
  },
  {
    "id": "oca-42",
    "question": "What is the result of executing the following code snippet? (Choose all that apply.)\n    3: int start = 7;\n    4: int end = 4;\n    5: end += ++start;\n    6: start = (byte)(Byte.MAX_VALUE + 1);",
    "choices": [
      {
        "key": "A",
        "text": "start is 0."
      },
      {
        "key": "B",
        "text": "start is - 128."
      },
      {
        "key": "C",
        "text": "start is 127."
      },
      {
        "key": "D",
        "text": "end is 8."
      },
      {
        "key": "E",
        "text": "end is 11."
      },
      {
        "key": "F",
        "text": "end is 12."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "The code compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The code compiles and runs successfully, so options G and H are incorrect. On line 5, \nthe pre-increment operator is executed first, so start is incremented to 8, and the new value \nis returned as the right side of the expression. The value of end is computed by adding 8 to \n\nthe original value of 4, leaving a new value of 12 for end and making option F a correct \nanswer. On line 6, we are incrementing one past the maximum byte value. Due to overflow, \nthis will result in a negative number, making option B the correct answer. Even if you didn’t \nknow the maximum value of byte, you should have known the code compiles and runs and \nlooked for the answer for start with a negative number.\n"
  },
  {
    "id": "oca-43",
    "question": "Which of the following statements about unary operators are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Unary operators are always executed before any surrounding numeric binary or ternary \noperators."
      },
      {
        "key": "B",
        "text": "The -  operator can be used to flip a boolean value."
      },
      {
        "key": "C",
        "text": "The pre- increment operator (++) returns the value of the variable before the increment is \napplied."
      },
      {
        "key": "D",
        "text": "The post- decrement operator (- - ) returns the value of the variable before the decrement \nis applied."
      },
      {
        "key": "E",
        "text": "The ! operator cannot be used on numeric values."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "Unary operators have the highest order of precedence, making option A correct. The \nnegation operator (-) is used only for numeric values, while the logical complement oper\u0002ator (!) is used exclusively for boolean values. For these reasons, option B is incorrect, and \noption E is correct. Finally, the pre-increment/pre-decrement operators return the new value \nof the variable, while the post-increment/post-decrement operators return the original vari\u0002able. For these reasons, option C is incorrect, and option D is correct.\n"
  },
  {
    "id": "oca-44",
    "question": "What is the result of executing the following code snippet?\n    int myFavoriteNumber = 8;\n    int bird = ~myFavoriteNumber;\n    int plane = - myFavoriteNumber;\n    var superman = bird == plane ? 5 : 10;\n    System.out.println(bird + \",\" + plane + \",\" + - - superman);",
    "choices": [
      {
        "key": "A",
        "text": "- 7,- 8,9"
      },
      {
        "key": "B",
        "text": "- 7,- 8,10"
      },
      {
        "key": "C",
        "text": "- 8,- 8,4"
      },
      {
        "key": "D",
        "text": "- 8,- 8,5"
      },
      {
        "key": "E",
        "text": "- 9,- 8,9"
      },
      {
        "key": "F",
        "text": "- 9,- 8,10"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The bitwise complement of 8 can be found by multiplying the number by negative one \nand subtracting one, making -9 the value of bird. By contrast, plane is -8 because it \nnegates myFavoriteNumber. Since bird and plane are not the same, superman is \nassigned a value of 10. The pre-decrement operator takes superman, subtracts 1, and \nreturns the new value, printing 9. For this reason, option E is correct.\n"
  },
  {
    "id": "oca-45",
    "question": "Which of the following data types can be used in a switch expression? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "enum"
      },
      {
        "key": "B",
        "text": "int"
      },
      {
        "key": "C",
        "text": "Byte"
      },
      {
        "key": "D",
        "text": "long"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "char"
      },
      {
        "key": "G",
        "text": "var"
      },
      {
        "key": "H",
        "text": "double"
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E",
      "F",
      "G"
    ],
    "explanation": "A switch expression supports only the primitives int, byte, short, \nand char, along with their associated wrapper classes Integer, Byte, Short, and \nCharacter, respectively, making options B, C, and F correct and ruling out options D and \nH. It also supports enum and String, making options A and E correct. Finally, switch\nsupports var if the type can be resolved to a supported switch data type, making option \nG correct.\n"
  },
  {
    "id": "oca-46",
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    3: int temperature = 4;\n    4: long humidity = - temperature + temperature * 3;\n    5: if (temperature>=4)\n    6: if (humidity < 6) System.out.println(\"Too Low\");\n    7: else System.out.println(\"Just Right\");\n    8: else System.out.println(\"Too High\");",
    "choices": [
      {
        "key": "A",
        "text": "Too Low"
      },
      {
        "key": "B",
        "text": "Just Right"
      },
      {
        "key": "C",
        "text": "Too High"
      },
      {
        "key": "D",
        "text": "A NullPointerException is thrown at runtime."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The code compiles and runs without issue, so options D, E, and F are incorrect. Even \nthough two consecutive else statements on lines 7 and 8 look a little odd, they are associ\u0002ated with separate if statements on lines 5 and 6, respectively. The value of humidity on \nline 4 is equal to -4 + 12, which is 8. The first if statement evaluates to true on line 5, so \nline 6 is executed and evaluates to false. This causes the else statement on line 7 to run, \nprinting Just Right and making option B the correct answer.\n"
  },
  {
    "id": "oca-47",
    "question": "Which of the following data types are permitted on the right side of a for- each expression? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Double[][]"
      },
      {
        "key": "B",
        "text": "Object"
      },
      {
        "key": "C",
        "text": "Map"
      },
      {
        "key": "D",
        "text": "List"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "char[]"
      },
      {
        "key": "G",
        "text": "Exception"
      },
      {
        "key": "H",
        "text": "Set"
      }
    ],
    "answer": [
      "A",
      "D",
      "F",
      "H"
    ],
    "explanation": "A for-each loop supports arrays, making options A and F correct. For \nDouble[][], each element of the for-each loop would be a Double[]. A for-each loop also \nsupports classes that implement java.lang.Iterable. Although this includes many of \nthe Collections Framework classes, not all of them implement java.lang.Iterable. For \nthis reason, option C is incorrect, and options D and H are correct. Options B, E, and G are \nincorrect, as they do not implement java.lang.Iterable. Although a String is a list of \nordered characters, the class does not implement the required interface for a for-each loop.\n"
  },
  {
    "id": "oca-48",
    "question": "What is the output of calling printReptile(6)?\n    void printReptile(int category) {\n      var type = switch(category) {\n          case 1,2 - > \"Snake\";\n          case 3,4 - > \"Lizard\";\n          case 5,6 - > \"Turtle\";\n          case 7,8 - > \"Alligator\";\n       };\n       System.out.print(type);\n    }",
    "choices": [
      {
        "key": "A",
        "text": "Snake"
      },
      {
        "key": "B",
        "text": "Lizard"
      },
      {
        "key": "C",
        "text": "Turtle"
      },
      {
        "key": "D",
        "text": "Alligator"
      },
      {
        "key": "E",
        "text": "TurtleAlligator"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because the switch expression requires all possible case \nvalues to be handled, making option F correct. If a valid default statement was added, then \nthe code would compile and print Turtle at runtime. Unlike traditional switch statements, \nswitch expressions execute exactly one branch and do not use break statements between \ncase statements.\n"
  },
  {
    "id": "oca-49",
    "question": "What is the output of the following code snippet?\n     List<Integer> myFavoriteNumbers = new ArrayList<>();\n     myFavoriteNumbers.add(10);\n     myFavoriteNumbers.add(14);\n     for (var a : myFavoriteNumbers) {\n        System.out.print(a + \", \");\n        break;\n     } \n     for (int b : myFavoriteNumbers) {\n        continue;\n        System.out.print(b + \", \");\n     } \n     for (Object c : myFavoriteNumbers)\n        System.out.print(c + \", \");",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue but does not produce any output."
      },
      {
        "key": "B",
        "text": "10, 14,"
      },
      {
        "key": "C",
        "text": "10, 10, 14,"
      },
      {
        "key": "D",
        "text": "10, 10, 14, 10, 14,"
      },
      {
        "key": "E",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "F",
        "text": "Exactly two lines of code do not compile."
      },
      {
        "key": "G",
        "text": "Three or more lines of code do not compile."
      },
      {
        "key": "H",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The second for-each loop contains a continue followed by a print() statement. \nBecause the continue is not conditional and always included as part of the body of the for\u0002each loop, the print() statement is not reachable. For this reason, the print() statement \ndoes not compile. As this is the only compilation error, option E is correct. The other lines of \ncode compile without issue.\n"
  },
  {
    "id": "oca-50",
    "question": "Which statements about decision structures are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A for- each loop can be executed on any Collections Framework object."
      },
      {
        "key": "B",
        "text": "The body of a while loop is guaranteed to be executed at least once."
      },
      {
        "key": "C",
        "text": "The conditional expression of a for loop is evaluated before the first execution of the \nloop body."
      },
      {
        "key": "D",
        "text": "A switch expression that takes a String and assigns the result to a variable requires a \ndefault branch."
      },
      {
        "key": "E",
        "text": "The body of a do/while loop is guaranteed to be executed at least once."
      },
      {
        "key": "F",
        "text": "An if statement can have multiple corresponding else statements."
      }
    ],
    "answer": [
      "C",
      "D",
      "E"
    ],
    "explanation": "A for-each loop can be executed on any Collections object that implements \njava.lang.Iterable, such as List or Set, but not all Collections classes, such as Map, \nso option A is incorrect. The body of a do/while loop is executed one or more times, while \nthe body of a while loop is executed zero or more times, making option E correct and \noption B incorrect. The conditional expression of for loops is evaluated at the start of the \nloop execution, meaning the for loop may execute zero or more times, making option C \ncorrect. A switch expression that takes a String requires a default branch if the result \nis assigned to a variable, making option D correct. Finally, each if statement has at most one \nmatching else statement, making option F incorrect.\n"
  },
  {
    "id": "oca-51",
    "question": "Assuming weather is a well- formed nonempty array, which code snippet, when inserted \nindependently into the blank in the following code, prints all of the elements of weather? \n(Choose all that apply.)\n     private void print(int[] weather) {\n        for( ) {\n           System.out.println(weather[i]);\n        }\n     }",
    "choices": [
      {
        "key": "A",
        "text": "int i=weather.length; i>0; i- - "
      },
      {
        "key": "B",
        "text": "int i=0; i<=weather.length- 1; ++i"
      },
      {
        "key": "C",
        "text": "var w : weather"
      },
      {
        "key": "D",
        "text": "int i=weather.length- 1; i>=0; i- - "
      },
      {
        "key": "E",
        "text": "int i=0, int j=3; i<weather.length; ++i"
      },
      {
        "key": "F",
        "text": "int i=0; ++i<10 && i<weather.length;"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Option A is incorrect because on the first iteration, it attempts to access \nweather[weather.length] of the nonempty array, which causes an \nArrayIndexOutOfBoundsException to be thrown. Option B is correct and will print \nthe elements in order. Option C doesn’t compile as i is undefined in weather[i]. For this \nto work, the body of the for-each loop would have to be updated as well. Option D is also \ncorrect and is a common way to print the elements of an array in reverse order. Option E \ndoes not compile and is therefore incorrect. You can declare multiple elements in a for loop, \nbut the data type must be listed only once, such as in for(int i=0, j=3; ...). Finally, \noption F is incorrect because the first element of the array is skipped. Since the conditional \nexpression is checked before the loop is executed the first time, the first value of i used inside \nthe body of the loop will be 1.\n"
  },
  {
    "id": "oca-52",
    "question": "What is the output of calling printType(11)?\n    31: void printType(Object o) {\n    32:    if(o instanceof Integer bat) {\n    33:       System.out.print(\"int\");\n    34:    } else if(o instanceof Integer bat && bat < 10) {\n    35:       System.out.print(\"small int\");\n    36:    } else if(o instanceof Long bat || bat <= 20) {\n    37:       System.out.print(\"long\");\n    38:    } default {\n    39:       System.out.print(\"unknown\");\n    40:    }\n    41: }",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "small int"
      },
      {
        "key": "C",
        "text": "long"
      },
      {
        "key": "D",
        "text": "unknown"
      },
      {
        "key": "E",
        "text": "Nothing is printed."
      },
      {
        "key": "F",
        "text": "The code contains one line that does not compile."
      },
      {
        "key": "G",
        "text": "The code contains two lines that do not compile."
      },
      {
        "key": "H",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The first two pattern matching statements compile without issue. The variable bat is \nallowed to be used again, provided it is no longer in scope. Line 36 does not compile, \nthough. Due to flow scoping, if s is not a Long, then bat is not in scope in the expres\u0002sion bat <= 20. Line 38 also does not compile as default cannot be used as part of an \nif/else statement. For these two reasons, option G is correct.\n"
  },
  {
    "id": "oca-53",
    "question": "Which statements, when inserted independently into the following blank, will cause the code \nto print 2 at runtime? (Choose all that apply.)\n     int count = 0;\n     BUNNY: for(int row = 1; row <=3; row++)\n        RABBIT: for(int col = 0; col <3 ; col++) {\n           if((col + row) % 2 == 0)\n              ;\n           count++;\n        }\n     System.out.println(count);",
    "choices": [
      {
        "key": "A",
        "text": "break BUNNY"
      },
      {
        "key": "B",
        "text": "break RABBIT"
      },
      {
        "key": "C",
        "text": "continue BUNNY"
      },
      {
        "key": "D",
        "text": "continue RABBIT"
      },
      {
        "key": "E",
        "text": "break"
      },
      {
        "key": "F",
        "text": "continue"
      },
      {
        "key": "G",
        "text": "None of the above, as the code contains a compiler error."
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "The code contains a nested loop and a conditional expression that is executed if the \nsum of col + row is an even number; otherwise, count is incremented. Note that options \nE and F are equivalent to options B and D, respectively, since unlabeled statements apply to \nthe most inner loop. Studying the loops, the first time the condition is true is in the second \niteration of the inner loop, when row is 1 and col is 1. Option A is incorrect because this \ncauses the loop to exit immediately with count only being set to 1. Options B, C, and E \nfollow the same pathway. First, count is incremented to 1 on the first inner loop, and then \n\nthe inner loop is exited. On the next iteration of the outer loop, row is 2 and col is 0, so \nexecution exits the inner loop immediately. On the third iteration of the outer loop, row is 3\nand col is 0, so count is incremented to 2. In the next iteration of the inner loop, the sum \nis even, so we exit, and our program is complete, making options B, C, and E each correct. \nOptions D and F are both incorrect, as they cause the inner and outer loops to execute mul\u0002tiple times, with count having a value of 5 when done. You don’t need to trace through all \nthe iterations; just stop when the value of count exceeds 2.\n"
  },
  {
    "id": "oca-54",
    "question": "Given the following method, how many lines contain compilation errors? (Choose all \nthat apply.)\n    10: private DayOfWeek getWeekDay(int day, final int thursday) {\n    11:    int otherDay = day;\n    12:    int Sunday = 0;\n    13:    switch(otherDay) {\n    14:       default:\n    15:       case 1: continue; \n    16:       case thursday: return DayOfWeek.THURSDAY;\n    17:       case 2,10: break;\n    18:       case Sunday: return DayOfWeek.SUNDAY;\n    19:       case DayOfWeek.MONDAY: return DayOfWeek.MONDAY;\n    20:    }\n    21:    return DayOfWeek.FRIDAY;\n    22: }",
    "choices": [
      {
        "key": "A",
        "text": "None, the code compiles without issue."
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      },
      {
        "key": "G",
        "text": "6"
      },
      {
        "key": "H",
        "text": "The code compiles but may produce an error at runtime."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code contains numerous compilation errors, making options A and H incorrect. Line \n15 does not compile, as continue cannot be used inside a switch statement like this. Line \n16 is not a compile-time constant since any int value can be passed as a parameter. Mark\u0002ing it final does not change this, so it doesn’t compile. Line 18 does not compile because \nSunday is not marked as final. Being effectively final is insufficient. Finally, line 19 does \nnot compile because DayOfWeek.MONDAY is not an int value. While switch statements \ndo support enum values, each case statement must have the same data type as the switch\nvariable otherDay, which is int. The rest of the lines do compile. Since exactly four lines \ndo not compile, option E is the correct answer.\n"
  },
  {
    "id": "oca-55",
    "question": "What is the output of calling printLocation(Animal.MAMMAL)?\n    10: class Zoo {\n    11:    enum Animal {BIRD, FISH, MAMMAL}\n    12:    void printLocation(Animal a) {\n    13:       long type = switch(a) {\n    14:          case BIRD - > 1;\n    15:          case FISH - > 2;\n    16:          case MAMMAL - > 3;\n    17:          default - > 4;\n    18:       };\n    19:       System.out.print(type);\n    20:    } }",
    "choices": [
      {
        "key": "A",
        "text": "3"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "34"
      },
      {
        "key": "D",
        "text": "The code does not compile because of line 13."
      },
      {
        "key": "E",
        "text": "The code does not compile because of line 17."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, printing 3 at runtime and making option \nA correct. The default statement on line 17 is optional since all the enum values are \naccounted for and can be removed without changing the output.\n"
  },
  {
    "id": "oca-56",
    "question": "What is the result of the following code snippet?\n    3: int sing = 8, squawk = 2, notes = 0;\n    4: while(sing > squawk) {\n    5:    sing- - ;\n    6:    squawk += 2;\n    7:    notes += sing + squawk;\n    8: }\n    9: System.out.println(notes);",
    "choices": [
      {
        "key": "A",
        "text": "11"
      },
      {
        "key": "B",
        "text": "13"
      },
      {
        "key": "C",
        "text": "23"
      },
      {
        "key": "D",
        "text": "33"
      },
      {
        "key": "E",
        "text": "50"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 7."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Prior to the first iteration, sing = 8, squawk = 2, and notes = 0. After the itera\u0002tion of the first loop, sing is updated to 7, squawk to 4, and notes to the sum of the new \nvalues for sing + squawk, 7 + 4 = 11. After the iteration of the second loop, sing is \nupdated to 6, squawk to 6, and notes to the sum of itself plus the new values for \nsing + squawk, 11 + 6 + 6 = 23. On the third iteration of the loop, \nsing > squawk evaluates to false, as 6 > 6 is false. The loop ends and the most \nrecent value of sing, 23, is output, so the correct answer is option C.\n"
  },
  {
    "id": "oca-57",
    "question": "What is the output of the following code snippet?\n    2: boolean keepGoing = true;\n    3: int result = 15, meters = 10;\n    4: do {\n    5:    meters- - ;\n    6:    if(meters==8) keepGoing = false;\n    7:    result - = 2;\n    8: } while keepGoing;\n    9: System.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "11"
      },
      {
        "key": "E",
        "text": "15"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "G",
        "text": "The code does not compile for a different reason."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "This example may look complicated, but the code does not compile. Line 8 is missing the \nrequired parentheses around the boolean conditional expression. Since the code does not \ncompile and it is not because of line 6, option G is the correct answer. If line 8 was corrected \nwith parentheses, then the loop would be executed twice, and the output would be 11.\n"
  },
  {
    "id": "oca-58",
    "question": "Which statements about the following code snippet are correct? (Choose all that apply.)\n     for(var penguin : new int[2])\n        System.out.println(penguin); \n     var ostrich = new Character[3];\n     for(var emu : ostrich)\n        System.out.println(emu); \n     List<Integer> parrots = new ArrayList<Integer>();\n     for(var macaw  : parrots)\n        System.out.println(macaw);",
    "choices": [
      {
        "key": "A",
        "text": "The data type of penguin is Integer."
      },
      {
        "key": "B",
        "text": "The data type of penguin is int."
      },
      {
        "key": "C",
        "text": "The data type of emu is undefined."
      },
      {
        "key": "D",
        "text": "The data type of emu is Character."
      },
      {
        "key": "E",
        "text": "The data type of macaw is List."
      },
      {
        "key": "F",
        "text": "The data type of macaw is Integer."
      },
      {
        "key": "G",
        "text": "None of the above, as the code does not compile."
      }
    ],
    "answer": [
      "B",
      "D",
      "F"
    ],
    "explanation": "The code does compile, making option G incorrect. In the first for-each loop, the \nright side of the for-each loop has a type of int[], so each element penguin has a type \nof int, making option B correct. In the second for-each loop, ostrich has a type of \nCharacter[], so emu has a data type of Character, making option D correct. In the \nlast for-each loop, parrots has a data type of List<Integer>. Since the generic type \nof Integer is used in the List, macaw will have a data type of Integer, making option \nF correct.\n"
  },
  {
    "id": "oca-59",
    "question": "What is the result of the following code snippet?\n     final char a = 'A', e = 'E';\n     char grade = 'B';\n     switch (grade) {\n        default:\n        case a:\n        case 'B': 'C': System.out.print(\"great \");\n        case 'D': System.out.print(\"good \"); break;\n        case e:\n        case 'F': System.out.print(\"not good \");\n     }",
    "choices": [
      {
        "key": "A",
        "text": "great"
      },
      {
        "key": "B",
        "text": "great good"
      },
      {
        "key": "C",
        "text": "good"
      },
      {
        "key": "D",
        "text": "not good"
      },
      {
        "key": "E",
        "text": "The code does not compile because the data type of one or more case statements does \nnot match the data type of the switch variable."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile, although not for the reason specified in option E. The sec\u0002ond case statement contains invalid syntax. Each case statement must have the keyword \ncase—in other words, you cannot chain them with a colon (:). For this reason, option F \nis the correct answer. This line could have been fixed to say case 'B', 'C' or by adding \nthe case keyword before 'C'; then the rest of the code would have compiled and printed \ngreat good at runtime.\n"
  },
  {
    "id": "oca-60",
    "question": "Given the following array, which code snippets print the elements in reverse order from how \nthey are declared? (Choose all that apply.)\n     char[] wolf = {'W', 'e', 'b', 'b', 'y'};",
    "choices": [
      {
        "key": "A",
        "text": "     int q = wolf.length;\n     int q = wolf.length;\n     for( ; ; ) {\n        System.out.print(wolf[- - q]);\n        if(q==0) break;\n     }"
      },
      {
        "key": "B",
        "text": "     for(int m=wolf.length- 1; m>=0; - - m)\n     for(int m=wolf.length- 1; m>=0; - - m)\n        System.out.print(wolf[m]);"
      },
      {
        "key": "C",
        "text": "     for(int z=0; z<wolf.length; z++)\n     for(int z=0; z<wolf.length; z++)\n        System.out.print(wolf[wolf.length- z]);"
      },
      {
        "key": "D",
        "text": "     int x = wolf.length- 1;\n     int x = wolf.length- 1;\n     for(int j=0; x>=0 && j==0; x- - )\n        System.out.print(wolf[x]);"
      },
      {
        "key": "E",
        "text": "     final int r = wolf.length;\n     final int r = wolf.length;\n     for(int w = r- 1; r>- 1; w = r- 1)\n        System.out.print(wolf[w]);"
      },
      {
        "key": "F",
        "text": "     for(int i=wolf.length; i>0; - - i)\n     for(int i=wolf.length; i>0; - - i)\n        System.out.print(wolf[i]);"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "To print items in the wolf array in reverse order, the code needs to start with \nwolf[wolf.length-1] and end with wolf[0]. Option A accomplishes this and is the \nfirst correct answer. Option B is also correct and is one of the most common ways a reverse \nloop is written. The termination condition is often m>=0 or m>-1, and both are correct. \nOptions C and F each cause an ArrayIndexOutOfBoundsException at runtime since \nboth read from wolf[wolf.length] first, with an index that is passed the length of the \n0-based array wolf. The form of option C would be successful if the value was changed to \nwolf[wolf.length-z-1]. Option D is also correct, as the j is extraneous and can be \nignored in this example. Finally, option E is incorrect and produces an infinite loop, as w is \nrepeatedly set to r-1, in this case 4, on every loop iteration. Since the update statement has \nno effect after the first iteration, the condition is never met, and the loop never terminates.\n"
  },
  {
    "id": "oca-61",
    "question": "What distinct numbers are printed when the following method is executed? (Choose all \nthat apply.)\n     private void countAttendees() {\n        int participants = 4, animals = 2, performers = - 1; \n        while((participants = participants+1) < 10) {}\n        do {} while (animals++ <= 1);\n        for( ; performers<2; performers+=2) {} \n        System.out.println(participants);\n        System.out.println(animals);\n        System.out.println(performers);\n     }",
    "choices": [
      {
        "key": "A",
        "text": "6"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "4"
      },
      {
        "key": "D",
        "text": "5"
      },
      {
        "key": "E",
        "text": "10"
      },
      {
        "key": "F",
        "text": "9"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "The code compiles without issue and prints two distinct numbers at runtime, so options \nG and H are incorrect. The first loop executes a total of five times, with the loop ending \nwhen participants has a value of 10. For this reason, option E is correct. In the second \nloop, animals starts out not less than or equal to 1, but since it is a do/while loop, it \nexecutes at least once. In this manner, animals takes on a value of 3 and the loop termi\u0002nates, making option B correct. Finally, the last loop executes a total of two times, with \nperformers starting with -1, going to 1 at the end of the first loop, and then ending with \na value of 3 after the second loop, which breaks the loop. This makes option B a correct \nanswer twice over.\n"
  },
  {
    "id": "oca-62",
    "question": "Which statements about pattern matching and flow scoping are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Pattern matching with an if statement is implemented using the instance operator."
      },
      {
        "key": "B",
        "text": "Pattern matching with an if statement is implemented using the instanceon operator."
      },
      {
        "key": "C",
        "text": "Pattern matching with an if statement is implemented using the instanceof operator."
      },
      {
        "key": "D",
        "text": "The pattern variable cannot be accessed after the if statement in which it is declared."
      },
      {
        "key": "E",
        "text": "Flow scoping means a pattern variable is only accessible if the compiler can discern its \ntype."
      },
      {
        "key": "F",
        "text": "Pattern matching can be used to declare a variable with an else statement."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Pattern matching with an if statement is implemented using the instanceof oper\u0002ator, making option C correct and options A and B incorrect. Option D is incorrect as it is \npossible to access a pattern variable outside the if statement in which it is defined. Option \nE is a correct statement about flow scoping. Option F is incorrect. Pattern matching does not \nsupport declaring variables in else statements as else statements do not have a boolean\nexpression.\n"
  },
  {
    "id": "oca-63",
    "question": "What is the output of the following code snippet?\n    2: double iguana = 0;\n    3: do {\n    4:    int snake = 1;\n    5:    System.out.print(snake++ + \" \");\n    6:    iguana- - ;\n    7: } while (snake <= 5);\n    8: System.out.println(iguana);",
    "choices": [
      {
        "key": "A",
        "text": "1 2 3 4 - 4.0"
      },
      {
        "key": "B",
        "text": "1 2 3 4 - 5.0"
      },
      {
        "key": "C",
        "text": "1 2 3 4 5 - 4.0"
      },
      {
        "key": "D",
        "text": "0 1 2 3 4 5 - 5.0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an infinite loop at runtime."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The variable snake is declared within the body of the do/while statement, so it is out \nof scope on line 7. For this reason, option E is the correct answer. If snake were declared \nbefore line 3 with a value of 1, then the output would have been 1 2 3 4 5 -5.0, and \noption G would have been the correct answer.\n"
  },
  {
    "id": "oca-64",
    "question": "Which statements, when inserted into the following blanks, allow the code to compile and \nrun without entering an infinite loop? (Choose all that apply.)\n    4:  int height = 1;\n    5:  L1: while(height++ <10) {\n    6:     long humidity = 12;\n    7:     L2: do {\n    8:        if(humidity- -  % 12 == 0) ;\n    9:        int temperature = 30;\n    10:       L3: for( ; ; ) {\n    11:          temperature++;\n    12:          if(temperature>50) ;\n    13:       }\n    14:    } while (humidity > 4);\n    15: }",
    "choices": [
      {
        "key": "A",
        "text": "break L2 on line 8; continue L2 on line 12"
      },
      {
        "key": "B",
        "text": "continue on line 8; continue on line 12"
      },
      {
        "key": "C",
        "text": "break L3 on line 8; break L1 on line 12"
      },
      {
        "key": "D",
        "text": "continue L2 on line 8; continue L3 on line 12"
      },
      {
        "key": "E",
        "text": "continue L2 on line 8; continue L2 on line 12"
      },
      {
        "key": "F",
        "text": "None of the above, as the code contains a compiler error"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The most important thing to notice when reading this code is that the innermost loop \nis an infinite loop. Therefore, you are looking for solutions that skip the innermost loop \nentirely or that exit that loop. Option A is correct, as break L2 on line 8 causes the second \ninner loop to exit every time it is entered, skipping the innermost loop entirely. For option B, \nthe first continue on line 8 causes the execution to skip the innermost loop on the first iter\u0002ation of the second loop but not the second iteration of the second loop. The innermost loop \nis executed, and with continue on line 12, it produces an infinite loop at runtime, making \noption B incorrect. Option C is incorrect because it contains a compiler error. The label L3\nis not visible outside its loop. Option D is incorrect, as it is equivalent to option B since the \nunlabeled break and continue apply to the nearest loop and therefore produce an infinite \nloop at runtime. Like option A, the continue L2 on line 8 allows the innermost loop to be \nexecuted the second time the second loop is called. The continue L2 on line 12 exits the \ninfinite loop, though, causing control to return to the second loop. Since the first and second \nloops terminate, the code terminates, and option E is a correct answer.\n"
  },
  {
    "id": "oca-65",
    "question": "A minimum of how many lines need to be corrected before the following method \nwill compile?\n    21: void findZookeeper(Long id) {\n    22:    System.out.print(switch(id) {\n    23:       case 10 - > {\"Jane\"}\n    24:       case 20 - > {yield \"Lisa\";};\n    25:       case 30 - > \"Kelly\";\n    26:       case 30 - > \"Sarah\";\n    27:       default - > \"Unassigned\";\n    28:    });\n    29: }",
    "choices": [
      {
        "key": "A",
        "text": "Zero"
      },
      {
        "key": "B",
        "text": "One"
      },
      {
        "key": "C",
        "text": "Two"
      },
      {
        "key": "D",
        "text": "Three"
      },
      {
        "key": "E",
        "text": "Four"
      },
      {
        "key": "F",
        "text": "Five"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Line 22 does not compile because Long is not a compatible type for a switch statement \nor expression. Line 23 does not compile because it is missing a semicolon after \"Jane\" and \na yield statement. Line 24 does not compile because it contains an extra semicolon at the \nend. Finally, lines 25 and 26 do not compile because they use the same case value. At least \none of them would need to be changed for the code to compile. Since four lines need to be \ncorrected, option E is correct.\n"
  },
  {
    "id": "oca-66",
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    2: var tailFeathers = 3;\n    3: final var one = 1;\n    4: switch (tailFeathers) {\n    5:    case one: System.out.print(3 + \" \");\n    6:    default: case 3: System.out.print(5 + \" \");\n    7: }\n    8: while (tailFeathers > 1) {\n    9:    System.out.print(- - tailFeathers + \" \"); }",
    "choices": [
      {
        "key": "A",
        "text": "3"
      },
      {
        "key": "B",
        "text": "5 1"
      },
      {
        "key": "C",
        "text": "5 2"
      },
      {
        "key": "D",
        "text": "3 5 1"
      },
      {
        "key": "E",
        "text": "5 2 1"
      },
      {
        "key": "F",
        "text": "The code will not compile because of lines 3–5."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line 6."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code compiles without issue, making options F and G incorrect. Remember, var is \nsupported in both switch and while loops, provided the compiler determines that the type \nis compatible with these statements. In addition, the variable one is allowed in a case state\u0002ment because it is a final local variable, making it a compile-time constant. The value of \ntailFeathers is 3, which matches the second case statement, making 5 the first output. \nThe while loop is executed twice, with the pre-increment operator (--) modifying the value \nof tailFeathers from 3 to 2 and then to 1 on the second loop. For this reason, the final \noutput is 5 2 1, making option E the correct answer.\n"
  },
  {
    "id": "oca-67",
    "question": "What is the output of the following code snippet?\n    15: int penguin = 50, turtle = 75;\n    16: boolean older = penguin >= turtle;\n    17: if (older = true) System.out.println(\"Success\");\n    18: else System.out.println(\"Failure\");\n    19: else if(penguin != 50) System.out.println(\"Other\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "Other"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 17."
      },
      {
        "key": "E",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Line 19 starts with an else statement, but there is no preceding if statement that it \nmatches. For this reason, line 19 does not compile, making option F the correct answer. If the \nelse keyword was removed from line 19, then the code snippet would print Success.\n"
  },
  {
    "id": "oca-68",
    "question": "Which of the following are possible data types for friends that would allow the code to \ncompile? (Choose all that apply.)\n     for(var friend in friends) {\n        System.out.println(friend);\n     }",
    "choices": [
      {
        "key": "A",
        "text": "Set"
      },
      {
        "key": "B",
        "text": "Map"
      },
      {
        "key": "C",
        "text": "String"
      },
      {
        "key": "D",
        "text": "int[]"
      },
      {
        "key": "E",
        "text": "Collection"
      },
      {
        "key": "F",
        "text": "StringBuilder"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The statement is not a valid for-each loop (or a traditional for loop) since it uses a non\u0002existent in keyword. For this reason, the code does not compile, and option G is correct. If \nthe in was changed to a colon (:), then Set, int[], and Collection would be correct.\n"
  },
  {
    "id": "oca-69",
    "question": "What is the output of the following code snippet?\n    6:  String instrument = \"violin\";\n    7:  final String CELLO = \"cello\";\n    8:  String viola = \"viola\";\n    9:  int p = - 1;\n    10: switch(instrument) {\n    11:    case \"bass\" : break;\n    12:    case CELLO : p++;\n    13:    default: p++;\n    14:    case \"VIOLIN\": p++;\n    15:    case \"viola\" : ++p; break;\n    16: }\n    17: System.out.print(p);",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "1"
      },
      {
        "key": "D",
        "text": "2"
      },
      {
        "key": "E",
        "text": "3"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles without issue, so option F is incorrect. The viola variable created on \nline 8 is never used and can be ignored. If it had been used as the case value on line 15, it \nwould have caused a compilation error since it is not marked final. Since \"violin\" and \n\"VIOLIN\" are not an exact match, the default branch of the switch statement is exe\u0002cuted at runtime. This execution path increments p a total of three times, bringing the final \nvalue of p to 2 and making option D the correct answer.\n"
  },
  {
    "id": "oca-70",
    "question": "What is the output of the following code snippet? (Choose all that apply.)\n    9:  int w = 0, r = 1;\n    10: String name = \"\";\n    11: while(w < 2) {\n    12:    name += \"A\";\n    13:    do {\n    14:       name += \"B\";\n    15:       if(name.length()>0) name += \"C\";\n    16:       else break;\n    17:    } while (r <=1);\n    18:    r++; w++; }\n    19: System.out.println(name);",
    "choices": [
      {
        "key": "A",
        "text": "ABC"
      },
      {
        "key": "B",
        "text": "ABCABC"
      },
      {
        "key": "C",
        "text": "ABCABCABC"
      },
      {
        "key": "D",
        "text": "Line 15 contains a compilation error."
      },
      {
        "key": "E",
        "text": "Line 18 contains a compilation error."
      },
      {
        "key": "F",
        "text": "The code compiles but never terminates at runtime."
      },
      {
        "key": "G",
        "text": "The code compiles but throws a NullPointerException at runtime."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code snippet does not contain any compilation errors, so options D and E are incor\u0002rect. There is a problem with this code snippet, though. While it may seem complicated, the \nkey is to notice that the variable r is updated outside of the do/while loop. This is allowed \nfrom a compilation standpoint, since it is defined before the loop, but it means the innermost \nloop never breaks the termination condition r <= 1. At runtime, this will produce an infi\u0002nite loop the first time the innermost loop is entered, making option F the correct answer.\n"
  },
  {
    "id": "oca-71",
    "question": "What is printed by the following code snippet?\n    23: byte amphibian = 1;\n    24: String name = \"Frog\";\n    25: String color = switch(amphibian) {\n    26:    case 1 - > { yield \"Red\"; } \n    27:    case 2 - > { if(name.equals(\"Frog\")) yield \"Green\"; }\n    28:    case 3 - > { yield \"Purple\"; }\n    29:    default - > throw new RuntimeException();\n    30: };\n    31: System.out.print(color);",
    "choices": [
      {
        "key": "A",
        "text": "Red"
      },
      {
        "key": "B",
        "text": "Green"
      },
      {
        "key": "C",
        "text": "Purple"
      },
      {
        "key": "D",
        "text": "RedPurple"
      },
      {
        "key": "E",
        "text": "An exception is thrown at runtime."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Line 27 does not compile because the case block does not yield a value if name is not \nequal to Frog. For this reason, option F is correct. Every path within a case block must \nyield a value if the switch expression is expected to return a value.\n"
  },
  {
    "id": "oca-72",
    "question": "What is the output of calling getFish(\"goldie\")?\n    40: void getFish(Object fish) {\n    41:    if (!(fish instanceof String guppy))\n    42:       System.out.print(\"Eat!\");\n    43:    else if (!(fish instanceof String guppy)) {\n    44:       throw new RuntimeException();\n    45:    }\n    46:    System.out.print(\"Swim!\");\n    47: }",
    "choices": [
      {
        "key": "A",
        "text": "Eat!"
      },
      {
        "key": "B",
        "text": "Swim!"
      },
      {
        "key": "C",
        "text": "Eat! followed by an exception."
      },
      {
        "key": "D",
        "text": "Eat!Swim!"
      },
      {
        "key": "E",
        "text": "An exception is printed."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Based on flow scoping, guppy is in scope after lines 41–42 if the type is not a String. \nIn this case, line 43 declares a variable guppy that is a duplicate of the previously defined \nlocal variable defined on line 41. For this reason, the code does not compile, and option F is \ncorrect. If a different variable name was used on line 43, then the code would compile and \nprint Swim! at runtime with the specified input.\n"
  },
  {
    "id": "oca-73",
    "question": "What is the result of the following code?\n    1: public class PrintIntegers {\n    2:    public static void main(String[] args) {\n    3:       int y = - 2;\n    4:       do System.out.print(++y + \" \"); \n    5:       while(y <= 5);\n    6: } }",
    "choices": [
      {
        "key": "A",
        "text": "- 2 - 1 0 1 2 3 4 5"
      },
      {
        "key": "B",
        "text": "- 2 - 1 0 1 2 3 4"
      },
      {
        "key": "C",
        "text": "- 1 0 1 2 3 4 5 6"
      },
      {
        "key": "D",
        "text": "- 1 0 1 2 3 4 5"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since the pre-increment operator was used, the first value that will be displayed is -1, so \noptions A and B are incorrect. On the second-to-last iteration of the loop, y will be incre\u0002mented to 5, and the loop will output 5. The loop will continue since 5 <= 5 is true, and \non the last iteration, 6 will be output. At the end of this last iteration, the boolean expres\u0002sion 6 <= 5 will evaluate to false, and the loop will terminate. Since 6 was the last value \noutput by the loop, the answer is option C.\n"
  },
  {
    "id": "oca-74",
    "question": "What is output by the following code? (Choose all that apply.)\n1: public class Fish {\n2:    public static void main(String[] args) {\n3:       int numFish = 4;\n4:       String fishType = \"tuna\";\n5:       String anotherFish = numFish + 1;\n6:       System.out.println(anotherFish + \" \" + fishType);\n7:       System.out.println(numFish + \" \" + 1);\n8: } }",
    "choices": [
      {
        "key": "A",
        "text": "4 1"
      },
      {
        "key": "B",
        "text": "5"
      },
      {
        "key": "C",
        "text": "5 tuna"
      },
      {
        "key": "D",
        "text": "5tuna"
      },
      {
        "key": "E",
        "text": "51tuna"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Line 5 does not compile. This question is checking to see whether you are paying attention \nto the types. numFish is an int, and 1 is an int. Therefore, we use numeric addition and \nget 5. The problem is that we can’t store an int in a String variable. Suppose line 5 said \nString anotherFish = numFish + 1 + \"\";. In that case, the answers would be \noption A and option C. The variable defined on line 5 would be the string \"5\", and both \noutput statements would use concatenation.\n"
  },
  {
    "id": "oca-75",
    "question": "Which of these array declarations are not legal? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "int[][] scores = new int[5][];"
      },
      {
        "key": "B",
        "text": "Object[][][] cubbies = new Object[3][0][5];"
      },
      {
        "key": "C",
        "text": "String beans[] = new beans[6];"
      },
      {
        "key": "D",
        "text": "java.util.Date[] dates[] = new java.util.Date[2][];"
      },
      {
        "key": "E",
        "text": "int[][] types = new int[];"
      },
      {
        "key": "F",
        "text": "int[][] java = new int[][];"
      }
    ],
    "answer": [
      "C",
      "E",
      "F"
    ],
    "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. Options \nE and F don’t specify any size. Although it is legal to leave out the size for later dimensions of \na multidimensional array, the first one is required. Option A declares a legal 2D array. Option \nB declares a legal 3D array. Option D declares a legal 2D array. Remember that it is normal \nto see classes on the exam you might not have learned. You aren’t expected to know anything \nabout them.\n"
  },
  {
    "id": "oca-76",
    "question": "Note that March 13, 2022 is the weekend when we spring forward, and November 6, 2022 \nis when we fall back for daylight saving time. Which of the following can fill in the blank \nwithout the code throwing an exception? (Choose all that apply.)\nvar zone = ZoneId.of(\"US/Eastern\");\nvar date =                                ;\nvar time = LocalTime.of(2, 15);\nvar z = ZonedDateTime.of(date, time, zone);",
    "choices": [
      {
        "key": "A",
        "text": "LocalDate.of(2022, 3, 13)"
      },
      {
        "key": "B",
        "text": "LocalDate.of(2022, 3, 40)"
      },
      {
        "key": "C",
        "text": "LocalDate.of(2022, 11, 6)"
      },
      {
        "key": "D",
        "text": "LocalDate.of(2022, 11, 7)"
      },
      {
        "key": "E",
        "text": "LocalDate.of(2023, 2, 29)"
      },
      {
        "key": "F",
        "text": "LocalDate.of(2022, MonthEnum.MARCH, 13);"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Option B throws an exception because there is no March 40. Option E also throws \nan exception because 2023 isn’t a leap year and therefore has no February 29. Option F \ndoesn’t compile because the enum should be named Month, rather than MonthEnum. Option \nD is correct because it is just a regular date and has nothing to do with daylight saving time. \nOptions A and C are correct because Java is smart enough to adjust for daylight saving time.\n"
  },
  {
    "id": "oca-77",
    "question": "Which of the following are output by this code? (Choose all that apply.)\n3: var s = \"Hello\";\n4: var t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.intern() == s) System.out.println(\"three\");\n8: if (\"Hello\" == s) System.out.println(\"four\");\n9: if (\"Hello\".intern() == t) System.out.println(\"five\");",
    "choices": [
      {
        "key": "A",
        "text": "one"
      },
      {
        "key": "B",
        "text": "two"
      },
      {
        "key": "C",
        "text": "three"
      },
      {
        "key": "D",
        "text": "four"
      },
      {
        "key": "E",
        "text": "five"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 calls \nthe String constructor explicitly and is therefore a different object than s. Line 5 checks \nfor object equality, which is true, and so it prints one. Line 6 uses object reference equality, \nwhich is not true since we have different objects. Line 7 calls intern(), which returns the \nvalue from the string pool and is therefore the same reference as s. Line 8 also compares ref\u0002erences but is true since both references point to the object from the string pool. Finally, line \n9 is a trick. The string Hello is already in the string pool, so calling intern() does not \nchange anything. The reference t is a different object, so the result is still false.\n"
  },
  {
    "id": "oca-78",
    "question": "What is the result of the following code?\n7: var sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
    "choices": [
      {
        "key": "A",
        "text": "abbaaccc"
      },
      {
        "key": "B",
        "text": "abbaccca"
      },
      {
        "key": "C",
        "text": "bbaaaccc"
      },
      {
        "key": "D",
        "text": "bbaaccca"
      },
      {
        "key": "E",
        "text": "An empty line"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". \nThat result is passed to the first insert() call, which inserts at index 1. At this point, sb\ncontains abbaa. That result is passed to the final insert(), which inserts at index 4, result\u0002ing in abbaccca.\n"
  },
  {
    "id": "oca-79",
    "question": "How many of these lines contain a compiler error? (Choose all that apply.)\n23: double one = Math.pow(1, 2);\n24: int two = Math.round(1.0);\n25: float three = Math.random();\n26: var doubles = new double[] {one, two, three};",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Remember to watch return types on math operations. One of the tricks is line 24. The \nround() method returns an int when called with a float. However, we are calling it with \na double, so it returns a long. The other trick is line 25. The random() method returns a \ndouble. Since two lines have a compiler error, option C is the answer.\n"
  },
  {
    "id": "oca-80",
    "question": "Which of these statements is true of the two values? (Choose all that apply.)\n2022–08–28T05:00 GMT- 04:00\n2022–08–28T09:00 GMT- 06:00",
    "choices": [
      {
        "key": "A",
        "text": "The first date/time is earlier."
      },
      {
        "key": "B",
        "text": "The second date/time is earlier."
      },
      {
        "key": "C",
        "text": "Both date/times are the same."
      },
      {
        "key": "D",
        "text": "The date/times are two hours apart."
      },
      {
        "key": "E",
        "text": "The date/times are six hours apart."
      },
      {
        "key": "F",
        "text": "The date/times are 10 hours apart."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "When dealing with time zones, it is best to convert to GMT first by subtracting the \ntime zone. Remember that subtracting a negative is like adding. The first date/time is 9:00 \nGMT, and the second is 15:00 GMT. Therefore, the first one is earlier by six hours.\n"
  },
  {
    "id": "oca-81",
    "question": "Which of the following return 5 when run independently? (Choose all that apply.)\nvar string = \"12345\";\nvar builder = new StringBuilder(\"12345\");",
    "choices": [
      {
        "key": "A",
        "text": "builder.charAt(4)"
      },
      {
        "key": "B",
        "text": "builder.replace(2, 4, \"6\").charAt(3)"
      },
      {
        "key": "C",
        "text": "builder.replace(2, 5, \"6\").charAt(2)"
      },
      {
        "key": "D",
        "text": "string.charAt(5)"
      },
      {
        "key": "E",
        "text": "string.length"
      },
      {
        "key": "F",
        "text": "string.replace(\"123\", \"1\").charAt(2)"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "B",
      "F"
    ],
    "explanation": "Remember that indexes are zero-based, which means index 4 corresponds to 5, and \noption A is correct. For option B, the replace() method starts the replacement at index 2 \nand ends before index 4. This means two characters are replaced, and charAt(3) is called \non the intermediate value of 1265. The character at index 3 is 5, making option B correct. \nOption C is similar, making the intermediate value 126 and returning 6.\nOption D results in an exception since there is no character at index 5. Option E is incorrect. \nIt does not compile because the parentheses for the length() method are missing. Finally, \noption F’s replace results in the intermediate value 145. The character at index 2 is 5, so \noption F is correct.\n"
  },
  {
    "id": "oca-82",
    "question": "Which of the following are true about arrays? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The first element is index 0."
      },
      {
        "key": "B",
        "text": "The first element is index 1."
      },
      {
        "key": "C",
        "text": "Arrays are fixed size."
      },
      {
        "key": "D",
        "text": "Arrays are immutable."
      },
      {
        "key": "E",
        "text": "Calling equals() on two different arrays containing the same primitive values always \nreturns true."
      },
      {
        "key": "F",
        "text": "Calling equals() on two different arrays containing the same primitive values always \nreturns false."
      },
      {
        "key": "G",
        "text": "Calling equals() on two different arrays containing the same primitive values can return \ntrue or false."
      }
    ],
    "answer": [
      "A",
      "C",
      "F"
    ],
    "explanation": "Arrays are zero-indexed, making option A correct and option B incorrect. They are \nnot able to change size, which is option C. The values can be changed, making option D \nincorrect. An array does not override equals(), so it uses object equality. Since two differ\u0002ent objects are not equal, option F is correct, and options E and G are incorrect.\n"
  },
  {
    "id": "oca-83",
    "question": "How many of these lines contain a compiler error? (Choose all that apply.)\n23: int one = Math.min(5, 3);\n24: long two = Math.round(5.5);\n25: double three = Math.floor(6.6);\n26: var doubles = new double[] {one, two, three};",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "All of these lines compile. The min() and floor() methods return the same type passed \nin: int and double, respectively. The round() method returns a long when called with a \ndouble. Option A is correct since the code compiles.\n"
  },
  {
    "id": "oca-84",
    "question": "What is the output of the following code?\nvar date = LocalDate.of(2022, 4, 3);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth()\n    + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 MARCH 4"
      },
      {
        "key": "B",
        "text": "2022 MARCH 6"
      },
      {
        "key": "C",
        "text": "2022 APRIL 3"
      },
      {
        "key": "D",
        "text": "2022 APRIL 5"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "A LocalDate does not have a time element. Therefore, there is no method to add hours, \nmaking option E the answer.\n"
  },
  {
    "id": "oca-85",
    "question": "What is output by the following code? (Choose all that apply.)\nvar numbers = \"012345678\".indent(1);\nnumbers = numbers.stripLeading();\nSystem.out.println(numbers.substring(1, 3));\nSystem.out.println(numbers.substring(7, 7));\nSystem.out.print(numbers.substring(7));",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "123"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "78"
      },
      {
        "key": "E",
        "text": "A blank line"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "First, notice that the indent() call adds a blank space to the beginning of \nnumbers, and stripLeading() immediately removes it. Therefore, these methods cancel \neach other out and have no effect. The substring() method has two forms. The first takes \nthe index to start with and the index to stop immediately before. The second takes just the \nindex to start with and goes to the end of the String. Remember that indexes are zero\u0002based. The first call starts at index 1 and ends with index 2 since it needs to stop before index 3.\nThis gives us option A. The second call starts at index 7 and ends in the same place, result\u0002ing in an empty String which is option E. This prints out a blank line. The final call starts \nat index 7 and goes to the end of the String finishing up with option D.\n"
  },
  {
    "id": "oca-86",
    "question": "What is the result of the following code?\npublic class Lion {\n   public void roar(String roar1, StringBuilder roar2) {\n      roar1.concat(\"!!!\");\n      roar2.append(\"!!!\");\n   }\n   public static void main(String[] args) {\n      var roar1 = \"roar\";\n      var roar2 = new StringBuilder(\"roar\");\n      new Lion().roar(roar1, roar2);\n      System.out.println(roar1 + \" \" + roar2);\n} }",
    "choices": [
      {
        "key": "A",
        "text": "roar roar"
      },
      {
        "key": "B",
        "text": "roar roar!!!"
      },
      {
        "key": "C",
        "text": "roar!!! roar"
      },
      {
        "key": "D",
        "text": "roar!!! roar!!!"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "A String is immutable. Calling concat() returns a new String but does not change \nthe original. A StringBuilder is mutable. Calling append() adds characters to the exist\u0002ing character sequence along with returning a reference to the same object. Therefore, option \nB is correct.\n"
  },
  {
    "id": "oca-87",
    "question": "Given the following, which can correctly fill in the blank? (Choose all that apply.)\nvar date = LocalDate.now();\nvar time = LocalTime.now();\nvar dateTime = LocalDateTime.now();\nvar zoneId = ZoneId.systemDefault();\nvar zonedDateTime = ZonedDateTime.of(dateTime, zoneId);\nInstant instant =                               ;",
    "choices": [
      {
        "key": "A",
        "text": "Instant.now()"
      },
      {
        "key": "B",
        "text": "new Instant()"
      },
      {
        "key": "C",
        "text": "date.toInstant()"
      },
      {
        "key": "D",
        "text": "dateTime.toInstant()"
      },
      {
        "key": "E",
        "text": "time.toInstant()"
      },
      {
        "key": "F",
        "text": "zonedDateTime.toInstant()"
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Option A correctly creates the current instant. Option F is also a proper conversion. \nOption B is incorrect because Instant, like many other date/time classes, does not have \na public constructor and is instantiated via methods. Options C, D, and E are incorrect \nbecause the source object does not represent a point in time. Without a time zone, Java \ndoesn’t know what moment in time to use for the Instant.\n"
  },
  {
    "id": "oca-88",
    "question": "What is the output of the following? (Choose all that apply.)\nvar arr = new String[] { \"PIG\", \"pig\", \"123\"};\nArrays.sort(arr);\nSystem.out.println(Arrays.toString(arr));\nSystem.out.println(Arrays.binarySearch(arr, \"Pippa\"));",
    "choices": [
      {
        "key": "A",
        "text": "[pig, PIG, 123]"
      },
      {
        "key": "B",
        "text": "[PIG, pig, 123]"
      },
      {
        "key": "C",
        "text": "[123, PIG, pig]"
      },
      {
        "key": "D",
        "text": "[123, pig, PIG]"
      },
      {
        "key": "E",
        "text": "- 3"
      },
      {
        "key": "F",
        "text": "- 2"
      },
      {
        "key": "G",
        "text": "The results of binarySearch() are undefined in this example."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Numbers sort before letters and uppercase sorts before lowercase. This makes option \nC one of the answers. The binarySearch() method looks at where a value would be \ninserted, which is before the second element for Pippa. It then negates it and subtracts one, \nwhich is option E.\n"
  },
  {
    "id": "oca-89",
    "question": "What is included in the output of the following code? (Choose all that apply.)\nvar base = \"ewe\\nsheep\\\\t\";\nint length = base.length();\nint indent = base.indent(2).length();\nint translate = base.translateEscapes().length();\n \nvar formatted = \"%s %s %s\".formatted(length, indent, translate);\nSystem.out.format(formatted);",
    "choices": [
      {
        "key": "A",
        "text": "10"
      },
      {
        "key": "B",
        "text": "11"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "13"
      },
      {
        "key": "E",
        "text": "14"
      },
      {
        "key": "F",
        "text": "15"
      },
      {
        "key": "G",
        "text": "16"
      }
    ],
    "answer": [
      "A",
      "B",
      "G"
    ],
    "explanation": "There are 11 characters in base because there are two escape characters. The \\n\ncounts as one character representing a new line, and the \\\\ counts as one character repre\u0002senting a backslash. This makes option B one of the answers. The indent() method adds \ntwo characters to the beginning of each of the two lines of base. This gives us four addi\u0002tional characters. However, the method also normalizes by adding a new line to the end if \nit is missing. The extra character means we add five characters to the existing 11, which is \noption G. Finally, the translateEscapes() method turns any text escape characters into \nactual escape characters, making \\\\t into \\t. This gets rid of one character, leaving us with \n10 characters matching option A.\n"
  },
  {
    "id": "oca-90",
    "question": "Which of these statements are true? (Choose all that apply.)\nvar letters = new StringBuilder(\"abcdefg\");",
    "choices": [
      {
        "key": "A",
        "text": "letters.substring(1, 2) returns a single- character String."
      },
      {
        "key": "B",
        "text": "letters.substring(2, 2) returns a single- character String."
      },
      {
        "key": "C",
        "text": "letters.substring(6, 5) returns a single- character String."
      },
      {
        "key": "D",
        "text": "letters.substring(6, 6) returns a single- character String."
      },
      {
        "key": "E",
        "text": "letters.substring(1, 2) throws an exception."
      },
      {
        "key": "F",
        "text": "letters.substring(2, 2) throws an exception."
      },
      {
        "key": "G",
        "text": "letters.substring(6, 5) throws an exception."
      },
      {
        "key": "H",
        "text": "letters.substring(6, 6) throws an exception."
      }
    ],
    "answer": [
      "A",
      "G"
    ],
    "explanation": "The substring() method includes the starting index but not the ending index. \nWhen called with 1 and 2, it returns a single-character String, making option A correct and \noption E incorrect. Calling substring() with 2 as both parameters is legal. It \nreturns an empty String, making options B and F incorrect. Java does not allow the \nindexes to be specified in reverse order. Option G is correct because it throws a \nStringIndexOutOfBoundsException. Finally, option H is incorrect because it returns \nan empty String.\n"
  },
  {
    "id": "oca-91",
    "question": "What is the result of the following code? (Choose all that apply.)\n13: String s1 = \"\"\"\n14:    purr\"\"\";\n15: String s2 = \"\";\n16:\n17: s1.toUpperCase();\n18: s1.trim();\n19: s1.substring(1, 3);\n20: s1 += \"two\";\n21:\n22: s2 += 2;\n23: s2 += 'c';\n24: s2 += false;\n25:\n26: if ( s2 == \"2cfalse\") System.out.println(\"==\");\n27: if ( s2.equals(\"2cfalse\")) System.out.println(\"equals\");\n28: System.out.println(s1.length());",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "10"
      },
      {
        "key": "E",
        "text": "=="
      },
      {
        "key": "F",
        "text": "equals"
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      },
      {
        "key": "H",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "This question is tricky because it has several parts. First, you have to know that the text \nblock on lines 13 and 14 is equivalent to a regular String. Since there is no line break at \nthe end, this is four characters. Then, you have to know that String objects are immutable, \nwhich means the results of lines 17–19 are ignored. Finally, on line 20, something happens. \nWe concatenate three new characters to s1 and now have a String of length 7, making \noption C correct.\nNext, s2 += 2 expands to s2 = s2 + 2. A String concatenated with any other type \ngives a String. Lines 22, 23, and 24 all append to s2, giving a result of \"2cfalse\". The \nif statement on line 27 returns true because the values of the two String objects are \nthe same using object equality. The if statement on line 26 returns false because the two \nString objects are not the same in memory. One comes directly from the string pool, and \nthe other comes from building using String operations.\n"
  },
  {
    "id": "oca-92",
    "question": "Which of the following fill in the blank to print a positive integer? (Choose all that apply.)\nString[] s1 = { \"Camel\", \"Peacock\", \"Llama\"};\nString[] s2 = { \"Camel\", \"Llama\", \"Peacock\"};\nString[] s3 = { \"Camel\"};\nString[] s4 = { \"Camel\", null};\nSystem.out.println(Arrays.                      );",
    "choices": [
      {
        "key": "A",
        "text": "compare(s1, s2)"
      },
      {
        "key": "B",
        "text": "mismatch(s1, s2)"
      },
      {
        "key": "C",
        "text": "compare(s3, s4)"
      },
      {
        "key": "D",
        "text": "mismatch (s3, s4)"
      },
      {
        "key": "E",
        "text": "compare(s4, s4)"
      },
      {
        "key": "F",
        "text": "mismatch (s4, s4)"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "The compare() method returns a positive integer when the arrays are different and \nthe first is larger. This is the case for option A since the element at index 1 comes first alpha\u0002betically. It is not the case for option C because the s4 is longer or for option E because the \narrays are the same.\nThe mismatch() method returns a positive integer when the arrays are different in a posi\u0002tion index 1 or greater. This is the case for options B and D since the difference is at index 1. \nIt is not the case for option F because there is no difference.\n"
  },
  {
    "id": "oca-93",
    "question": "Note that March 13, 2022 is the weekend that clocks spring ahead for daylight saving time. \nWhat is the output of the following? (Choose all that apply.)\nvar date = LocalDate.of(2022, Month.MARCH, 13);\nvar time = LocalTime.of(1, 30);\nvar zone = ZoneId.of(\"US/Eastern\");\nvar dateTime1 = ZonedDateTime.of(date, time, zone);\nvar dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);\n \nlong diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);\nint hour = dateTime2.getHour();\nboolean offset = dateTime1.getOffset() \n   == dateTime2.getOffset();\nSystem.out.println(\"diff = \" + diff);\nSystem.out.println(\"hour = \" + hour);\nSystem.out.println(\"offset = \" + offset);",
    "choices": [
      {
        "key": "A",
        "text": "diff = 1"
      },
      {
        "key": "B",
        "text": "diff = 2"
      },
      {
        "key": "C",
        "text": "hour = 2"
      },
      {
        "key": "D",
        "text": "hour = 3"
      },
      {
        "key": "E",
        "text": "offset = true"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The dateTime1 object has a time of 1:30 per initialization. The dateTime2 object \nis an hour later. However, there is no 2:30 when springing ahead, setting the time to 3:30. \nOption A is correct because it is an hour later. Option D is also correct because the hour of \nthe new time is 3. Option E is not correct because we have changed the time zone offset due \nto daylight saving time.\n"
  },
  {
    "id": "oca-94",
    "question": "Which of the following can fill in the blank to print avaJ? (Choose all that apply.)\n3: var puzzle = new StringBuilder(\"Java\");\n4: puzzle.                        ;\n5: System.out.println(puzzle);",
    "choices": [
      {
        "key": "A",
        "text": "reverse()"
      },
      {
        "key": "B",
        "text": "append(\"vaJ$\").substring(0, 4)"
      },
      {
        "key": "C",
        "text": "append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() -  1)"
      },
      {
        "key": "D",
        "text": "append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length())"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "The reverse() method is the easiest way of reversing the characters in a \nStringBuilder; therefore, option A is correct. In option B, substring() returns a \nString, which is not stored anywhere. Option C uses method chaining. First, it creates the \nvalue \"JavavaJ$\". Then, it removes the first three characters, resulting in \"avaJ$\". Finally, \nit removes the last character, resulting in \"avaJ\". Option D throws an exception because \nyou cannot delete the character after the last index. Remember that deleteCharAt() uses \nindexes that are zero-based, and length() counts the number of characters rather than \nthe index.\n"
  },
  {
    "id": "oca-95",
    "question": "What is the output of the following code?\nvar date = LocalDate.of(2022, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() \n   + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 APRIL 30"
      },
      {
        "key": "B",
        "text": "2022 MAY 2"
      },
      {
        "key": "C",
        "text": "2025 APRIL 2"
      },
      {
        "key": "D",
        "text": "2025 APRIL 30"
      },
      {
        "key": "E",
        "text": "2025 MAY 2"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The date starts out as April 30, 2022. Since dates are immutable and the plus methods’ \nreturn values are ignored, the result is unchanged. Therefore, option A is correct.\n"
  },
  {
    "id": "oca-96",
    "question": "Which statements about the final modifier are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Instance and static variables can be marked final."
      },
      {
        "key": "B",
        "text": "A variable is effectively final only if it is marked final."
      },
      {
        "key": "C",
        "text": "An object that is marked final cannot be modified."
      },
      {
        "key": "D",
        "text": "Local variables cannot be declared with type var and the final modifier."
      },
      {
        "key": "E",
        "text": "A primitive that is marked final cannot be modified."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Instance and static variables can be marked final, making option A correct. Effec\u0002tively final means a local variable is not marked final but whose value does not change \nafter it is set, making option B incorrect. Option C is incorrect, as final refers only to \nthe reference to an object, not its contents. Option D is incorrect, as var and final can \nbe used together. Finally, option E is correct: once a primitive is marked final, it cannot \nbe modified.\n"
  },
  {
    "id": "oca-97",
    "question": "Which of the following can fill in the blank in this code to make it compile? (Choose all \nthat apply.)\npublic class Ant {\n         void method() {}\n}",
    "choices": [
      {
        "key": "A",
        "text": "default"
      },
      {
        "key": "B",
        "text": "final"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "Public"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "zzz:"
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "The keyword void is a return type. Only the access modifier or optional specifiers are \nallowed before the return type. Option C is correct, creating a method with private access. \nOption B is also correct, creating a method with package access and the optional specifier \nfinal. Since package access does not use a modifier, we get to jump right to \nfinal. Option A is incorrect because package access omits the access modifier rather than \nspecifying default. Option D is incorrect because Java is case sensitive. It would have been \ncorrect if public were the choice. Option E is incorrect because the method already has a \nvoid return type. Option F is incorrect because labels are not allowed for methods.\n"
  },
  {
    "id": "oca-98",
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "final static void rain() {}"
      },
      {
        "key": "B",
        "text": "public final int void snow() {}"
      },
      {
        "key": "C",
        "text": "private void int hail() {}"
      },
      {
        "key": "D",
        "text": "static final void sleet() {}"
      },
      {
        "key": "E",
        "text": "void final ice() {}"
      },
      {
        "key": "F",
        "text": "void public slush() {}"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Options A and D are correct because the optional specifiers are allowed in any order. \nOptions B and C are incorrect because they each have two return types. Options E and F \nare incorrect because the return type is before the optional specifier and access modifier, \nrespectively.\n"
  },
  {
    "id": "oca-99",
    "question": "Which of the following can fill in the blank and allow the code to compile? (Choose all that apply.)\nfinal          song = 6;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "Integer"
      },
      {
        "key": "C",
        "text": "long"
      },
      {
        "key": "D",
        "text": "Long"
      },
      {
        "key": "E",
        "text": "double"
      },
      {
        "key": "F",
        "text": "Double"
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "The value 6 can be implicitly promoted to any of the primitive types, making \noptions A, C, and E correct. It can also be autoboxed to Integer, making option B correct. \nIt cannot be both promoted and autoboxed, making options D and F incorrect.\n"
  },
  {
    "id": "oca-100",
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void january() { return; }"
      },
      {
        "key": "B",
        "text": "public int february() { return null;}"
      },
      {
        "key": "C",
        "text": "public void march() {}"
      },
      {
        "key": "D",
        "text": "public int april() { return 9;}"
      },
      {
        "key": "E",
        "text": "public int may() { return 9.0;}"
      },
      {
        "key": "F",
        "text": "public int june() { return;}"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Options A and C are correct because a void method is optionally allowed to have \na return statement as long as it doesn’t try to return a value. Option B does not compile \nbecause null requires a reference object as the return type. Since int is primitive, it is not \na reference object. Option D is correct because it returns an int value. Option E does not \ncompile because it tries to return a double when the return type is int. Since a \ndouble cannot be assigned to an int, it cannot be returned as one either. Option F does not \ncompile because no value is actually returned.\n"
  },
  {
    "id": "oca-101",
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void violin(int... nums) {}"
      },
      {
        "key": "B",
        "text": "public void viola(String values, int... nums) {}"
      },
      {
        "key": "C",
        "text": "public void cello(int... nums, String values) {}"
      },
      {
        "key": "D",
        "text": "public void bass(String... values, int... nums) {}"
      },
      {
        "key": "E",
        "text": "public void flute(String[] values, ...int nums) {}"
      },
      {
        "key": "F",
        "text": "public void oboe(String[] values, int[] nums) {}"
      }
    ],
    "answer": [
      "A",
      "B",
      "F"
    ],
    "explanation": "Options A and B are correct because the single varargs parameter is the last param\u0002eter declared. Option F is correct because it doesn’t use any varargs parameters. Option C is \nincorrect because the varargs parameter is not last. Option D is incorrect because two varargs \nparameters are not allowed in the same method. Option E is incorrect because the ... for a \nvarargs must be after the type, not before it.\n"
  },
  {
    "id": "oca-102",
    "question": "Given the following method, which of the method calls return 2? (Choose all that apply.)\npublic int juggle(boolean b, boolean... b2) {\n   return b2.length;\n}",
    "choices": [
      {
        "key": "A",
        "text": "juggle();"
      },
      {
        "key": "B",
        "text": "juggle(true);"
      },
      {
        "key": "C",
        "text": "juggle(true, true);"
      },
      {
        "key": "D",
        "text": "juggle(true, true, true);"
      },
      {
        "key": "E",
        "text": "juggle(true, {true, true});"
      },
      {
        "key": "F",
        "text": "juggle(true, new boolean[2]);"
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "Option D passes the initial parameter plus two more to turn into a varargs array of size 2.\nOption F passes the initial parameter plus an array of size 2. Option A does not compile \nbecause it does not pass the initial parameter. Option E does not compile because it does not \ndeclare an array properly. It should be new boolean[] {true, true}. Option B creates \na varargs array of size 0, and option C creates a varargs array of size 1.\n"
  },
  {
    "id": "oca-103",
    "question": "Which of the following statements is correct?",
    "choices": [
      {
        "key": "A",
        "text": "Package access is more lenient than protected access."
      },
      {
        "key": "B",
        "text": "A public class that has private fields and package methods is not visible to classes \noutside the package."
      },
      {
        "key": "C",
        "text": "You can use access modifiers so only some of the classes in a package see a particular \npackage class."
      },
      {
        "key": "D",
        "text": "You can use access modifiers to allow access to all methods and not any instance vari-\nables."
      },
      {
        "key": "E",
        "text": "You can use access modifiers to restrict access to all classes that begin with the word \nTest."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Option D is correct. A common practice is to set all fields to be private and all \nmethods to be public. Option A is incorrect because protected access allows everything \nthat package access allows and additionally allows subclasses access. Option B is incor\u0002rect because the class is public. This means that other classes can see the class. However, \nthey cannot call any of the methods or read any of the fields. It is essentially a useless class. \nOption C is incorrect because package access applies to the whole package. Option E is \nincorrect because Java has no such wildcard access capability.\n"
  },
  {
    "id": "oca-104",
    "question": "Given the following class definitions, which lines in the main() method generate a compiler \nerror? (Choose all that apply.)\n// Classroom.java\npackage my.school;\npublic class Classroom {\n   private int roomNumber;\n   protected static String teacherName;\n   static int globalKey = 54321;\n   public static int floor = 3;\n   Classroom(int r, String t) {\n      roomNumber = r;\n      teacherName = t; } }\n \n// School.java\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4:    public static void main(String[] args) {\n5:       System.out.println(Classroom.globalKey);\n6:       Classroom room = new Classroom(101, \"Mrs. Anderson\");\n7:       System.out.println(room.roomNumber);\n8:       System.out.println(Classroom.floor);\n9:       System.out.println(Classroom.teacherName); } }",
    "choices": [
      {
        "key": "A",
        "text": "None: the code compiles fine."
      },
      {
        "key": "B",
        "text": "Line 5"
      },
      {
        "key": "C",
        "text": "Line 6"
      },
      {
        "key": "D",
        "text": "Line 7"
      },
      {
        "key": "E",
        "text": "Line 8"
      },
      {
        "key": "F",
        "text": "Line 9"
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The two classes are in different packages, which means private access and \npackage access will not compile. This causes compiler errors on lines 5, 6, and 7, making \noptions B, C, and D correct answers. Additionally, protected access will not compile since \nSchool does not inherit from Classroom. This causes the compiler error on line 9, making \noption F a correct answer as well.\n"
  },
  {
    "id": "oca-105",
    "question": "What is the output of executing the Chimp program?\n// Rope.java\n1: package rope;\n2: public class Rope {\n3:    public static int LENGTH = 5;\n4:    static { \n5:       LENGTH = 10;\n6:    }\n7:    public static void swing() {\n8:       System.out.print(\"swing \");\n9:    } }\n \n// Chimp.java\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4:    public static void main(String[] args) {\n5:       Rope.swing();\n6:       new Rope().swing();\n7:       System.out.println(LENGTH);\n8:    } }",
    "choices": [
      {
        "key": "A",
        "text": "swing swing 5"
      },
      {
        "key": "B",
        "text": "swing swing 10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 2 of Chimp"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5 of Chimp"
      },
      {
        "key": "E",
        "text": "Compiler error on line 6 of Chimp"
      },
      {
        "key": "F",
        "text": "Compiler error on line 7 of Chimp"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Rope runs line 3, setting LENGTH to 5, and then immediately after that runs the \nstatic initializer, which sets it to 10. Line 5 in the Chimp class calls the static method \nnormally and prints swing and a space. Line 6 also calls the static method. Java allows \ncalling a static method through an instance variable, although it is not recommended. \nLine 7 uses the static import on line 2 to reference LENGTH. For these reasons, option B \nis correct.\n"
  },
  {
    "id": "oca-106",
    "question": "Which statements are true of the following code? (Choose all that apply.)\n1:  public class Rope {\n2:     public static void swing() {\n3:        System.out.print(\"swing\");\n4:     }\n5:     public void climb() {\n6:        System.out.println(\"climb\");\n7:     }\n8:     public static void play() {\n9:        swing();\n10:       climb();\n11:    }\n12:    public static void main(String[] args) {\n13:       Rope rope = new Rope();\n14:       rope.play();\n15:       Rope rope2 = null;\n16:       System.out.print(\"- \");\n17:       rope2.play();\n18:    } }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles as is."
      },
      {
        "key": "B",
        "text": "There is exactly one compiler error in the code."
      },
      {
        "key": "C",
        "text": "There are exactly two compiler errors in the code."
      },
      {
        "key": "D",
        "text": "If the line(s) with compiler errors are removed, the output is swing- climb."
      },
      {
        "key": "E",
        "text": "If the line(s) with compiler errors are removed, the output is swing- swing."
      },
      {
        "key": "F",
        "text": "If the line(s) with compile errors are removed, the code throws a NullPointerException."
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Line 10 does not compile because static methods are not allowed to call instance \nmethods. Even though we are calling play() as if it were an instance method and an in\u0002stance exists, Java knows play() is really a static method and treats it as such. Since \nthis is the only line that does not compile, option B is correct. If line 10 is removed, the \ncode prints swing-swing, making option E correct. It does not throw a \nNullPointerException on line 17 because play() is a static method. Java looks at \nthe type of the reference for rope2 and translates the call to Rope.play().\n"
  },
  {
    "id": "oca-107",
    "question": "How many variables in the following method are effectively final?\n10: public void feed() {\n11:    int monkey = 0;\n12:    if(monkey > 0) {\n13:       var giraffe = monkey++;\n14:       String name;\n15:       name = \"geoffrey\";\n16:    }\n17:    String name = \"milly\";\n18:    var food = 10;\n19:    while(monkey <= 10) {\n20:       food = 0;\n21:    }\n22:    name = null;\n23: }",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "None of the above. The code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The test for effectively final is if the final modifier can be added to the local variable \nand the code still compiles. The monkey variable declared on line 11 is not effectively final \nbecause it is modified on line 13. The giraffe and name variables declared on lines 13 and \n14, respectively, are effectively final and not modified after they are set. The name variable \ndeclared on line 17 is not effectively final since it is modified on line 22. Finally, the food\nvariable on line 18 is not effectively final since it is modified on line 20. Since there are two \neffectively final variables, option B is correct.\n"
  },
  {
    "id": "oca-108",
    "question": "What is the output of the following code?\n// RopeSwing.java\nimport rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n   private static Rope rope1 = new Rope();\n   private static Rope rope2 = new Rope();\n   {\n      System.out.println(rope1.length);\n   }\n   public static void main(String[] args) {\n      rope1.length = 2;\n      rope2.length = 8;\n      System.out.println(rope1.length);\n   }\n}\n \n// Rope.java\npackage rope;\npublic class Rope {\n   public static int length = 0;\n}",
    "choices": [
      {
        "key": "A",
        "text": "02"
      },
      {
        "key": "B",
        "text": "08"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "There are two details to notice in this code. First, note that RopeSwing has an instance \ninitializer and not a static initializer. Since RopeSwing is never constructed, the instance \ninitializer does not run. The other detail is that length is static. Changes from any object \nupdate this common static variable. The code prints 8, making option D correct.\n"
  },
  {
    "id": "oca-109",
    "question": "How many lines in the following code have compiler errors?\n1:  public class RopeSwing {\n2:     private static final String leftRope;\n3:     private static final String rightRope;\n4:     private static final String bench;\n5:     private static final String name = \"name\";\n6:     static {\n7:        leftRope = \"left\";\n8:        rightRope = \"right\";\n9:     }\n10:    static {\n11:       name = \"name\";\n12:       rightRope = \"right\";\n13:    }\n14:    public static void main(String[] args) {\n15:       bench = \"bench\";\n16:    }\n17: }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "If a variable is static final, it must be set exactly once, and it must be in the dec\u0002laration line or in a static initialization block. Line 4 doesn’t compile because bench is \nnot set in either of these locations. Line 15 doesn’t compile because final variables are not \nallowed to be set after that point. Line 11 doesn’t compile because name is set twice: once in \nthe declaration and again in the static block. Line 12 doesn’t compile because rightRope\nis set twice as well. Both are in static initialization blocks. Since four lines do not compile, \noption E is correct.\n"
  },
  {
    "id": "oca-110",
    "question": "Which of the following can replace line 2 to make this code compile? (Choose all that apply.)\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4:    public void method(ArrayList<String> list) {\n5:       sort(list);\n6:    }\n7: }",
    "choices": [
      {
        "key": "A",
        "text": "import static java.util.Collections;"
      },
      {
        "key": "B",
        "text": "import static java.util.Collections.*;"
      },
      {
        "key": "C",
        "text": "import static java.util.Collections.sort(ArrayList<String>);"
      },
      {
        "key": "D",
        "text": "static import java.util.Collections;"
      },
      {
        "key": "E",
        "text": "static import java.util.Collections.*;"
      },
      {
        "key": "F",
        "text": "static import java.util.Collections.sort(ArrayList<String>);"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The two valid ways to do this are import static java.util.Collections.*;\nand import static java.util.Collections.sort;. Option A is incorrect because \nyou can do a static import only on static members. Classes such as Collections require \na regular import. Option C is nonsense as method parameters have no business in an \nimport. Options D, E, and F try to trick you into reversing the syntax of import static.\n"
  },
  {
    "id": "oca-111",
    "question": "What is the result of the following statements?\n1:  public class Test {\n2:     public void print(byte x) {\n3:        System.out.print(\"byte- \");\n4:     }\n5:     public void print(int x) {\n6:        System.out.print(\"int- \");\n7:     }\n8:     public void print(float x) {\n9:        System.out.print(\"float- \");\n10:    }\n11:    public void print(Object x) {\n12:       System.out.print(\"Object- \");\n13:    }\n14:    public static void main(String[] args) {\n15:       Test t = new Test();\n16:       short s = 123;\n17:       t.print(s);\n18:       t.print(true);\n19:       t.print(6.789);\n20:    }\n21: }",
    "choices": [
      {
        "key": "A",
        "text": "byte- float- Object- "
      },
      {
        "key": "B",
        "text": "int- float- Object- "
      },
      {
        "key": "C",
        "text": "byte- Object- float- "
      },
      {
        "key": "D",
        "text": "int- Object- float- "
      },
      {
        "key": "E",
        "text": "int- Object- Object- "
      },
      {
        "key": "F",
        "text": "byte- Object- Object- "
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The argument on line 17 is a short. It can be promoted to an int, so print() on line \n5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a Boolean, \nso print() on line 11 is invoked. The argument on line 19 is a double. It can be auto\u0002boxed to a Double, so print() on line 11 is invoked. Therefore, the output is \nint-Object-Object-, and the correct answer is option E.\n"
  },
  {
    "id": "oca-112",
    "question": "What is the result of the following program?\n1:  public class Squares {\n2:     public static long square(int x) {\n3:        var y = x * (long) x;\n4:        x = - 1;\n5:        return y;\n6:     }\n7:     public static void main(String[] args) {\n8:        var value = 9;\n9:        var result = square(value);\n10:       System.out.println(value);\n11:    } }",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "81"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9"
      },
      {
        "key": "E",
        "text": "Compiler error on a different line"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays as 9. \nIn the method square, x starts as 9. The y value becomes 81, and then x gets set to –1. Line \n9 does set result to 81. However, we are printing out value, and that is still 9, making \noption B correct.\n"
  },
  {
    "id": "oca-113",
    "question": "Which of the following are output by the following code? (Choose all that apply.)\npublic class StringBuilders {\n   public static StringBuilder work(StringBuilder a, \n      StringBuilder b) {\n      a = new StringBuilder(\"a\");\n      b.append(\"b\");\n      return a;\n   }\n   public static void main(String[] args) {\n      var s1 = new StringBuilder(\"s1\");\n      var s2 = new StringBuilder(\"s2\");\n      var s3 = work(s1, s2);\n      System.out.println(\"s1 = \" + s1);\n      System.out.println(\"s2 = \" + s2);\n      System.out.println(\"s3 = \" + s3);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "s1 = a"
      },
      {
        "key": "B",
        "text": "s1 = s1"
      },
      {
        "key": "C",
        "text": "s2 = s2"
      },
      {
        "key": "D",
        "text": "s2 = s2b"
      },
      {
        "key": "E",
        "text": "s3 = a"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Since Java is pass-by-value, assigning a new object to a does not change the caller. \nCalling append() does affect the caller because both the method parameter and the caller \nhave a reference to the same object. Finally, returning a value does pass the reference to the \ncaller for assignment to s3. For these reasons, options B, D, and E are correct.\n"
  },
  {
    "id": "oca-114",
    "question": "Which of the following will compile when independently inserted in the following code? \n(Choose all that apply.)\n1:  public class Order3 {\n2:     final String value1 = \"red\";\n3:     static String value2 = \"blue\";\n4:     String value3 = \"yellow\";\n5:     {\n6:        // CODE SNIPPET 1\n7:     }\n8:     static {\n9:        // CODE SNIPPET 2\n10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Insert at line 6: value1 = \"green\";"
      },
      {
        "key": "B",
        "text": "Insert at line 6: value2 = \"purple\";"
      },
      {
        "key": "C",
        "text": "Insert at line 6: value3 = \"orange\";"
      },
      {
        "key": "D",
        "text": "Insert at line 9: value1 = \"magenta\";"
      },
      {
        "key": "E",
        "text": "Insert at line 9: value2 = \"cyan\";"
      },
      {
        "key": "F",
        "text": "Insert at line 9: value3 = \"turquoise\";"
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "The variable value1 is a final instance variable. It can be set only once: in the \nvariable declaration, an instance initializer, or a constructor. Option A does not compile \nbecause the final variable was already set in the declaration. The variable value2 is a \nstatic variable. Both instance and static initializers are able to access static variables, \nmaking options B and E correct. The variable value3 is an instance variable. Options D and \nF do not compile because a static initializer does not have access to instance variables.\n"
  },
  {
    "id": "oca-115",
    "question": "Which of the following are true about the following code? (Choose all that apply.)\npublic class Run {\n   static void execute() {\n      System.out.print(\"1- \");\n   }\n   static void execute(int num) {\n      System.out.print(\"2- \");\n   }\n   static void execute(Integer num) {\n      System.out.print(\"3- \");\n   }\n   static void execute(Object num) {\n      System.out.print(\"4- \");\n   }\n   static void execute(int... nums) {\n      System.out.print(\"5- \");\n   }\n   public static void main(String[] args) {\n      Run.execute(100);\n      Run.execute(100L);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code prints out 2- 4- ."
      },
      {
        "key": "B",
        "text": "The code prints out 3- 4- ."
      },
      {
        "key": "C",
        "text": "The code prints out 4- 2- ."
      },
      {
        "key": "D",
        "text": "The code prints out 4- 4- ."
      },
      {
        "key": "E",
        "text": "The code prints 3- 4-  if you remove the method static void execute(int num)."
      },
      {
        "key": "F",
        "text": "The code prints 4- 4-  if you remove the method static void execute(int num)."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The 100 parameter is an int and so calls the matching int method, making option A \ncorrect. When this method is removed, Java looks for the next most specific constructor. Java \nprefers autoboxing to varargs, so it chooses the Integer constructor. The 100L parameter \nis a long. Since it can’t be converted into a smaller type, it is autoboxed into a Long, and \nthen the method for Object is called, making option E correct.\n"
  },
  {
    "id": "oca-116",
    "question": "Which method signatures are valid overloads of the following method signature? (Choose all \nthat apply.)\npublic void moo(int m, int... n)",
    "choices": [
      {
        "key": "A",
        "text": "public void moo(int a, int... b)"
      },
      {
        "key": "B",
        "text": "public int moo(char ch)"
      },
      {
        "key": "C",
        "text": "public void moooo(int... z)"
      },
      {
        "key": "D",
        "text": "private void moo(int... x)"
      },
      {
        "key": "E",
        "text": "public void moooo(int y)"
      },
      {
        "key": "F",
        "text": "public void moo(int... c, int d)"
      },
      {
        "key": "G",
        "text": "public void moo(int... i, int j...)"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Option A is incorrect because it has the same parameter list of types and therefore the \nsame signature as the original method. Options B and D are valid method overloads because \nthe types of parameters in the list change. When overloading methods, the return type and \naccess modifiers do not need to be the same. Options C and E are incorrect because the \nmethod name is different. Options F and G do not compile. There can be at most one varargs \nparameter, and it must be the last element in the parameter list.\n"
  },
  {
    "id": "oca-117",
    "question": "Which code can be inserted to have the code print 2?\npublic class BirdSeed {\n   private int numberBags;\n   boolean call;\n \n   public BirdSeed() {\n      // LINE 1\n      call = false;\n      // LINE 2\n   }\n \n   public BirdSeed(int numberBags) {\n      this.numberBags = numberBags;\n   }\n \n   public static void main(String[] args) {\n      var seed = new BirdSeed();\n      System.out.print(seed.numberBags);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Replace line 1 with BirdSeed(2);."
      },
      {
        "key": "B",
        "text": "Replace line 2 with BirdSeed(2);."
      },
      {
        "key": "C",
        "text": "Replace line 1 with new BirdSeed(2);."
      },
      {
        "key": "D",
        "text": "Replace line 2 with new BirdSeed(2);."
      },
      {
        "key": "E",
        "text": "Replace line 1 with this(2);."
      },
      {
        "key": "F",
        "text": "Replace line 2 with this(2);."
      },
      {
        "key": "G",
        "text": "The code prints 2 without any changes."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Options A and B will not compile because constructors cannot be called without new. \nOptions C and D will compile but will create a new object rather than setting the fields in \nthis one. The result is the program will print 0, not 2, at runtime. Calling an overloaded con\u0002structor, using this(), or a parent constructor, using super(), is only allowed on the first \nline of the constructor, making option E correct and option F incorrect. Finally, option G is \nincorrect because the program prints 0 without any changes, not 2.\n"
  },
  {
    "id": "oca-118",
    "question": "Which modifier pairs can be used together in a method declaration? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "static and final"
      },
      {
        "key": "B",
        "text": "private and static"
      },
      {
        "key": "C",
        "text": "static and abstract"
      },
      {
        "key": "D",
        "text": "private and abstract"
      },
      {
        "key": "E",
        "text": "abstract and final"
      },
      {
        "key": "F",
        "text": "private and final"
      }
    ],
    "answer": [
      "A",
      "B",
      "F"
    ],
    "explanation": "The final modifier can be used with private and static, making options A \nand F correct. Marking a private method final is redundant but allowed. A private\nmethod may also be marked static, making option B correct. Options C, D, and E are \nincorrect because methods marked static, private, or final cannot be overridden; \ntherefore, they cannot be marked abstract.\n"
  },
  {
    "id": "oca-119",
    "question": "Which of the following statements about methods are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Overloaded methods must have the same signature."
      },
      {
        "key": "B",
        "text": "Overridden methods must have the same signature."
      },
      {
        "key": "C",
        "text": "Hidden methods must have the same signature."
      },
      {
        "key": "D",
        "text": "Overloaded methods must have the same return type."
      },
      {
        "key": "E",
        "text": "Overridden methods must have the same return type."
      },
      {
        "key": "F",
        "text": "Hidden methods must have the same return type."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "Overloaded methods have the same method name but a different signature (the method \nparameters differ), making option A incorrect. Overridden instance methods and hidden \nstatic methods must have the same signature (the name and method parameters must \nmatch), making options B and C correct. Overloaded methods can have different return \ntypes, while overridden and hidden methods can have covariant return types. None of these \nmethods are required to use the same return type, making options D, E, and F incorrect.\n"
  },
  {
    "id": "oca-120",
    "question": "What is the output of the following program?\n1:  class Mammal {\n2:     private void sneeze() {}\n3:     public Mammal(int age) {\n4:        System.out.print(\"Mammal\");\n5:     } }\n6:  public class Platypus extends Mammal {\n7:     int sneeze() { return 1; }\n8:     public Platypus() {\n9:        System.out.print(\"Platypus\");\n10:    }\n11:    public static void main(String[] args) {\n12:       new Mammal(5);\n13:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Platypus"
      },
      {
        "key": "B",
        "text": "Mammal"
      },
      {
        "key": "C",
        "text": "PlatypusMammal"
      },
      {
        "key": "D",
        "text": "MammalPlatypus"
      },
      {
        "key": "E",
        "text": "The code will compile if line 7 is changed."
      },
      {
        "key": "F",
        "text": "The code will compile if line 9 is changed."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code will not compile as is, because the parent class Mammal does not define a no\u0002argument constructor. For this reason, the first line of a Platypus constructor should be \nan explicit call to super(int), making option F the correct answer. Option E is incorrect, \nas line 7 compiles without issue. The sneeze() method in the Mammal class is marked \nprivate, meaning it is not inherited and therefore is not overridden in the Platypus class. \nFor this reason, the sneeze() method in the Platypus class is free to define the same \nmethod with any return type.\n"
  },
  {
    "id": "oca-121",
    "question": "Which of the following complete the constructor so that this code prints out 50? (Choose all \nthat apply.)\nclass Speedster {\n   int numSpots;\n}\npublic class Cheetah extends Speedster {\n   int numSpots;\n \n   public Cheetah(int numSpots) {\n      // INSERT CODE HERE\n   }\n\n   public static void main(String[] args) {\n      Speedster s = new Cheetah(50);\n      System.out.print(s.numSpots);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "numSpots = numSpots;"
      },
      {
        "key": "B",
        "text": "numSpots = this.numSpots;"
      },
      {
        "key": "C",
        "text": "this.numSpots = numSpots;"
      },
      {
        "key": "D",
        "text": "numSpots = super.numSpots;"
      },
      {
        "key": "E",
        "text": "super.numSpots = numSpots;"
      },
      {
        "key": "F",
        "text": "The code does not compile regardless of the code inserted into the constructor."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code compiles, making option F incorrect. An instance variable with the same name \nas an inherited instance variable is hidden, not overridden. This means that both variables \nexist, and the one that is used depends on the location and reference type. Because the \nmain() method uses a reference type of Speedster to access the numSpots variable, the \nvariable in the Speedster class, not the Cheetah class, must be set to 50. Option A is \nincorrect, as it reassigns the method parameter to itself. Option B is incorrect, as it assigns \n\nthe method parameter the value of the instance variable in Cheetah, which is 0. Option C \nis incorrect, as it assigns the value to the instance variable in Cheetah, not Speedster. \nOption D is incorrect, as it assigns the method parameter the value of the instance variable in \nSpeedster, which is 0. Options A, B, C, and D all print 0 at runtime. Option E is the only \ncorrect answer, as it assigns the instance variable numSpots in the Speedster class a value \nof 50. The numSpots variable in the Speedster class is then correctly referenced in the \nmain() method, printing 50 at runtime.\n"
  },
  {
    "id": "oca-122",
    "question": "Which of the following declare immutable classes? (Choose all that apply.)\npublic final class Moose {\n   private final int antlers; \n}\n \npublic class Caribou {\n   private int antlers = 10; \n}\n \npublic class Reindeer {\n   private final int antlers = 5; \n}\n \npublic final class Elk {}\n \npublic final class Deer {\n   private final Object o = new Object();\n}",
    "choices": [
      {
        "key": "A",
        "text": "Moose"
      },
      {
        "key": "B",
        "text": "Caribou"
      },
      {
        "key": "C",
        "text": "Reindeer"
      },
      {
        "key": "D",
        "text": "Elk"
      },
      {
        "key": "E",
        "text": "Deer"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D",
      "E"
    ],
    "explanation": "The Moose class doesn’t compile, as the final variable antlers is not initialized \nwhen it is declared, in an instance initializer, or in a constructor. Caribou and Reindeer\nare not immutable because they are not marked final, which means a subclass could \nextend them and add mutable fields. Elk and Deer are both immutable classes since they \nare marked final and only include private final members, making options D and \nE correct. As shown with Elk, a class doesn’t need to declare any fields to be considered \nimmutable. \n"
  },
  {
    "id": "oca-123",
    "question": "What is the output of the following code?\n1:  class Arthropod {\n2:     protected void printName(long input) {\n3:        System.out.print(\"Arthropod\");\n4:     }\n5:     void printName(int input) {\n6:        System.out.print(\"Spooky\");\n7:     } }\n8:  public class Spider extends Arthropod {\n9:     protected void printName(int input) {\n10:       System.out.print(\"Spider\");\n11:    }\n12:    public static void main(String[] args) {\n13:       Arthropod a = new Spider();\n14:       a.printName((short)4);\n15:       a.printName(4);\n16:       a.printName(5L);\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "SpiderSpiderArthropod"
      },
      {
        "key": "B",
        "text": "SpiderSpiderSpider"
      },
      {
        "key": "C",
        "text": "SpiderSpookyArthropod"
      },
      {
        "key": "D",
        "text": "SpookySpiderArthropod"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 9."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so options E and F are incorrect. The \nArthropod class defines two overloaded versions of the printName() method. The \nprintName() method that takes an int value on line 5 is correctly overridden in the \nSpider class on line 9. Remember, an overridden method can have a broader access \nmodifier, and protected access is broader than package access. Because of polymorphism, \nthe overridden method replaces the method on all calls, even if an Arthropod reference \nvariable is used, as is done in the main() method. For these reasons, the overridden method \nis called on lines 14 and 15, printing Spider twice. Note that the short value is auto\u0002matically cast to the larger type of int, which then uses the overridden method. Line 16 \ncalls the overloaded method in the Arthropod class, as the long value 5L does not match \nthe overridden method, resulting in Arthropod being printed. Therefore, option A is the \ncorrect answer.\n"
  },
  {
    "id": "oca-124",
    "question": "What is the result of the following code?\n1:  abstract class Bird {\n2:     private final void fly() { System.out.println(\"Bird\"); }\n3:     protected Bird() { System.out.print(\"Wow- \"); }\n4:  }\n5:  public class Pelican extends Bird {\n6:     public Pelican() { System.out.print(\"Oh- \"); }\n7:     protected void fly() { System.out.println(\"Pelican\"); }\n8:     public static void main(String[] args) {\n9:        var chirp = new Pelican();\n10:       chirp.fly();\n11: } }",
    "choices": [
      {
        "key": "A",
        "text": "Oh- Bird"
      },
      {
        "key": "B",
        "text": "Oh- Pelican"
      },
      {
        "key": "C",
        "text": "Wow- Oh- Bird"
      },
      {
        "key": "D",
        "text": "Wow- Oh- Pelican"
      },
      {
        "key": "E",
        "text": "The code contains a compilation error."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles without issue. The question is making sure you know that superclass \nconstructors are called in the same manner in abstract classes as they are in non-abstract \nclasses. Line 9 calls the constructor on line 6. The compiler automatically inserts super() as \nthe first line of the constructor defined on line 6. The program then calls the constructor on \nline 3 and prints Wow-. Control then returns to line 6, and Oh- is printed. Finally, the \nmethod call on line 10 uses the version of fly() in the Pelican class, since it is marked \nprivate and the reference type of var is resolved as Pelican. The final output is \nWow-Oh-Pelican, making option D the correct answer. Remember that private methods \ncannot be overridden. If the reference type of chirp was Bird, then the code would not \ncompile as it would not be accessible outside the class.\n"
  },
  {
    "id": "oca-125",
    "question": "Which of the following statements about overridden methods are true? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An overridden method must contain method parameters that are the same or covariant \nwith the method parameters in the inherited method."
      },
      {
        "key": "B",
        "text": "An overridden method may declare a new exception, provided it is not checked."
      },
      {
        "key": "C",
        "text": "An overridden method must be more accessible than the method in the parent class."
      },
      {
        "key": "D",
        "text": "An overridden method may declare a broader checked exception than the method in the \nparent class."
      },
      {
        "key": "E",
        "text": "If an inherited method returns void, then the overridden version of the method must \nreturn void."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "The signature must match exactly, making option A incorrect. There is no such thing as \na covariant signature. An overridden method must not declare any new checked exceptions \nor a checked exception that is broader than the inherited method. For this reason, option B is \ncorrect, and option D is incorrect. Option C is incorrect because an overridden method may \nhave the same access modifier as the version in the parent class. Finally, overridden methods \nmust have covariant return types, and only void is covariant with void, making option \nE correct.\n"
  },
  {
    "id": "oca-126",
    "question": "Which of the following pairs, when inserted into the blanks, allow the code to compile? \n(Choose all that apply.)\n1:  public class Howler {\n2:     public Howler(long shadow) {\n3:        ;\n4:     }\n5:     private Howler(int moon) {\n6:        super();\n7:     }\n8:  }\n9:  class Wolf extends Howler {\n10:    protected Wolf(String stars) {\n11:       super(2L);\n12:    }\n13:    public Wolf() {\n14:       ;\n15:    }\n16: }",
    "choices": [
      {
        "key": "A",
        "text": "this(3) at line 3, this(\"\") at line 14"
      },
      {
        "key": "B",
        "text": "this() at line 3, super(1) at line 14"
      },
      {
        "key": "C",
        "text": "this((short)1) at line 3, this(null) at line 14"
      },
      {
        "key": "D",
        "text": "super() at line 3, super() at line 14"
      },
      {
        "key": "E",
        "text": "this(2L) at line 3, super((short)2) at line 14"
      },
      {
        "key": "F",
        "text": "this(5) at line 3, super(null) at line 14"
      },
      {
        "key": "G",
        "text": "Remove lines 3 and 14."
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "Option A is correct, as this(3) calls the constructor declared on line 5, while \nthis(\"\") calls the constructor declared on line 10. Option B does not compile, as inserting \nthis() at line 3 results in a compiler error, since there is no matching constructor. Option \nC is correct, as short can be implicitly cast to int, resulting in this((short)1) calling \nthe constructor declared on line 5. In addition, this(null) calls the String constructor \ndeclared on line 10. Option D does not compile because inserting super() on line 14 results \nin an invalid constructor call. The Howler class does not contain a no-argument constructor. \nOption E is also incorrect. Inserting this(2L) at line 3 results in a recursive constructor \ndefinition. The compiler detects this and reports an error. Option F is incorrect, as using \nsuper(null) on line 14 does not match any parent constructors. If an explicit cast was \nused, such as super((Integer)null), then the code would have compiled but would \nthrow an exception at runtime during unboxing. Finally, option G is incorrect because the \nsuperclass Howler does not contain a no-argument constructor. Therefore, the constructor \ndeclared on line 13 will not compile without an explicit call to an overloaded or parent \nconstructor.\n"
  },
  {
    "id": "oca-127",
    "question": "What is the result of the following?\n1:  public class PolarBear {\n2:     StringBuilder value = new StringBuilder(\"t\");\n3:     { value.append(\"a\"); }\n4:     { value.append(\"c\"); }\n5:     private PolarBear() {\n6:        value.append(\"b\");\n7:     }\n8:     public PolarBear(String s) {\n9:        this();\n10:       value.append(s);\n11:    }\n12:    public PolarBear(CharSequence p) {\n13:       value.append(p);\n14:    }\n15:    public static void main(String[] args) {\n16:       Object bear = new PolarBear();\n17:       bear = new PolarBear(\"f\");\n18:       System.out.println(((PolarBear)bear).value);\n19:    } }",
    "choices": [
      {
        "key": "A",
        "text": "tacb"
      },
      {
        "key": "B",
        "text": "tacf"
      },
      {
        "key": "C",
        "text": "tacbf"
      },
      {
        "key": "D",
        "text": "tcafb"
      },
      {
        "key": "E",
        "text": "taftacb"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without issue, making options F and G incorrect. Line 16 ini\u0002tializes a PolarBear instance and assigns it to the bear reference. The variable declaration \nand instance initializers are run first, setting value to tac. The constructor declared on line \n5 is called, resulting in value being set to tacb. Remember, a static main() method can \naccess private constructors declared in the same class. Line 17 creates another PolarBear\ninstance, replacing the bear reference declared on line 16. First, value is initialized to tac\nas before. Line 17 calls the constructor declared on line 8, since String is the narrowest \nmatch of a String literal. This constructor then calls the overloaded constructor declared \non line 5, resulting in value being updated to tacb. Control returns to the previous con\u0002structor, with line 10 updating value to tacbf, and making option C the correct answer. \nNote that if the constructor declared on line 8 did not exist, then the constructor on line \n12 would match. Finally, the bear reference is properly cast to PolarBear on line 18, \nmaking the value parameter accessible.\n"
  },
  {
    "id": "oca-128",
    "question": "How many lines of the following program contain a compilation error?\n1:  public class Rodent {\n2:     public Rodent(Integer x) {}\n3:     protected static Integer chew() throws Exception {\n4:        System.out.println(\"Rodent is chewing\");\n5:        return 1;\n6:     }\n7:  }\n8:  class Beaver extends Rodent {\n9:     public Number chew() throws RuntimeException {\n10:       System.out.println(\"Beaver is chewing on wood\");\n11:       return 2;\n12:    } }",
    "choices": [
      {
        "key": "A",
        "text": "None"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code doesn’t compile, so option A is incorrect. The first compilation error is on line 8.\nSince Rodent declares at least one constructor and it is not a no-argument constructor, \nBeaver must declare a constructor with an explicit call to a super() constructor. Line 9 \ncontains two compilation errors. First, the return types are not covariant since Number is \na supertype, not a subtype, of Integer. Second, the inherited method is static, but the \noverridden method is not, making this an invalid override. The code contains three compila\u0002tion errors, although they are limited to two lines, making option C the correct answer.\n"
  },
  {
    "id": "oca-129",
    "question": "Which of these classes compile and will include a default constructor created by the  \ncompiler? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public class Bird {}\npublic class Bird {}"
      },
      {
        "key": "B",
        "text": "public class Bird {\npublic class Bird {\n   public bird() {}\n}"
      },
      {
        "key": "C",
        "text": "public class Bird {\npublic class Bird {\n   public bird(String name) {}\n}"
      },
      {
        "key": "D",
        "text": "public class Bird {\npublic class Bird {\n   public Bird() {}\n}"
      },
      {
        "key": "E",
        "text": "public class Bird {\npublic class Bird {\n   Bird(String name) {}\n}"
      },
      {
        "key": "F",
        "text": "public class Bird {\npublic class Bird {\n   private Bird(int age) {}\n}"
      },
      {
        "key": "G",
        "text": "public class Bird {\npublic class Bird {\n   public Bird bird() { return null; }\n}"
      }
    ],
    "answer": [
      "A",
      "G"
    ],
    "explanation": "The compiler will insert a default no-argument constructor if the class compiles and \ndoes not define any constructors. Options A and G fulfill this requirement, making them \nthe correct answers. The bird() declaration in option G is a method declaration, not a \nconstructor. Options B and C do not compile. Since the constructor name does not match \nthe class name, the compiler treats these as methods with missing return types. Options D, \nE, and F all compile, but since they declare at least one constructor, the compiler does not \nsupply one.\n"
  },
  {
    "id": "oca-130",
    "question": "Which of the following statements about inheritance are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A class can directly extend any number of classes."
      },
      {
        "key": "B",
        "text": "A class can implement any number of interfaces."
      },
      {
        "key": "C",
        "text": "All variables inherit java.lang.Object."
      },
      {
        "key": "D",
        "text": "If class A is extended by B, then B is a superclass of A."
      },
      {
        "key": "E",
        "text": "If class C implements interface D, then C is a subtype of D."
      },
      {
        "key": "F",
        "text": "Multiple inheritance is the property of a class to have multiple direct superclasses."
      }
    ],
    "answer": [
      "B",
      "E",
      "F"
    ],
    "explanation": "A class can only directly extend a single class, making option A incorrect. A class can \nimplement any number of interfaces, though, making option B correct. Option C is incor\u0002rect because primitive variables types do not inherit java.lang.Object. If a class extends \nanother class, then it is a subclass, not a superclass, making option D incorrect. A class that \nimplements an interface is a subtype of that interface, making option E correct. Finally, \noption F is correct as it is an accurate description of multiple inheritance, which is not per\u0002mitted in Java.\n"
  },
  {
    "id": "oca-131",
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1: abstract class Nocturnal {\n2:    boolean isBlind();\n3: }\n4: public class Owl extends Nocturnal {\n5:    public boolean isBlind() { return false; }\n6:    public static void main(String[] args) {\n7:       var nocturnal = (Nocturnal)new Owl();\n8:       System.out.println(nocturnal.isBlind());\n9: } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and prints true."
      },
      {
        "key": "B",
        "text": "It compiles and prints false."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code does not compile because the isBlind() method in Nocturnal is not \nmarked abstract and does not contain a method body. The rest of the lines compile \nwithout issue, making option C the only correct answer. If the abstract modifier was \nadded to line 2, then the code would compile and print false at runtime, making option B \nthe correct answer.\n"
  },
  {
    "id": "oca-132",
    "question": "What is the result of the following?\n1:  class Arachnid {\n2:     static StringBuilder sb = new StringBuilder();\n3:     { sb.append(\"c\"); }\n4:     static\n5:     { sb.append(\"u\"); }\n6:     { sb.append(\"r\"); }\n7:  }\n8:  public class Scorpion extends Arachnid {\n9:     static\n10:    { sb.append(\"q\"); }\n11:    { sb.append(\"m\"); }\n12:    public static void main(String[] args) {\n13:       System.out.print(Scorpion.sb + \" \");\n14:       System.out.print(Scorpion.sb + \" \");\n15:       new Arachnid();\n16:       new Scorpion();\n17:       System.out.print(Scorpion.sb);\n18:    } }",
    "choices": [
      {
        "key": "A",
        "text": "qu qu qumrcrc"
      },
      {
        "key": "B",
        "text": "u u ucrcrm"
      },
      {
        "key": "C",
        "text": "uq uq uqmcrcr"
      },
      {
        "key": "D",
        "text": "uq uq uqcrcrm"
      },
      {
        "key": "E",
        "text": "qu qu qumcrcr"
      },
      {
        "key": "F",
        "text": "qu qu qucrcrm"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles, so option G is incorrect. Based on order of initialization, the static\ncomponents are initialized first, starting with the Arachnid class, since it is the parent of \nthe Scorpion class, which initializes the StringBuilder to u. The static initializer in \nScorpion then updates sb to contain uq, which is printed twice by lines 13 and 14 along \nwith spaces separating the values. Next, an instance of Arachnid is initialized on line 15. \nThere are two instance initializers in Arachnid, and they run in order, appending cr to the \nStringBuilder, resulting in a value of uqcr. An instance of Scorpion is then initialized \non line 16. The instance initializers in the superclass Arachnid run first, appending cr again \nand updating the value of sb to uqcrcr. Finally, the instance initializer in Scorpion runs \nand appends m. The program completes with the final value printed being uq uq uqcrcrm, \nmaking option D the correct answer.\n"
  },
  {
    "id": "oca-133",
    "question": "Which of the following are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "this() can be called from anywhere in a constructor."
      },
      {
        "key": "B",
        "text": "this() can be called from anywhere in an instance method."
      },
      {
        "key": "C",
        "text": "this.variableName can be called from any instance method in the class."
      },
      {
        "key": "D",
        "text": "this.variableName can be called from any static method in the class."
      },
      {
        "key": "E",
        "text": "You can call the default constructor written by the compiler using this()."
      },
      {
        "key": "F",
        "text": "You can access a private constructor with the main() method in the same class."
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "Calling an overloaded constructor with this() may be used only as the first line of a \nconstructor, making options A and B incorrect. Accessing this.variableName can be per\u0002formed from any instance method, constructor, or instance initializer, but not from a static\nmethod or static initializer. For this reason, option C is correct, and option D is incorrect. \nOption E is tricky. The default constructor is written by the compiler only if no user-defined \nconstructors were provided. And this() can only be called from a constructor in the same \nclass. Since there can be no user-defined constructors in the class if a default constructor was \ncreated, it is impossible for option E to be true. Since the main() method is in the same \nclass, it can call private methods in the class, making option F correct.\n"
  },
  {
    "id": "oca-134",
    "question": "Which statements about the following classes are correct? (Choose all that apply.)\n1:  public class Mammal {\n2:     private void eat() {}\n3:     protected static void drink() {}\n4:     public Integer dance(String p) { return null; }\n5:  }\n6:  class Primate extends Mammal {\n7:     public void eat(String p) {}\n8:  }\n9:  class Monkey extends Primate {\n10:    public static void drink() throws RuntimeException {}\n11:    public Number dance(CharSequence p) { return null; }\n12:    public int eat(String p) {}\n13: }",
    "choices": [
      {
        "key": "A",
        "text": "The eat() method in Mammal is correctly overridden on line 7."
      },
      {
        "key": "B",
        "text": "The eat() method in Mammal is correctly overloaded on line 7."
      },
      {
        "key": "C",
        "text": "The drink() method in Mammal is correctly overridden on line 10."
      },
      {
        "key": "D",
        "text": "The drink() method in Mammal is correctly hidden on line 10."
      },
      {
        "key": "E",
        "text": "The dance() method in Mammal is correctly overridden on line 11."
      },
      {
        "key": "F",
        "text": "The dance() method in Mammal is correctly overloaded on line 11."
      },
      {
        "key": "G",
        "text": "The eat() method in Primate is correctly hidden on line 12."
      },
      {
        "key": "H",
        "text": "The eat() method in Primate is correctly overloaded on line 12."
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "The eat() method is private in the Mammal class. Since it is not inherited in the \nPrimate class, it is neither overridden nor overloaded, making options A and B incorrect. \nThe drink() method in Mammal is correctly hidden in the Monkey class, as the signature is \nthe same and both are static, making option D correct and option C incorrect. The version \nin the Monkey class throws a new exception, but it is unchecked; therefore, it is allowed. The \ndance() method in Mammal is correctly overloaded in the Monkey class because the signa\u0002tures are not the same, making option E incorrect and option F correct. For methods to be \noverridden, the signatures must match exactly. Finally, line 12 is an invalid override and does \nnot compile, as int is not covariant with void, making options G and H both incorrect.\n"
  },
  {
    "id": "oca-135",
    "question": "What is the output of the following code?\n1:  class Reptile {\n2:     {System.out.print(\"A\");}\n3:     public Reptile(int hatch) {}\n4:     void layEggs() {\n5:        System.out.print(\"Reptile\");\n6:     } }\n7:  public class Lizard extends Reptile {\n8:     static {System.out.print(\"B\");}\n9:     public Lizard(int hatch) {}\n10:    public final void layEggs() {\n11:       System.out.print(\"Lizard\");\n12:    }\n13:    public static void main(String[] args) {\n14:       var reptile = new Lizard(1);\n15:       reptile.layEggs();\n16:    } }",
    "choices": [
      {
        "key": "A",
        "text": "AALizard"
      },
      {
        "key": "B",
        "text": "BALizard"
      },
      {
        "key": "C",
        "text": "BLizardA"
      },
      {
        "key": "D",
        "text": "ALizard"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The Reptile class defines a constructor, but it is not a no-argument constructor. There\u0002fore, the Lizard constructor must explicitly call super(), passing in an int value. For this \nreason, line 9 does not compile, and option F is the correct answer. If the Lizard class were \ncorrected to call the appropriate super() constructor, then the program would print \nBALizard at runtime, with the static initializer running first, followed by the instance \ninitializer, and finally the method call using the overridden method.\n"
  },
  {
    "id": "oca-136",
    "question": "Which statement about the following program is correct?\n1:  class Bird {\n2:     int feathers = 0;\n3:     Bird(int x) { this.feathers = x; }\n4:     Bird fly() {\n5:        return new Bird(1);\n6:     } }\n7:  class Parrot extends Bird {\n8:     protected Parrot(int y) { super(y); }\n9:     protected Parrot fly() {\n10:       return new Parrot(2);\n11:    } }\n12: public class Macaw extends Parrot {\n13:    public Macaw(int z) { super(z); }\n14:    public Macaw fly() {\n15:       return new Macaw(3);\n16:    }\n17:    public static void main(String... sing) {\n18:       Bird p = new Macaw(4);\n19:       System.out.print(((Parrot)p.fly()).feathers);\n20:    } }",
    "choices": [
      {
        "key": "A",
        "text": "One line contains a compiler error."
      },
      {
        "key": "B",
        "text": "Two lines contain compiler errors."
      },
      {
        "key": "C",
        "text": "Three lines contain compiler errors."
      },
      {
        "key": "D",
        "text": "The code compiles but throws a ClassCastException at runtime."
      },
      {
        "key": "E",
        "text": "The program compiles and prints 3."
      },
      {
        "key": "F",
        "text": "The program compiles and prints 0."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The program compiles and runs without issue, making options A through D incorrect. The \nfly() method is correctly overridden in each subclass since the signature is the same, the \naccess modifier is less restrictive, and the return types are covariant. For covariance, Macaw is \na subtype of Parrot, which is a subtype of Bird, so overridden return types are valid. Like\u0002wise, the constructors are all implemented properly, with explicit calls to the parent construc\u0002tors as needed. Line 19 calls the overridden version of fly() defined in the Macaw class, as \noverriding replaces the method regardless of the reference type. This results in feathers\nbeing assigned a value of 3. The Macaw object is then cast to Parrot, which is allowed \nbecause Macaw inherits Parrot. The feathers variable is visible since it is defined in the \nBird class, and line 19 prints 3, making option E the correct answer.\n"
  },
  {
    "id": "oca-137",
    "question": "Which of the following are properties of immutable classes? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The class can contain setter methods, provided they are marked final."
      },
      {
        "key": "B",
        "text": "The class must not be able to be extended outside the class declaration."
      },
      {
        "key": "C",
        "text": "The class may not contain any instance variables."
      },
      {
        "key": "D",
        "text": "The class must be marked static."
      },
      {
        "key": "E",
        "text": "The class may not contain any static variables."
      },
      {
        "key": "F",
        "text": "The class may only contain private constructors."
      },
      {
        "key": "G",
        "text": "The data for mutable instance variables may be read, provided they cannot be modified \nby the caller."
      }
    ],
    "answer": [
      "B",
      "G"
    ],
    "explanation": "Immutable objects do not include setter methods, making option A incorrect. An \nimmutable class must be marked final or contain only private constructors, so no sub\u0002class can extend it and make it mutable, making option B correct. Options C and E are \nincorrect, as immutable classes can contain both instance and static variables. Option D \nis incorrect, as marking a class static is not a property of immutable objects. Option F is \nincorrect. While an immutable class may contain only private constructors, this is not a \nrequirement. Finally, option G is correct. It is allowed for the caller to access data in mutable \nelements of an immutable object, provided they have no ability to modify these elements.\n"
  },
  {
    "id": "oca-138",
    "question": "What does the following program print?\n1:  class Person {\n2:     static String name;\n3:     void setName(String q) { name = q; } }\n4:  public class Child extends Person {\n5:     static String name;\n6:     void setName(String w) { name = w; }\n7:     public static void main(String[] p) {\n8:        final Child m = new Child();\n9:        final Person t = m;\n10:       m.name = \"Elysia\";\n11:       t.name = \"Sophia\";\n12:       m.setName(\"Webby\");\n13:       t.setName(\"Olivia\");\n14:       System.out.println(m.name + \" \" + t.name);\n15:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Elysia Sophia"
      },
      {
        "key": "B",
        "text": "Webby Olivia"
      },
      {
        "key": "C",
        "text": "Olivia Olivia"
      },
      {
        "key": "D",
        "text": "Olivia Sophia"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles and runs without issue, making option E incorrect. The Child class \noverrides the setName() method and hides the static name variable defined in the \ninherited Person class. Since variables are only hidden, not overridden, there are two dis\u0002tinct name variables accessible, depending on the location and reference type. Line 8 creates \na Child instance, which is implicitly cast to a Person reference type on line 9. Line 10 uses \nthe Child reference type, updating Child.name to Elysia. Line 11 uses the Person ref\u0002erence type, updating Person.name to Sophia. Lines 12 and 13 both call the overridden \nsetName() instance method declared on line 6. This sets Child.name to Webby on line \n12 and then to Olivia on line 13. The final values of Child.name and Person.name are \nOlivia and Sophia, respectively, making option D the correct answer.\n"
  },
  {
    "id": "oca-139",
    "question": "What is the output of the following program?\n1:  class Canine {\n2:     public Canine(boolean t) { logger.append(\"a\"); }\n3:     public Canine() { logger.append(\"q\"); }\n4:     \n5:     private StringBuilder logger = new StringBuilder();\n6:     protected void print(String v) { logger.append(v); }\n7:     protected String view() { return logger.toString(); }\n8:  }\n9:  \n10: class Fox extends Canine {\n11:    public Fox(long x) { print(\"p\"); }\n12:    public Fox(String name) {\n13:       this(2);\n14:       print(\"z\");\n15:    }\n16: }\n17:\n18: public class Fennec extends Fox {\n19:    public Fennec(int e) {\n20:       super(\"tails\");\n21:       print(\"j\");\n22:    }\n23:    public Fennec(short f) {\n24:       super(\"eevee\");\n25:       print(\"m\");\n26:    }\n27: \n28:    public static void main(String... unused) {\n29:       System.out.println(new Fennec(1).view());\n30:    } }",
    "choices": [
      {
        "key": "A",
        "text": "qpz"
      },
      {
        "key": "B",
        "text": "qpzj"
      },
      {
        "key": "C",
        "text": "jzpa"
      },
      {
        "key": "D",
        "text": "apj"
      },
      {
        "key": "E",
        "text": "apjm"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The program compiles, making option F incorrect. The constructors are called from the \nchild class upward, but since each line of a constructor is a call to another constructor, via \nthis() or super(), they are ultimately executed in a top-down manner. On line 29, the \nmain() method calls the Fennec() constructor declared on line 19. Remember, integer \nliterals in Java are considered int by default. This constructor calls the Fox() constructor \ndefined on line 12, which in turn calls the overloaded Fox() constructor declared on line 11.\nSince the constructor on line 11 does not explicitly call a parent constructor, the compiler \ninserts a call to the no-argument super() constructor, which exists on line 3 of the Canine\nclass. Line 3 is then executed, adding q to the output, and the compiler chain is unwound. \nLine 11 then executes, adding p, followed by line 14, adding z. Finally, line 21 is executed, \nand j is added, resulting in a final value for logger of qpzj, and making option B correct. \nFor the exam, remember to follow constructors from the lowest level upward to determine \nthe correct pathway, but then execute them from the top down using the established order.\n"
  },
  {
    "id": "oca-140",
    "question": "What is printed by the following program?\n1:  class Antelope {\n2:     public Antelope(int p) {\n3:        System.out.print(\"4\");\n4:     }\n5:     { System.out.print(\"2\"); }\n6:     static { System.out.print(\"1\"); }\n7:  }\n8:  public class Gazelle extends Antelope {\n9:     public Gazelle(int p) {\n10:       super(6);\n11:       System.out.print(\"3\");\n12:    }\n13:    public static void main(String hopping[]) {\n14:       new Gazelle(0);\n15:    }\n16:    static { System.out.print(\"8\"); }\n17:    { System.out.print(\"9\"); }\n18: }",
    "choices": [
      {
        "key": "A",
        "text": "182640"
      },
      {
        "key": "B",
        "text": "182943"
      },
      {
        "key": "C",
        "text": "182493"
      },
      {
        "key": "D",
        "text": "421389"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The output cannot be determined until runtime."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without issue, making options E and F incorrect. First, the \nclass is initialized, starting with the superclass Antelope and then the subclass \nGazelle. This involves invoking the static variable declarations and static initializers. \nThe program first prints 1, followed by 8. Then we follow the constructor pathway from the \nobject created on line 14 upward, initializing each class instance using a top-down approach. \nWithin each class, the instance initializers are run, followed by the referenced construc\u0002tors. The Antelope instance is initialized, printing 24, followed by the Gazelle instance, \nprinting 93. The final output is 182493, making option C the correct answer.\n"
  },
  {
    "id": "oca-141",
    "question": "Which of the following are true about a concrete class? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A concrete class can be declared as abstract."
      },
      {
        "key": "B",
        "text": "A concrete class must implement all inherited abstract methods."
      },
      {
        "key": "C",
        "text": "A concrete class can be marked as final."
      },
      {
        "key": "D",
        "text": "A concrete class must be immutable."
      },
      {
        "key": "E",
        "text": "A concrete method that implements an abstract method must match the method declara-\ntion of the abstract method exactly."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "Concrete classes are, by definition, not abstract, so option A is incorrect. A concrete \nclass must implement all inherited abstract methods, so option B is correct. Concrete classes \ncan be optionally marked final, so option C is correct. Option D is incorrect; concrete \nclasses need not be immutable. A concrete subclass only needs to override the inherited \nabstract method, not match the declaration exactly. For example, a covariant return type can \nbe used. For this reason, option E is incorrect.\n"
  },
  {
    "id": "oca-142",
    "question": "What is the output of the following code?\n4:  public abstract class Whale {\n5:     public abstract void dive();\n6:     public static void main(String[] args) {\n7:        Whale whale = new Orca();\n8:        whale.dive(3);\n9:     }\n10: }\n11: class Orca extends Whale {\n12:    static public int MAX = 3;\n13:    public void dive() {\n14:       System.out.println(\"Orca diving\");\n15:    }\n16:    public void dive(int... depth) {\n17:       System.out.println(\"Orca diving deeper \"+MAX);\n18: } }",
    "choices": [
      {
        "key": "A",
        "text": "Orca diving"
      },
      {
        "key": "B",
        "text": "Orca diving deeper 3"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 11."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 12."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line 17."
      },
      {
        "key": "H",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The classes are structured correctly, but the body of the main() method contains a com\u0002piler error. The Orca object is implicitly cast to a Whale reference on line 7. This is per\u0002mitted because Orca is a subclass of Whale. By performing the cast, the whale reference on \nline 8 does not have access to the dive(int... depth) method. For this reason, line 8 \ndoes not compile, making option D correct.\n"
  },
  {
    "id": "oca-143",
    "question": "Which of the following are valid record declarations? (Choose all that apply.)\npublic record Iguana(int age) {\n   private static final int age = 10; }\n \npublic final record Gecko() {}\n \npublic abstract record Chameleon()  {\n   private static String name; }\n \npublic record BeardedDragon(boolean fun) {\n   @Override public boolean fun() { return false; } }\n \npublic record Newt(long size) {\n   @Override public boolean equals(Object obj) { return false; }\n   public void setSize(long size) {\n      this.size = size;\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Iguana"
      },
      {
        "key": "B",
        "text": "Gecko"
      },
      {
        "key": "C",
        "text": "Chameleon"
      },
      {
        "key": "D",
        "text": "BeardedDragon"
      },
      {
        "key": "E",
        "text": "Newt"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Iguana does not compile, as it declares a static field with the same name as an in\u0002stance field. Records are implicitly final and cannot be marked abstract, which is why \nGecko compiles and Chameleon does not, making option B correct. Notice in Gecko that \nrecords are not required to declare any fields. BeardedDragon also compiles, as records \nmay override any accessor methods, making option D correct. Newt does not compile \nbecause records are immutable, so any mutator methods that modify fields are not permitted. \nOverriding the equals() method is allowed, though.\n"
  },
  {
    "id": "oca-144",
    "question": "Which of the following statements can be inserted in the blank line so that the code will com-\npile successfully? (Choose all that apply.)\ninterface CanHop {}\npublic class Frog implements CanHop {\n   public static void main(String[] args) {\n       frog = new TurtleFrog();\n   }\n}\nclass BrazilianHornedFrog extends Frog {}\nclass TurtleFrog extends Frog {}",
    "choices": [
      {
        "key": "A",
        "text": "Frog"
      },
      {
        "key": "B",
        "text": "TurtleFrog"
      },
      {
        "key": "C",
        "text": "BrazilianHornedFrog"
      },
      {
        "key": "D",
        "text": "CanHop"
      },
      {
        "key": "E",
        "text": "var"
      },
      {
        "key": "F",
        "text": "Long"
      },
      {
        "key": "G",
        "text": "None of the above; the code contains a compilation error."
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "The code compiles without issue, so option G is incorrect. The blank can be filled \nwith any class or interface that is a supertype of TurtleFrog. Option A is the direct super\u0002class of TurtleFrog, and option B is the same class, so both are correct. \nBrazilianHornedFrog is not a superclass of TurtleFrog, so option C is incorrect. \nTurtleFrog inherits the CanHop interface, so option D is correct. Option E is also correct, \nas var is permitted when the type is known. Finally, Long is an unrelated class that is not a \nsuperclass of TurtleFrog and is therefore incorrect.\n"
  },
  {
    "id": "oca-145",
    "question": "What is the result of the following program?\npublic class Favorites {\n   enum Flavors {\n      VANILLA, CHOCOLATE, STRAWBERRY\n      static final Flavors DEFAULT = STRAWBERRY;\n  }\n   public static void main(String[] args) {\n      for(final var e : Flavors.values())\n         System.out.print(e.ordinal()+\" \");\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0 1 2"
      },
      {
        "key": "B",
        "text": "1 2 3"
      },
      {
        "key": "C",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "D",
        "text": "More than one line of code does not compile."
      },
      {
        "key": "E",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "When an enum contains only a list of values, the semicolon (;) after the list is optional. \nWhen an enum contains any other members, such as a constructor or variable, the semi\u0002colon is required. Since the enum list does not end with a semicolon, the code does not com\u0002pile, making option C the correct answer. If the missing semicolon were added, the program \nwould print 0 1 2 at runtime.\n"
  },
  {
    "id": "oca-146",
    "question": "What is the output of the following program?\npublic sealed class ArmoredAnimal permits Armadillo {\n   public ArmoredAnimal(int size) {}\n   @Override public String toString() { return \"Strong\"; }\n   public static void main(String[] a) {\n      var c = new Armadillo(10, null);\n      System.out.println(c);\n   }\n}\nclass Armadillo extends ArmoredAnimal {\n   @Override public String toString() { return \"Cute\"; }\n   public Armadillo(int size, String name) {\n      super(size);\n   }   \n}",
    "choices": [
      {
        "key": "A",
        "text": "Strong"
      },
      {
        "key": "B",
        "text": "Cute"
      },
      {
        "key": "C",
        "text": "The program does not compile."
      },
      {
        "key": "D",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A class extending a sealed class must be marked final, sealed, or non-sealed. Since \nArmadillo is missing a modifier, the code does not compile, and option C is correct.\n"
  },
  {
    "id": "oca-147",
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1:  interface HasExoskeleton {\n2:     double size = 2.0f;\n3:     abstract int getNumberOfSections();\n4:  }\n5:  abstract class Insect implements HasExoskeleton {\n6:     abstract int getNumberOfLegs();\n7:  }\n8:  public class Beetle extends Insect {\n9:     int getNumberOfLegs() { return 6; }\n10:    int getNumberOfSections(int count) { return 1; }\n11: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "The code will produce a ClassCastException if called at runtime."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 10."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, the declarations of HasExoskeleton and Insect are correct and do not contain \nany errors, making options C and D incorrect. The concrete class Beetle extends \nInsect and inherits two abstract methods, getNumberOfSections() and \ngetNumberOfLegs(). The Beetle class includes an overloaded version of \ngetNumberOfSections() that takes an int value. The method declaration is valid, mak\u0002ing option F incorrect, although it does not satisfy the abstract method requirement inherited \nfrom HasExoskeleton. For this reason, only one of the two abstract methods is properly \noverridden. The Beetle class therefore does not compile, and option E is correct.\n"
  },
  {
    "id": "oca-148",
    "question": "Which statements about the following program are correct? (Choose all that apply.)\n1: public abstract interface Herbivore {\n2:    int amount = 10;\n3:    public void eatGrass();\n4:    public abstract int chew() { return 13; }\n5: }\n6:\n7: abstract class IsAPlant extends Herbivore {\n8:    Object eatGrass(int season) { return null; }\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because line 8 contains an invalid method override."
      }
    ],
    "answer": [
      "D",
      "E"
    ],
    "explanation": "Line 4 does not compile, since an abstract method cannot include a body. Line 7 \nalso does not compile because the wrong keyword is used. A class implements an interface; it \ndoes not extend it. For these reasons, options D and E are correct.\n"
  },
  {
    "id": "oca-149",
    "question": "What is the output of the following program?\n1: interface Aquatic {\n2:    int getNumOfGills(int p);\n3: }\n4: public class ClownFish implements Aquatic {\n5:    String getNumOfGills() { return \"14\"; }\n6:    int getNumOfGills(int input) { return 15; }\n7:    public static void main(String[] args) {\n8:       System.out.println(new ClownFish().getNumOfGills(- 1));\n9: } }",
    "choices": [
      {
        "key": "A",
        "text": "14"
      },
      {
        "key": "B",
        "text": "15"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The inherited interface method getNumOfGills(int) is implicitly public; therefore, \nit must be declared public in any concrete class that implements the interface. Since the \nmethod uses the package (default) modifier in the ClownFish class, line 6 does not com\u0002pile, making option E the correct answer. If the method declaration were corrected to include \npublic on line 6, then the program would compile and print 15 at runtime, and option B \nwould be the correct answer.\n"
  },
  {
    "id": "oca-150",
    "question": "When inserted in order, which modifiers can fill in the blank to create a properly encapsu-\nlated class? (Choose all that apply.)\npublic class Rabbits {\n    int numRabbits = 0;\n    void multiply() {\n      numRabbits *= 6;\n   }\n    int getNumberOfRabbits() {\n      return numRabbits;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "private, public, and public"
      },
      {
        "key": "B",
        "text": "private, protected, and private"
      },
      {
        "key": "C",
        "text": "private, private, and protected"
      },
      {
        "key": "D",
        "text": "public, public, and public"
      },
      {
        "key": "E",
        "text": "The class cannot be properly encapsulated since multiply() does not begin with set."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Instance variables must include the private access modifier, making option D \nincorrect. While it is common for methods to be public, this is not required. Options A, B, \nand C fulfill this requirement.\n"
  },
  {
    "id": "oca-151",
    "question": "Which of the following statements can be inserted in the blank so that the code will compile \nsuccessfully? (Choose all that apply.)\nabstract class Snake {}\nclass Cobra extends Snake {}\nclass GardenSnake extends Cobra {}\npublic class SnakeHandler {\n   private Snake snakey;\n   public void setSnake(Snake mySnake) { this.snakey = mySnake; }\n   public static void main(String[] args) {\n      new SnakeHandler().setSnake( );\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "new Cobra()"
      },
      {
        "key": "B",
        "text": "new Snake()"
      },
      {
        "key": "C",
        "text": "new Object()"
      },
      {
        "key": "D",
        "text": "new String(\"Snake\")"
      },
      {
        "key": "E",
        "text": "new GardenSnake()"
      },
      {
        "key": "F",
        "text": "null"
      },
      {
        "key": "G",
        "text": "None of the above. The class does not compile, regardless of the value inserted in the \nblank."
      }
    ],
    "answer": [
      "A",
      "E",
      "F"
    ],
    "explanation": "The setSnake() method requires an instance of Snake. Cobra is a direct subclass, \nwhile GardenSnake is an indirect subclass. For these reasons, options A and E are correct. \nOption B is incorrect because Snake is abstract and requires a concrete subclass for \ninstantiation. Option C is incorrect because Object is a supertype of Snake, not a subtype. \nOption D is incorrect as String is an unrelated class and does not inherit Snake. Finally, a \nnull value can always be passed as an object value, regardless of type, so option \nF is also correct.\n"
  },
  {
    "id": "oca-152",
    "question": "What types can be inserted in the blanks on the lines marked X and Z that allow the code to \ncompile? (Choose all that apply.)\ninterface Walk { private static List move() { return null; } }\ninterface Run extends Walk { public ArrayList move(); }\nclass Leopard implements Walk {\n   public  move() {  // X\n      return null;\n   }\n}\nclass Panther implements Run {\n   public  move() {  // Z\n      return null;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Integer on the line marked X"
      },
      {
        "key": "B",
        "text": "ArrayList on the line marked X"
      },
      {
        "key": "C",
        "text": "List on the line marked X"
      },
      {
        "key": "D",
        "text": "List on the line marked Z"
      },
      {
        "key": "E",
        "text": "ArrayList on the line marked Z"
      },
      {
        "key": "F",
        "text": "None of the above, since the Run interface does not compile"
      },
      {
        "key": "G",
        "text": "The code does not compile for a different reason."
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "Walk declares a private method that is not inherited in any of its subtypes. For \nthis reason, any valid class is supported on line X, making options A, B, and C correct. Line \nZ is more restrictive, with only ArrayList or subtypes of ArrayList supported, making \noption E correct.\n"
  },
  {
    "id": "oca-153",
    "question": "What is the result of the following code? (Choose all that apply.)\n1:  public class Movie {\n2:     private int butter = 5;\n3:     private Movie() {}\n4:     protected class Popcorn {\n5:        private Popcorn() {}\n6:        public static int butter = 10;\n7:        public void startMovie() {\n8:           System.out.println(butter);\n9:        }\n10:    }\n11:    public static void main(String[] args) {\n12:       var movie = new Movie();\n13:       Movie.Popcorn in = new Movie().new Popcorn();\n14:       in.startMovie();\n15:    } }",
    "choices": [
      {
        "key": "A",
        "text": "The output is 5."
      },
      {
        "key": "B",
        "text": "The output is 10."
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 12 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 13 generates a compiler error."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an exception at runtime."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Starting with Java 16, inner classes can contain static variables, so the code compiles. \nRemember that private constructors can be used by any methods within the outer class. \nThe butter reference on line 8 refers to the inner class variable defined on line 6, with the \noutput being 10 at runtime, and making option B correct.\n"
  },
  {
    "id": "oca-154",
    "question": "Which of the following are true about encapsulation? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "It allows getters."
      },
      {
        "key": "B",
        "text": "It allows setters."
      },
      {
        "key": "C",
        "text": "It requires specific naming conventions."
      },
      {
        "key": "D",
        "text": "It requires public instance variables."
      },
      {
        "key": "E",
        "text": "It requires private instance variables."
      }
    ],
    "answer": [
      "A",
      "B",
      "E"
    ],
    "explanation": "Encapsulation allows using methods to get and set instance variables so other classes \nare not directly using them, making options A and B correct. Instance variables must be \nprivate for this to work, making option E correct and option D incorrect. While there are \ncommon naming conventions, they are not required, making option C incorrect.\n"
  },
  {
    "id": "oca-155",
    "question": "What is the result of the following program?\npublic class Weather {\n   enum Seasons {\n      WINTER, SPRING, SUMMER, FALL\n   }\n\n   public static void main(String[] args) {\n      Seasons v = null;\n      switch (v) {\n         case Seasons.SPRING - > System.out.print(\"s\");\n         case Seasons.WINTER - > System.out.print(\"w\");\n         case Seasons.SUMMER - > System.out.print(\"m\");\n         default - > System.out.println(\"missing data\"); }\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "s"
      },
      {
        "key": "B",
        "text": "w"
      },
      {
        "key": "C",
        "text": "m"
      },
      {
        "key": "D",
        "text": "missing data"
      },
      {
        "key": "E",
        "text": "Exactly one line of code does not compile."
      },
      {
        "key": "F",
        "text": "More than one line of code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but produces an exception at runtime."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "When using an enum in a switch expression, the case statement must be made up of the \nenum values only. If the enum name is used in the case statement value, then the code does \nnot compile. In this question, SPRING is acceptable, but Seasons.SPRING is not. \nFor this reason, the three case statements do not compile, making option F the correct \nanswer. If these three lines were corrected, then the code would compile and produce a \nNullPointerException at runtime.\n"
  },
  {
    "id": "oca-156",
    "question": "Which statements about sealed classes are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A sealed interface restricts which subinterfaces may extend it."
      },
      {
        "key": "B",
        "text": "A sealed class cannot be indirectly extended by a class that is not listed in its permits \nclause."
      },
      {
        "key": "C",
        "text": "A sealed class can be extended by an abstract class."
      },
      {
        "key": "D",
        "text": "A sealed class can be extended by a subclass that uses the non-sealed modifier."
      },
      {
        "key": "E",
        "text": "A sealed interface restricts which subclasses may implement it."
      },
      {
        "key": "F",
        "text": "A sealed class cannot contain any nested subclasses."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C",
      "E"
    ],
    "explanation": "A sealed interface restricts which interfaces may extend it, or which classes may \nimplement it, making options A and E correct. Option B is incorrect. For example, a \nnon-sealed subclass allows classes not listed in the permits clause to indirectly extend \nthe sealed class. Option C is correct. While a sealed class is commonly extended by a sub\u0002class marked final, it can also be extended by a sealed or non-sealed subclass marked \nabstract. Option D is incorrect, as the modifier is non-sealed, not nonsealed. Finally, \noption F is incorrect, as sealed classes can contain nested subclasses.\n"
  },
  {
    "id": "oca-157",
    "question": "Which lines, when entered independently into the blank, allow the code to print  \nNot scared at runtime? (Choose all that apply.)\npublic class Ghost {\n   public static void boo() {\n      System.out.println(\"Not scared\");\n   }\n   protected final class Spirit {\n      public void boo() {\n         System.out.println(\"Booo!!!\");\n      }\n   }\n   public static void main(String... haunt) {\n      var g = new Ghost().new Spirit() {};\n      ;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "g.boo()"
      },
      {
        "key": "B",
        "text": "g.super.boo()"
      },
      {
        "key": "C",
        "text": "new Ghost().boo()"
      },
      {
        "key": "D",
        "text": "g.Ghost.boo()"
      },
      {
        "key": "E",
        "text": "new Spirit().boo()"
      },
      {
        "key": "F",
        "text": "Ghost.boo()"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "Trick question—the code does not compile! For this reason, option G is correct. The \nSpirit class is marked final, so it cannot be extended. The main() method uses an \nanonymous class that inherits from Spirit, which is not allowed. If Spirit were not \nmarked final, then options C and F would be correct. Option A would print Booo!!!, \nwhile options B, D, and E would not compile for various reasons.\n"
  },
  {
    "id": "oca-158",
    "question": "The following code appears in a file named Ostrich.java. What is the result of compiling \nthe source file?\n1: public class Ostrich {\n2:    private int count;\n3:    static class OstrichWrangler {\n4:       public int stampede() {\n5:          return count;\n6:       } } }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles successfully, and one bytecode file is generated: Ostrich.class."
      },
      {
        "key": "B",
        "text": "The code compiles successfully, and two bytecode files are generated: Ostrich.class \nand OstrichWrangler.class."
      },
      {
        "key": "C",
        "text": "The code compiles successfully, and two bytecode files are generated: Ostrich.class \nand Ostrich$OstrichWrangler.class."
      },
      {
        "key": "D",
        "text": "A compiler error occurs on line 3."
      },
      {
        "key": "E",
        "text": "A compiler error occurs on line 5."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The OstrichWrangler class is a static nested class; therefore, it cannot access the \ninstance member count. For this reason, line 5 does not compile, and option E is correct.\n"
  },
  {
    "id": "oca-159",
    "question": "Which lines of the following interface declarations do not compile? (Choose all that apply.)\n1: public interface Omnivore {\n2:    int amount = 10;\n3:    static boolean gather = true;\n4:    static void eatGrass() {}\n5:    int findMore() { return 2; }\n6:    default float rest() { return 2; }\n7:    protected int chew() { return 13; }\n8:    private static void eatLeaves() {}\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "All of the lines compile without issue."
      },
      {
        "key": "B",
        "text": "Line 2"
      },
      {
        "key": "C",
        "text": "Line 3"
      },
      {
        "key": "D",
        "text": "Line 4"
      },
      {
        "key": "E",
        "text": "Line 5"
      },
      {
        "key": "F",
        "text": "Line 6"
      },
      {
        "key": "G",
        "text": "Line 7"
      },
      {
        "key": "H",
        "text": "Line 8"
      }
    ],
    "answer": [
      "E",
      "G"
    ],
    "explanation": "Lines 2 and 3 compile with interface variables implicitly public, static, and \nfinal. Line 4 also compiles, as static methods are implicitly public. Line 5 does not \ncompile, making option E correct. Non-static interface methods with a body must be \nexplicitly marked private or default. Line 6 compiles, with the public modifier being \nadded by the compiler. Line 7 does not compile, as interfaces do not have protected mem\u0002bers, making option G correct. Finally, line 8 compiles without issue.\n"
  },
  {
    "id": "oca-160",
    "question": "What is printed by the following program?\npublic class Deer {\n   enum Food {APPLES, BERRIES, GRASS}\n   protected class Diet {\n      private Food getFavorite() {\n         return Food.BERRIES;\n      }\n  }\n   public static void main(String[] seasons) {\n      System.out.print(switch(new Diet().getFavorite()) {\n         case APPLES - > \"a\";\n         case BERRIES - > \"b\";\n         default - > \"c\";\n      });\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "a"
      },
      {
        "key": "B",
        "text": "b"
      },
      {
        "key": "C",
        "text": "c"
      },
      {
        "key": "D",
        "text": "The code declaration of the Diet class does not compile."
      },
      {
        "key": "E",
        "text": "The main() method does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but produces an exception at runtime."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Diet is an inner class, which requires an instance of Deer to instantiate. Since the \nmain() method is static, there is no such instance. Therefore, the main() method does \nnot compile, and option E is correct. If a reference to Deer were used, such as calling \nnew Deer().new Diet(), then the code would compile and print b at runtime.\n"
  },
  {
    "id": "oca-161",
    "question": "Which of the following are printed by the Bear program? (Choose all that apply.)\npublic class Bear {\n   enum FOOD {\n      BERRIES, INSECTS {\n         public boolean isHealthy() { return true; }},\n      FISH, ROOTS, COOKIES, HONEY;\n      public abstract boolean isHealthy();\n   }\n   public static void main(String[] args) {\n      System.out.print(FOOD.INSECTS);\n      System.out.print(FOOD.INSECTS.ordinal());\n      System.out.print(FOOD.INSECTS.isHealthy());\n      System.out.print(FOOD.COOKIES.isHealthy());\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "insects"
      },
      {
        "key": "B",
        "text": "INSECTS"
      },
      {
        "key": "C",
        "text": "0"
      },
      {
        "key": "D",
        "text": "1"
      },
      {
        "key": "E",
        "text": "false"
      },
      {
        "key": "F",
        "text": "true"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The isHealthy() method is marked abstract in the enum; therefore, it must be \nimplemented in each enum value declaration. Since only INSECTS implements it, the code \ndoes not compile, making option G correct.\n"
  },
  {
    "id": "oca-162",
    "question": "Which statements about polymorphism and method inheritance are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Given an arbitrary instance of a class, it cannot be determined until runtime which over -\nridden method will be executed in a parent class."
      },
      {
        "key": "B",
        "text": "It cannot be determined until runtime which hidden method will be executed in a parent \nclass."
      },
      {
        "key": "C",
        "text": "Marking a method static prevents it from being overridden or hidden."
      },
      {
        "key": "D",
        "text": "Marking a method final prevents it from being overridden or hidden."
      },
      {
        "key": "E",
        "text": "The reference type of the variable determines which overridden method will be called at \nruntime."
      },
      {
        "key": "F",
        "text": "The reference type of the variable determines which hidden method will be called at run-\ntime."
      }
    ],
    "answer": [
      "A",
      "D",
      "F"
    ],
    "explanation": "Polymorphism is the property of an object to take on many forms. Part of polymor\u0002phism is that methods are replaced through overriding wherever they are called, regardless of \nwhether they’re in a parent or child class. For this reason, option A is correct, and option E \nis incorrect. With hidden static methods, Java relies on the location and reference type to \ndetermine which method is called, making option B incorrect and option F correct. Finally, \nmaking a method final, not static, prevents it from being overridden, making option D \ncorrect and option C incorrect.\n"
  },
  {
    "id": "oca-163",
    "question": "Given the following record declaration, which lines of code can fill in the blank and allow \nthe code to compile? (Choose all that apply.)\npublic record RabbitFood(int size, String brand, LocalDate expires) {\n   public static int MAX_STORAGE = 100;\n   public RabbitFood() {\n      ;\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "size = MAX_STORAGE"
      },
      {
        "key": "B",
        "text": "this.size = 10"
      },
      {
        "key": "C",
        "text": "if(expires.isAfter(LocalDate.now())) throw new  \nRuntimeException()"
      },
      {
        "key": "D",
        "text": "if(brand==null) super.brand = \"Unknown\""
      },
      {
        "key": "E",
        "text": "throw new RuntimeException()"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The record defines an overloaded constructor using parentheses, not a \ncompact one. For this reason, the first line must be a call to another constructor, such as \nthis(500, \"Acme\", LocalDate.now()). For this reason, the code does not compile \nand option F is correct. If the parentheses were removed from the constructor to declare a \ncompact constructor, then options A, C, and E would be correct.\n"
  },
  {
    "id": "oca-164",
    "question": "Which of the following can be inserted in the rest() method? (Choose all that apply.)\npublic class Lion {\n   class Cub {}\n   static class Den {}\n   static void rest() {\n       ;\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "Cub a = Lion.new Cub()"
      },
      {
        "key": "B",
        "text": "Lion.Cub b = new Lion().Cub()"
      },
      {
        "key": "C",
        "text": "Lion.Cub c = new Lion().new Cub()"
      },
      {
        "key": "D",
        "text": "var d = new Den()"
      },
      {
        "key": "E",
        "text": "var e = Lion.new Cub()"
      },
      {
        "key": "F",
        "text": "Lion.Den f = Lion.new Den()"
      },
      {
        "key": "G",
        "text": "Lion.Den g = new Lion.Den()"
      },
      {
        "key": "H",
        "text": "var h = new Cub()"
      }
    ],
    "answer": [
      "C",
      "D",
      "G"
    ],
    "explanation": "Option C correctly creates an instance of an inner class Cub using an instance of \nthe outer class Lion. Options A, B, E, and H use incorrect syntax for creating an instance of \nthe Cub class. Options D and G correctly create an instance of the static nested Den class, \nwhich does not require an instance of Lion, while option F uses invalid syntax.\n"
  },
  {
    "id": "oca-165",
    "question": "Given the following program, what can be inserted into the blank line that would allow it to \nprint Swim! at runtime?\ninterface Swim {\n   default void perform() { System.out.print(\"Swim!\"); }\n}\ninterface Dance {\n   default void perform() { System.out.print(\"Dance!\"); }\n}\npublic class Penguin implements Swim, Dance {\n   public void perform() { System.out.print(\"Smile!\"); }\n   private void doShow() {\n     ;\n   }\n   public static void main(String[] eggs) {\n      new Penguin().doShow();\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "super.perform()"
      },
      {
        "key": "B",
        "text": "Swim.perform()"
      },
      {
        "key": "C",
        "text": "super.Swim.perform()"
      },
      {
        "key": "D",
        "text": "Swim.super.perform()"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is inserted into the blank."
      },
      {
        "key": "F",
        "text": "The code compiles, but due to polymorphism, it is not possible to produce the requested \noutput without creating a new object."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "First, if a class or interface inherits two interfaces containing default methods with the \nsame signature, it must override the method with its own implementation. The Penguin\nclass does this correctly, so option E is incorrect. The way to access an inherited default\nmethod is by using the syntax Swim.super.perform(), making option D correct. We \nagree that the syntax is bizarre, but you need to learn it. Options A, B, and C are incorrect \nand result in compiler errors.\n"
  },
  {
    "id": "oca-166",
    "question": "Which lines of the following interface do not compile? (Choose all that apply.)\n1: public interface BigCat {\n2:    abstract String getName();\n3:    static int hunt() { getName(); return 5; }\n4:    default void climb() { rest(); }\n5:    private void roar() { getName();  climb(); hunt(); }\n6:    private static boolean sneak() { roar(); return true; }\n7:    private int rest() { return 2; };\n8: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 2"
      },
      {
        "key": "B",
        "text": "Line 3"
      },
      {
        "key": "C",
        "text": "Line 4"
      },
      {
        "key": "D",
        "text": "Line 5"
      },
      {
        "key": "E",
        "text": "Line 6"
      },
      {
        "key": "F",
        "text": "Line 7"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Line 3 does not compile because the static method hunt() cannot access an \nabstract instance method getName(), making option B correct. Line 6 does not com\u0002pile because the private static method sneak() cannot access the private instance \nmethod roar(), making option E correct. The rest of the lines compile without issue.\n"
  },
  {
    "id": "oca-167",
    "question": "What does the following program print?\n1:  public class Zebra {\n2:     private int x = 24;\n3:     public int hunt() {\n4:        String message = \"x is \";\n5:        abstract class Stripes {\n6:           private int x = 0;\n7:           public void print() {\n8:              System.out.print(message + Zebra.this.x);\n9:           }\n10:       }\n11:       var s = new Stripes() {};\n12:       s.print();\n13:       return x;\n14:    }\n15:    public static void main(String[] args) {\n16:       new Zebra().hunt();\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "x is 0"
      },
      {
        "key": "B",
        "text": "x is 24"
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 8 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 11 generates a compiler error."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Zebra.this.x is the correct way to refer to x in the Zebra class. Line 5 defines an \nabstract local class within a method, while line 11 defines a concrete anonymous class that \nextends the Stripes class. The code compiles without issue and prints x is 24 at runtime, \nmaking option B the correct answer.\n"
  },
  {
    "id": "oca-168",
    "question": "Which statements about the following enum are true? (Choose all that apply.)\n1:  public enum Animals {\n2:     MAMMAL(true), INVERTEBRATE(Boolean.FALSE), BIRD(false),\n3:     REPTILE(false), AMPHIBIAN(false), FISH(false) {\n4:        public int swim() { return 4; }\n5:     }\n6:     final boolean hasHair;\n7:     public Animals(boolean hasHair) {\n8:        this.hasHair = hasHair;\n9:     }\n10:    public boolean hasHair() { return hasHair; }\n11:    public int swim() { return 0; }\n12: }",
    "choices": [
      {
        "key": "A",
        "text": "Compiler error on line 2"
      },
      {
        "key": "B",
        "text": "Compiler error on line 3"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 8"
      },
      {
        "key": "E",
        "text": "Compiler error on line 10"
      },
      {
        "key": "F",
        "text": "Compiler error on another line"
      },
      {
        "key": "G",
        "text": "The code compiles successfully."
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "Enums are required to have a semicolon (;) after the list of values if there is anything \nelse in the enum. Don’t worry; you won’t be expected to track down missing semicolons on \nthe whole exam—only on enum questions. For this reason, line 5 should have a semicolon \nafter it since it is the end of the list of enums, making option F correct. Enum constructors \nare implicitly private, making option C correct as well. The rest of the enum compiles \nwithout issue.\n"
  },
  {
    "id": "oca-169",
    "question": "Assuming a record is defined with at least one field, which components does the compiler \nalways insert, each of which may be overridden or redeclared? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A no- argument constructor"
      },
      {
        "key": "B",
        "text": "An accessor method for each field"
      },
      {
        "key": "C",
        "text": "The toString() method"
      },
      {
        "key": "D",
        "text": "The equals() method"
      },
      {
        "key": "E",
        "text": "A mutator method for each field"
      },
      {
        "key": "F",
        "text": "A sort method for each field"
      },
      {
        "key": "G",
        "text": "The hashCode() method"
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "G"
    ],
    "explanation": "The compiler inserts an accessor for each field, a constructor containing all \nof the fields in the order they are declared, and useful implementations of equals(), \nhashCode(), and toString(), making options B, C, D, and G correct. Option A is incor\u0002rect, as the compiler would only insert a no-argument constructor if the record had no fields. \nOption E is incorrect, as records are immutable. Option F is also incorrect and not a property \nof records.\n"
  },
  {
    "id": "oca-170",
    "question": "Which of the following classes and interfaces do not compile? (Choose all that apply.)\npublic abstract class Camel { void travel(); }\n \npublic interface EatsGrass { private abstract int chew(); }\n \npublic abstract class Elephant {\n   abstract private class SleepsAlot {\n      abstract int sleep();\n   } }\n \npublic class Eagle { abstract soar(); }\n \npublic interface Spider { default void crawl() {} }",
    "choices": [
      {
        "key": "A",
        "text": "Camel"
      },
      {
        "key": "B",
        "text": "EatsGrass"
      },
      {
        "key": "C",
        "text": "Elephant"
      },
      {
        "key": "D",
        "text": "Eagle"
      },
      {
        "key": "E",
        "text": "Spider"
      },
      {
        "key": "F",
        "text": "None of the classes or interfaces compile."
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Camel does not compile because the travel() method does not declare a \nbody, nor is it marked abstract, making option A correct. EatsGrass also does not \ncompile because an interface method cannot be marked both private and abstract, \nmaking option B correct. Finally, Eagle does not compile because it declares an abstract \nmethod soar() in a concrete class, making option D correct. The other classes compile \nwithout issue.\n"
  },
  {
    "id": "oca-171",
    "question": "How many lines of the following program contain a compilation error?\n1:  class Primate {\n2:     protected int age = 2;\n3:     { age = 1; }\n4:     public Primate() {\n5:        this().age = 3;\n6:     }\n7:  }\n8:  public class Orangutan {\n9:     protected int age = 4;\n10:    { age = 5; }\n11:    public Orangutan() {\n12:       this().age = 6;\n13:    }\n14:    public static void main(String[] bananas) {\n15:       final Primate x = (Primate)new Orangutan();\n16:       System.out.println(x.age);\n17:    }\n18: }",
    "choices": [
      {
        "key": "A",
        "text": "None, and the program prints 1 at runtime."
      },
      {
        "key": "B",
        "text": "None, and the program prints 3 at runtime."
      },
      {
        "key": "C",
        "text": "None, but it causes a ClassCastException at runtime."
      },
      {
        "key": "D",
        "text": "1"
      },
      {
        "key": "E",
        "text": "2"
      },
      {
        "key": "F",
        "text": "3"
      },
      {
        "key": "G",
        "text": "4"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile, so options A through C are incorrect. Both lines 5 and 12 do \nnot compile, as this() is used instead of this. Remember, this() refers to calling a con\u0002structor, whereas this is a reference to the current instance. Next, the compiler does not \nallow casting to an unrelated class type. Since Orangutan is not a subclass of Primate, the \ncast on line 15 is invalid, and the code does not compile. Due to these three lines containing \ncompilation errors, option F is the correct answer.\n"
  },
  {
    "id": "oca-172",
    "question": "Assuming the following classes are declared as top- level types in the same file, which classes \ncontain compiler errors? (Choose all that apply.)\nsealed class Bird {\n   public final class Flamingo extends Bird {}   \n}\n \nsealed class Monkey {}\n \nclass EmperorTamarin extends Monkey {}\n \nnon- sealed class Mandrill extends Monkey {}\n \nsealed class Friendly extends Mandrill permits Silly {}\n \nfinal class Silly {}",
    "choices": [
      {
        "key": "A",
        "text": "Bird"
      },
      {
        "key": "B",
        "text": "Monkey"
      },
      {
        "key": "C",
        "text": "EmperorTamarin"
      },
      {
        "key": "D",
        "text": "Mandrill"
      },
      {
        "key": "E",
        "text": "Friendly"
      },
      {
        "key": "F",
        "text": "Silly"
      },
      {
        "key": "G",
        "text": "All of the classes compile without issue.\nLambdas and"
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Bird and its nested Flamingo subclass compile without issue. The permits clause is \noptional if the subclass is nested or declared in the same file. For this reason, Monkey and its \nsubclass Mandrill also compile without issue. EmperorTamarin does not compile, as it is \nmissing a non-sealed, sealed, or final modifier, making option C correct. Friendly\nalso does not compile, since it lists a subclass Silly that does not extend it, making option \nE correct. While the permits clause is optional, the extends clause is not. Silly compiles \njust fine. Even though it does not extend Friendly, the compiler error is in the sealed class.\n"
  },
  {
    "id": "oca-173",
    "question": "What is the result of the following class?\n1:  import java.util.function.*;\n2:\n3:  public class Panda {\n4:     int age;\n5:     public static void main(String[] args) {\n6:        Panda p1 = new Panda();\n7:        p1.age = 1;\n8:        check(p1, p - > p.age < 5);\n9:     }\n10:    private static void check(Panda panda,\n11:       Predicate<Panda> pred) {\n12:       String result =\n13:          pred.test(panda) ? \"match\" : \"not match\";\n14:       System.out.print(result);\n15: } }",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8"
      },
      {
        "key": "D",
        "text": "Compiler error on lines 10 and 11"
      },
      {
        "key": "E",
        "text": "Compiler error on lines 12 and 13"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "This code is correct. Line 8 creates a lambda expression that checks whether the age \nis less than 5, making option A correct. Since there is only one parameter and it does not \nspecify a type, the parentheses around the parameter are optional. Lines 11 and 13 use the \nPredicate interface, which declares a test() method.\n"
  },
  {
    "id": "oca-174",
    "question": "What is the result of the following code?\n1:  interface Climb {\n2:     boolean isTooHigh(int height, int limit);\n3:  }\n4:\n5:  public class Climber {\n6:     public static void main(String[] args) {\n7:        check((h, m) - > h.append(m).isEmpty(), 5);\n8:     }\n9:     private static void check(Climb climb, int height) {\n10:       if (climb.isTooHigh(height, 10))\n11:          System.out.println(\"too high\");\n12:       else\n13:          System.out.println(\"ok\");\n14:    }\n15: }",
    "choices": [
      {
        "key": "A",
        "text": "ok"
      },
      {
        "key": "B",
        "text": "too high"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on a different line"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The interface takes two int parameters. The code on line 7 attempts to use them as if \nh is a String making option C correct. It is tricky to use types in a lambda when they are \nimplicitly specified. Remember to check the interface for the real type.\n"
  },
  {
    "id": "oca-175",
    "question": "Which statements about functional interfaces are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A functional interface can contain default and private methods."
      },
      {
        "key": "B",
        "text": "A functional interface can be defined as a class or an interface."
      },
      {
        "key": "C",
        "text": "Abstract methods with signatures that are contained in public methods of \njava.lang.Object do not count toward the abstract method count for a functional \ninterface."
      },
      {
        "key": "D",
        "text": "A functional interface cannot contain static or private static methods."
      },
      {
        "key": "E",
        "text": "A functional interface must be marked with the @FunctionalInterface annotation."
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "A functional interface can contain any number of non-abstract methods, including \ndefault, private, static, and private static. For this reason, option A is correct, \nand option D is incorrect. Option B is incorrect, as classes are never considered functional \ninterfaces. A functional interface contains exactly one abstract method, although methods \nthat have matching signatures as public methods in java.lang.Object do not count \ntoward the single method test. For these reasons, option C is correct. Finally, option E is \nincorrect. While a functional interface can be marked with the @FunctionalInterface\nannotation, it is not required.\n"
  },
  {
    "id": "oca-176",
    "question": "Which lambda can replace the MySecret class to return the same value? (Choose all \nthat apply.)\ninterface Secret {\n   String magic(double d);\n}\n \nclass MySecret implements Secret {\n   public String magic(double d) {\n      return \"Poof\";\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "(e) - > \"Poof\""
      },
      {
        "key": "B",
        "text": "(e) - > {\"Poof\"}"
      },
      {
        "key": "C",
        "text": "(e) - > { String e = \"\"; \"Poof\" }"
      },
      {
        "key": "D",
        "text": "(e) - > { String e = \"\"; return \"Poof\"; }"
      },
      {
        "key": "E",
        "text": "(e) - > { String e = \"\"; return \"Poof\" }"
      },
      {
        "key": "F",
        "text": "(e) - > { String f = \"\"; return \"Poof\"; }"
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Option B is incorrect because it does not use the return keyword. Options C, D, and \nE are incorrect because the variable e is already in use from the lambda and cannot be rede\u0002fined. Additionally, option C is missing the return keyword, and option E is missing the \nsemicolon. Therefore, options A and F are correct.\n"
  },
  {
    "id": "oca-177",
    "question": "Which of the following functional interfaces contain an abstract method that returns a primi-\ntive value? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "BooleanSupplier"
      },
      {
        "key": "B",
        "text": "CharSupplier"
      },
      {
        "key": "C",
        "text": "DoubleSupplier"
      },
      {
        "key": "D",
        "text": "FloatSupplier"
      },
      {
        "key": "E",
        "text": "IntSupplier"
      },
      {
        "key": "F",
        "text": "StringSupplier"
      }
    ],
    "answer": [
      "A",
      "C",
      "E"
    ],
    "explanation": "Java includes support for three primitive streams, along with numerous functional \ninterfaces to go with them: int, double, and long. For this reason, options C and E are \ncorrect. Additionally, there is a BooleanSupplier functional interface, making option A \ncorrect. Java does not include primitive streams or related functional interfaces for other \nnumeric data types, making options B and D incorrect. Option F is incorrect because String\nis not a primitive but an object. Only primitives have custom suppliers.\n"
  },
  {
    "id": "oca-178",
    "question": "Which of the following lambda expressions can be passed to a function of Predicate<String>  \ntype? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "s - > s.isEmpty()"
      },
      {
        "key": "B",
        "text": "s - - > s.isEmpty()"
      },
      {
        "key": "C",
        "text": "(String s) - > s.isEmpty()"
      },
      {
        "key": "D",
        "text": "(String s) - - > s.isEmpty()"
      },
      {
        "key": "E",
        "text": "(StringBuilder s) - > s.isEmpty()"
      },
      {
        "key": "F",
        "text": "(StringBuilder s) - - > s.isEmpty()"
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "Predicate<String> takes a parameter list of one parameter using the specified \ntype. Options E and F are incorrect because they specify the wrong type. Options B and D \nare incorrect because they use the wrong syntax for the arrow operator. This leaves us with \noptions A and C as the answers.\n"
  },
  {
    "id": "oca-179",
    "question": "Which of these statements is true about the following code?\npublic void method() {\n   x((var x) - > {}, (var x, var y) - > false);\n}\npublic void x(Consumer<String> x, BinaryOperator<Boolean> y) {}",
    "choices": [
      {
        "key": "A",
        "text": "The code does not compile because of one of the variables named x."
      },
      {
        "key": "B",
        "text": "The code does not compile because of one of the variables named y."
      },
      {
        "key": "C",
        "text": "The code does not compile for another reason."
      },
      {
        "key": "D",
        "text": "The code compiles, and the x in each lambda refers to the same type."
      },
      {
        "key": "E",
        "text": "The code compiles, and the x in each lambda refers to a different type."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "While there appears to have been a variable name shortage when this code was written, \nit does compile. Lambda variables and method names are allowed to be the same. The x\nlambda parameter is scoped to within each lambda, so it is allowed to be reused. The type \nis inferred by the method it calls. The first lambda maps x to a String and the second to a \nBoolean. Therefore, option E is correct.\n"
  },
  {
    "id": "oca-180",
    "question": "Which of the following is equivalent to this code? (Choose all that apply.)\nUnaryOperator<Integer> u = x - > x * x;",
    "choices": [
      {
        "key": "A",
        "text": "BiFunction<Integer> f = x - > x*x;"
      },
      {
        "key": "B",
        "text": "BiFunction<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "C",
        "text": "BinaryOperator<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "D",
        "text": "Function<Integer> f = x - > x*x;"
      },
      {
        "key": "E",
        "text": "Function<Integer, Integer> f = x - > x*x;"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The question starts with a UnaryOperator<Integer>, which takes one parameter \nand returns a value of the same type. Therefore, option E is correct, as UnaryOperator\nextends Function. Notice that other options don’t even compile because they have the \nwrong number of generic types for the functional interface provided. You should know that \na BiFunction<T,U,R> takes three generic arguments, a BinaryOperator<T> takes one \ngeneric argument, and a Function<T,R> takes two generic arguments.\n"
  },
  {
    "id": "oca-181",
    "question": "Which statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The Consumer interface is good for printing out an existing value."
      },
      {
        "key": "B",
        "text": "The Supplier interface is good for printing out an existing value."
      },
      {
        "key": "C",
        "text": "The IntegerSupplier interface returns an int."
      },
      {
        "key": "D",
        "text": "The Predicate interface returns an int."
      },
      {
        "key": "E",
        "text": "The Function interface has a method named test()."
      },
      {
        "key": "F",
        "text": "The Predicate interface has a method named test()."
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Option A is correct and option B is incorrect because a Supplier returns a value \nwhile a Consumer takes one and acts on it. Option C is tricky. IntSupplier does return \nan int. However, the option asks about IntegerSupplier, which doesn’t exist. Option \nD is incorrect because a Predicate returns a boolean. It does have a method named \ntest(), making option F correct. Finally, option E is incorrect because Function has an \napply() method.\n"
  },
  {
    "id": "oca-182",
    "question": "Which of the following can be inserted without causing a compilation error? (Choose all \nthat apply.)\npublic void remove(List<Character> chars) {\n   char end = 'z';\n   Predicate<Character> predicate = c - > {\n      char start = 'a'; return start <= c && c <= end; };\n \n   // INSERT LINE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "char start = 'a';"
      },
      {
        "key": "B",
        "text": "char c = 'x';"
      },
      {
        "key": "C",
        "text": "chars = null;"
      },
      {
        "key": "D",
        "text": "end = '1';"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Since the scope of start and c is within the lambda, the variables can be declared \nor updated after it without issue, making options A, B, and C correct. Option D is incorrect \nbecause setting end prevents it from being effectively final.\n"
  },
  {
    "id": "oca-183",
    "question": "How many times is true printed out by this code?\nimport java.util.function.Predicate;\npublic class Fantasy {\n   public static void scary(String animal) {\n      var dino = s - > \"dino\".equals(animal);\n      var dragon = s - > \"dragon\".equals(animal);\n      var combined = dino.or(dragon);\n      System.out.println(combined.test(animal));\n   }\n   public static void main(String[] args) {\n      scary(\"dino\");\n      scary(\"dragon\");\n      scary(\"unicorn\");\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "One"
      },
      {
        "key": "B",
        "text": "Two"
      },
      {
        "key": "C",
        "text": "Three"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code does not compile because the lambdas are assigned to var. The compiler does \nnot have enough information to determine they are of type Predicate<String>. There\u0002fore, option D is correct.\n"
  },
  {
    "id": "oca-184",
    "question": "What does the following code output?\nFunction<Integer, Integer> s = a - > a + 4;\nFunction<Integer, Integer> t = a - > a * 3;\nFunction<Integer, Integer> c = s.compose(t);\nSystem.out.print(c.apply(1));",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "15"
      },
      {
        "key": "C",
        "text": "The code does not compile because of the data types in the lambda expressions."
      },
      {
        "key": "D",
        "text": "The code does not compile because of the compose() call."
      },
      {
        "key": "E",
        "text": "The code does not compile for another reason."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The a.compose(b) method calls the Function parameter b before the reference \nFunction variable a. In this case, that means that we multiply by 3 before adding 4. This \ngives a result of 7, making option A correct.\n"
  },
  {
    "id": "oca-185",
    "question": "Which is true of the following code?\nint length = 3;\n \nfor (int i = 0; i<3; i++) {\n   if (i%2 == 0) {\n      Supplier<Integer> supplier = () - > length; // A\n      System.out.println(supplier.get());        // B\n   } else {\n      int j = i;\n      Supplier<Integer> supplier = () - > j;      // C\n      System.out.println(supplier.get());        // D\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The first compiler error is on line A."
      },
      {
        "key": "B",
        "text": "The first compiler error is on line B."
      },
      {
        "key": "C",
        "text": "The first compiler error is on line C."
      },
      {
        "key": "D",
        "text": "The first compiler error is on line D."
      },
      {
        "key": "E",
        "text": "The code compiles successfully."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Lambdas are only allowed to reference final or effectively final variables. You can tell \nthe variable j is effectively final because adding a final keyword before it wouldn’t intro\u0002duce a compiler error. Each time the else statement is executed, the variable is redeclared \nand goes out of scope. Therefore, it is not reassigned. Similarly, length is effectively final. \nThere are no compiler errors, and option E is correct.\n"
  },
  {
    "id": "oca-186",
    "question": "Which of the following are valid lambda expressions? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "(Wolf w, var c) - > 39"
      },
      {
        "key": "B",
        "text": "(final Camel c) - > {}"
      },
      {
        "key": "C",
        "text": "(a,b,c) - > {int b = 3; return 2;}"
      },
      {
        "key": "D",
        "text": "(x,y) - > new RuntimeException()"
      },
      {
        "key": "E",
        "text": "(var y) - > return 0;"
      },
      {
        "key": "F",
        "text": "() - > {float r}"
      },
      {
        "key": "G",
        "text": "(Cat a, b) - > {}"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Option B is a valid functional interface, one that could be assigned to a \nConsumer<Camel> reference. Notice that the final modifier is permitted on variables in \nthe parameter list. Option D is correct, as the exception is being returned as an object and \nnot thrown. This would be compatible with a BiFunction that included \nRuntimeException as its return type.\n\nOptions A and G are incorrect because they mix format types for the parameters. Option C \nis invalid because the variable b is used twice. Option E is incorrect, as a return statement \nis permitted only inside braces ({}). Option F is incorrect because the variable declaration \nrequires a semicolon (;) after it.\n"
  },
  {
    "id": "oca-187",
    "question": "Which lambda expression, when entered into the blank line in the following code, causes the \nprogram to print hahaha? (Choose all that apply.)\nimport java.util.function.Predicate;\npublic class Hyena {\n   private int age = 1;\n   public static void main(String[] args) {\n      var p = new Hyena();\n      double height = 10;\n      int age = 1;\n      testLaugh(p,  );\n      age = 2;\n   }\n   static void testLaugh(Hyena panda, Predicate<Hyena> joke) {\n      var r = joke.test(panda) ? \"hahaha\" : \"silence\";\n      System.out.print(r);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "var - > p.age <= 10"
      },
      {
        "key": "B",
        "text": "shenzi - > age==1"
      },
      {
        "key": "C",
        "text": "p - > true"
      },
      {
        "key": "D",
        "text": "age==1"
      },
      {
        "key": "E",
        "text": "shenzi - > age==2"
      },
      {
        "key": "F",
        "text": "h - > h.age < 5"
      },
      {
        "key": "G",
        "text": "None of the above, as the code does not compile"
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Option A is a valid lambda expression. While main() is a static method, it can \naccess age since it is using a reference to an instance of Hyena, which is effectively final in \nthis method. Since var is not a reserved word, it may be used for variable names. Option F \nis also correct, with the lambda variable being a reference to a Hyena object. The variable is \nprocessed using deferred execution in the testLaugh() method.\nOptions B and E are incorrect; since the local variable age is not effectively final, this would \nlead to a compilation error. Option C would also cause a compilation error, since the expres\u0002sion uses the variable name p, which is already declared within the method. Finally, option D \nis incorrect, as this is not even a lambda expression.\n"
  },
  {
    "id": "oca-188",
    "question": "Which of the following can be inserted without causing a compilation error? (Choose all \nthat apply.)\npublic void remove(List<Character> chars) {\n   char end = 'z';\n\n   // INSERT LINE HERE\n \n   Predicate<Character> predicate =  c - > {\n      char start = 'a'; return start <= c && c <= end; };\n}",
    "choices": [
      {
        "key": "A",
        "text": "char start = 'a';"
      },
      {
        "key": "B",
        "text": "char c = 'x';"
      },
      {
        "key": "C",
        "text": "chars = null;"
      },
      {
        "key": "D",
        "text": "end = '1';"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Lambdas are not allowed to redeclare local variables, making options A and B incorrect. \nOption D is incorrect because setting end prevents it from being effectively final. Lambdas \nare only allowed to reference final or effectively final variables. Option C compiles since \nchars is not used. \n"
  },
  {
    "id": "oca-189",
    "question": "What is the result of running the following class?\n1:  import java.util.function.*;\n2:\n3:  public class Panda {\n4:     int age;\n5:     public static void main(String[] args) {\n6:        Panda p1 = new Panda();\n7:        p1.age = 1;\n8:        check(p1, p - > {p.age < 5});\n9:     }\n10:    private static void check(Panda panda,\n11:       Predicate<Panda> pred) {\n12:       String result = pred.test(panda)\n13:          ? \"match\" : \"not match\";\n14:       System.out.print(result);\n15: } }",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on line 12"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Line 8 uses braces around the body. This means the return keyword and semicolon are \nrequired. Since the code doesn’t compile, option C is the answer.\n"
  },
  {
    "id": "oca-190",
    "question": "Which functional interfaces complete the following code? For line 7, assume m and n are \ninstances of functional interfaces that exist and have the same type as y. (Choose all that apply.)\n6:  x = String::new;\n7:  y = m.andThen(n);\n8:  z = a - > a + a;",
    "choices": [
      {
        "key": "A",
        "text": "BinaryConsumer<String, String>"
      },
      {
        "key": "B",
        "text": "BiConsumer<String, String>"
      },
      {
        "key": "C",
        "text": "BinaryFunction<String, String>"
      },
      {
        "key": "D",
        "text": "BiFunction<String, String>"
      },
      {
        "key": "E",
        "text": "Predicate<String>"
      },
      {
        "key": "F",
        "text": "Supplier<String>"
      },
      {
        "key": "G",
        "text": "UnaryOperator<String>"
      },
      {
        "key": "H",
        "text": "UnaryOperator<String, String>"
      }
    ],
    "answer": [
      "B",
      "F",
      "G"
    ],
    "explanation": "We can eliminate four choices right away. Options A and C are there to mislead you; \nthese interfaces don’t exist. Option D is incorrect because a BiFunction<T,U,R> takes \nthree generic arguments, not two. Option E is incorrect because none of the examples returns \na boolean.\nThe declaration on line 6 doesn’t take any parameters, and it returns a String, so a \nSupplier<String> can fill in the blank, making option F correct. The declaration on line \n7 requires you to recognize that Consumer and Function, along with their binary equiva\u0002lents, have an andThen() method. This makes option B correct. Finally, line 8 takes a single \nparameter, and it returns the same type, which is a UnaryOperator. Since the types are the \nsame, only one generic parameter is needed, making option G correct.\n"
  },
  {
    "id": "oca-191",
    "question": "Which of the following compiles and prints out the entire set? (Choose all that apply.)\nSet<?> set = Set.of(\"lion\", \"tiger\", \"bear\");\nvar s = Set.copyOf(set);\nConsumer<Object> consumer =  ;\ns.forEach(consumer);",
    "choices": [
      {
        "key": "A",
        "text": "() - > System.out.println(s)"
      },
      {
        "key": "B",
        "text": "s - > System.out.println(s)"
      },
      {
        "key": "C",
        "text": "(s) - > System.out.println(s)"
      },
      {
        "key": "D",
        "text": "System.out.println(s)"
      },
      {
        "key": "E",
        "text": "System::out::println"
      },
      {
        "key": "F",
        "text": "System.out::println"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "While there is a lot in this question trying to confuse you, note that there are no options \nabout the code not compiling. This allows you to focus on the lambdas and method refer\u0002ences. Option A is incorrect because a Consumer requires one parameter. Options B and C \nare close. The syntax for a lambda is correct. However, s is already defined as a local vari\u0002able, and therefore the lambda can’t redefine it. Options D and E use incorrect syntax for a \nmethod reference. Option F is correct.\n"
  },
  {
    "id": "oca-192",
    "question": "Which lambdas can replace the new Sloth() call in the main() method and produce the \nsame output at runtime? (Choose all that apply.)\nimport java.util.List;\ninterface Yawn {\n   String yawn(double d, List<Integer> time);\n}\nclass Sloth implements Yawn {\n   public String yawn(double zzz, List<Integer> time) {\n      return \"Sleep: \" + zzz;\n   } }\npublic class Vet {\n   public static String takeNap(Yawn y) {\n      return y.yawn(10, null);\n   }\n   public static void main(String... unused) {\n      System.out.print(takeNap(new Sloth()));\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "(z,f) - > { String x = \"\"; return \"Sleep: \" + x }"
      },
      {
        "key": "B",
        "text": "(t,s) - > { String t = \"\"; return \"Sleep: \" + t; }"
      },
      {
        "key": "C",
        "text": "(w,q) - > {\"Sleep: \" + w}"
      },
      {
        "key": "D",
        "text": "(e,u) - > { String g = \"\"; \"Sleep: \" + e }"
      },
      {
        "key": "E",
        "text": "(a,b) - > \"Sleep: \" + (double)(b==null ? a : a)"
      },
      {
        "key": "F",
        "text": "(r,k) - > { String g = \"\"; return \"Sleep:\"; }"
      },
      {
        "key": "G",
        "text": "None of the above, as the program does not compile"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Option A does not compile because the second statement within the block is missing \na semicolon (;) at the end. Option B is an invalid lambda expression because t is defined \ntwice: in the parameter list and within the lambda expression. Options C and D are both \nmissing a return statement and semicolon. Options E and F are both valid lambda expres\u0002sions, although only option E matches the behavior of the Sloth class. In particular, option \nF only prints Sleep:, not Sleep: 10.0.\n"
  },
  {
    "id": "oca-193",
    "question": "Which of the following are valid functional interfaces? (Choose all that apply.)\npublic interface Transport {\n   public int go();\n   public boolean equals(Object o);\n}\n \npublic abstract class Car {\n   public abstract Object swim(double speed, int duration);\n}\n \npublic interface Locomotive extends Train {\n   public int getSpeed();\n}\n \npublic interface Train extends Transport {}\n \nabstract interface Spaceship extends Transport {\n   default int blastOff();\n}\n \npublic interface Boat {\n   int hashCode();\n   int hashCode(String input);\n}",
    "choices": [
      {
        "key": "A",
        "text": "Boat"
      },
      {
        "key": "B",
        "text": "Car"
      },
      {
        "key": "C",
        "text": "Locomotive"
      },
      {
        "key": "D",
        "text": "Spaceship"
      },
      {
        "key": "E",
        "text": "Transport"
      },
      {
        "key": "F",
        "text": "Train"
      },
      {
        "key": "G",
        "text": "None of these is a valid functional interface.\nCollections"
      }
    ],
    "answer": [
      "A",
      "E",
      "F"
    ],
    "explanation": "A valid functional interface is one that contains a single abstract method, \nexcluding any public methods that are already defined in the java.lang.Object class. \nTransport and Boat are valid functional interfaces, as they each contain a single abstract \nmethod: go() and hashCode(String), respectively. This gives us options A and E. Since \nthe other methods are part of Object, they do not count as abstract methods. Train is \nalso a functional interface since it extends Transport and does not define any additional \nabstract methods. This adds option F as the final correct answer.\nCar is not a functional interface because it is an abstract class. Locomotive is not a \nfunctional interface because it includes two abstract methods, one of which is inherited. \nFinally, Spaceship is not a valid interface, let alone a functional interface, because a \ndefault method must provide a body. A quick way to test whether an interface is a \nfunctional interface is to apply the @FunctionalInterface annotation and check if the \ncode still compiles.\n"
  },
  {
    "id": "oca-194",
    "question": "Suppose you need to display a collection of products for sale, which may contain duplicates. \nAdditionally, you have a collection of sales that you need to track, sorted by the natural order \nof the sale ID, and you need to retrieve the text of each. Which two of the following from the \njava.util package best suit your needs for this scenario? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "ArrayList"
      },
      {
        "key": "B",
        "text": "HashMap"
      },
      {
        "key": "C",
        "text": "HashSet"
      },
      {
        "key": "D",
        "text": "LinkedList"
      },
      {
        "key": "E",
        "text": "TreeMap"
      },
      {
        "key": "F",
        "text": "TreeSet"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "For the first scenario, the answer needs to implement List because the scenario allows \nduplicates, narrowing it down to options A and D. Option A is a better answer than option D \nbecause LinkedList is both a List and a Queue, and you just need a regular List.\nFor the second scenario, the answer needs to implement Map because you are dealing with \nkey/value pairs per the unique id field. This narrows it down to options B and E. Since the \nquestion talks about ordering, you need the TreeMap. Therefore, the answer is option E.\n"
  },
  {
    "id": "oca-195",
    "question": "Which of the following are true? (Choose all that apply.)\n12: List<?> q = List.of(\"mouse\", \"parrot\");\n13: var v = List.of(\"mouse\", \"parrot\");\n14:\n15: q.removeIf(String::isEmpty);\n16: q.removeIf(s - > s.length() == 4);\n17: v.removeIf(String::isEmpty);\n18: v.removeIf(s - > s.length() == 4);",
    "choices": [
      {
        "key": "A",
        "text": "This code compiles and runs without error."
      },
      {
        "key": "B",
        "text": "Exactly one of these lines contains a compiler error."
      },
      {
        "key": "C",
        "text": "Exactly two of these lines contain a compiler error."
      },
      {
        "key": "D",
        "text": "Exactly three of these lines contain a compiler error."
      },
      {
        "key": "E",
        "text": "Exactly four of these lines contain a compiler error."
      },
      {
        "key": "F",
        "text": "If any lines with compiler errors are removed, this code runs without throwing an \nexception."
      },
      {
        "key": "G",
        "text": "If any lines with compiler errors are removed, this code throws an exception."
      }
    ],
    "answer": [
      "C",
      "G"
    ],
    "explanation": "Line 12 creates a List<?>, which means it is treated as if all the elements are of type \nObject rather than String. Lines 15 and 16 do not compile since they call the String\nmethods isEmpty() and length(), which are not defined on Object. Line 13 creates \na List<String> because var uses the type that it deduces from the context. Lines 17 \nand 18 do compile. However, List.of() creates an immutable list, so both of those lines \nwould throw an UnsupportedOperationException if run. Therefore, options C and G \nare correct.\n"
  },
  {
    "id": "oca-196",
    "question": "What is the result of the following statements?\n3:  var greetings = new ArrayDeque<String>();\n4:  greetings.offerLast(\"hello\");\n5:  greetings.offerLast(\"hi\");\n6:  greetings.offerFirst(\"ola\");\n7:  greetings.pop();\n8:  greetings.peek();\n9:  while (greetings.peek() != null)\n10:    System.out.print(greetings.pop());",
    "choices": [
      {
        "key": "A",
        "text": "hello"
      },
      {
        "key": "B",
        "text": "hellohi"
      },
      {
        "key": "C",
        "text": "hellohiola"
      },
      {
        "key": "D",
        "text": "hiola"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This is a double-ended queue. On lines 4 and 5, we add to the back, giving us \n[hello, hi]. On line 6, we add to the front and have [ola, hello, hi]. On line 7, \nwe remove the first element, which is \"ola\". On line 8, we look at the new first element \n(\"hello\") but don’t remove it. On lines 9 and 10, we remove each element in turn until no \nelements are left, printing hello and hi together which makes option B the answer.\n"
  },
  {
    "id": "oca-197",
    "question": "Which of these statements compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "HashSet<Number> hs = new HashSet<Integer>();"
      },
      {
        "key": "B",
        "text": "HashSet<? super ClassCastException> set = new \nHashSet<Exception>();"
      },
      {
        "key": "C",
        "text": "List<> list = new ArrayList<String>();"
      },
      {
        "key": "D",
        "text": "List<Object> values = new HashSet<Object>();"
      },
      {
        "key": "E",
        "text": "List<Object> objects = new ArrayList<? extends Object>();"
      },
      {
        "key": "F",
        "text": "Map<String, ? extends Number> hm = new HashMap<String, \nInteger>();"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "Option A does not compile because the generic types are not compatible. We could say \nHashSet<? extends Number> hs2 = new HashSet<Integer>();. Option B uses \na lower bound, so it allows superclass generic types. Option C does not compile because the \ndiamond operator is allowed only on the right side. Option D does not compile because a \nSet is not a List. Option E does not compile because upper bounds are not allowed when \ninstantiating the type. Finally, option F does compile because the upper bound is on the \ncorrect side of the =.\n"
  },
  {
    "id": "oca-198",
    "question": "What is the result of the following code?\n1: public record Hello<T>(T t) {\n2:    public Hello(T t) { this.t = t; }\n3:    private <T> void println(T message) {\n4:       System.out.print(t + \"- \" + message);\n5:    }\n6:    public static void main(String[] args) {\n7:       new Hello<String>(\"hi\").println(1);\n8:       new Hello(\"hola\").println(true);\n9:    } }",
    "choices": [
      {
        "key": "A",
        "text": "hi followed by a runtime exception"
      },
      {
        "key": "B",
        "text": "hi- 1hola- true"
      },
      {
        "key": "C",
        "text": "The first compiler error is on line 1."
      },
      {
        "key": "D",
        "text": "The first compiler error is on line 3."
      },
      {
        "key": "E",
        "text": "The first compiler error is on line 8."
      },
      {
        "key": "F",
        "text": "The first compiler error is on another line."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The record compiles and runs without issue. Line 8 gives a compiler warning for not \nusing generics but not a compiler error. Line 7 creates the Hello class with the generic type \nString. It also passes an int to the println() method, which gets autoboxed into an \nInteger. While the println() method takes a generic parameter of type T, it is not the \nsame <T> defined for the class on line 1. Instead, it is a different T defined as part of the \nmethod declaration on line 3. Therefore, the String argument on line 7 applies only to the \nclass. The method can take any object as a parameter, including autoboxed primitives. Line \n8 creates the Hello class with the generic type Object since no type is specified for that \ninstance. It passes a boolean to println(), which gets autoboxed into a Boolean. The \nresult is that hi-1hola-true is printed, making option B correct.\n"
  },
  {
    "id": "oca-199",
    "question": "Which of the following can fill in the blank to print [7, 5, 3]? (Choose all that apply.)\n8:  public record Platypus(String name, int beakLength) {\n9:     @Override public String toString() {return \"\" + beakLength;}\n10:\n11:    public static void main(String[] args) {\n12:       Platypus p1 = new Platypus(\"Paula\", 3);\n13:       Platypus p2 = new Platypus(\"Peter\", 5);\n14:       Platypus p3 = new Platypus(\"Peter\", 7);\n15:\n16:       List<Platypus> list = Arrays.asList(p1, p2, p3);\n17:\n18:       Collections.sort(list, Comparator.comparing      );\n19:\n20:       System.out.println(list);\n21:    }\n22: }",
    "choices": [
      {
        "key": "A",
        "text": "(Platypus::beakLength)\n(Platypus::beakLength)"
      },
      {
        "key": "B",
        "text": "(Platypus::beakLength).reversed()\n(Platypus::beakLength).reversed()"
      },
      {
        "key": "C",
        "text": "(Platypus::name)\n(Platypus::name)\n   .thenComparing(Platypus::beakLength)"
      },
      {
        "key": "D",
        "text": "(Platypus::name)\n(Platypus::name)\n   .thenComparing(\n   Comparator.comparing(Platypus::beakLength)\n   .reversed())"
      },
      {
        "key": "E",
        "text": "(Platypus::name)\n(Platypus::name)\n   .thenComparingNumber(Platypus::beakLength)\n   .reversed()"
      },
      {
        "key": "F",
        "text": "(Platypus::name)\n(Platypus::name)\n   .thenComparingInt(Platypus::beakLength)\n   .reversed()"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "We’re looking for a Comparator definition that sorts in descending order by \nbeakLength. Option A is incorrect because it sorts in ascending order by beakLength. \nSimilarly, option C is incorrect because it sorts by beakLength in ascending order within \nthose matches that have the same name. Option E is incorrect because there is no \nthenComparingNumber() method.\nOption B is a correct answer, as it sorts by beakLength in descending order. Options D \nand F are trickier. First, notice that we can call either thenComparing() or \nthenComparingInt() because the former will simply autobox the int into an \nInteger. Then observe what reversed() applies to. Option D is incorrect because it sorts \nby name in ascending order and only reverses the beak length of those with the same name. \nOption F creates a comparator that sorts by name in ascending order and then by beak size \nin ascending order. Finally, it reverses the result. This is just what we want, so option F is \ncorrect.\n"
  },
  {
    "id": "oca-200",
    "question": "Which of the following method signatures are valid overrides of the hairy() method in the \nAlpaca class? (Choose all that apply.)\nimport java.util.*;\n \npublic class Alpaca {\n   public List<String> hairy(List<String> list) { return null; }\n}",
    "choices": [
      {
        "key": "A",
        "text": "public List<String> hairy(List<CharSequence> list) { return null; }"
      },
      {
        "key": "B",
        "text": "public List<String> hairy(ArrayList<String> list) { return null; }"
      },
      {
        "key": "C",
        "text": "public List<String> hairy(List<Integer> list) { return null; }"
      },
      {
        "key": "D",
        "text": "public List<CharSequence> hairy(List<String> list) { return null; }"
      },
      {
        "key": "E",
        "text": "public Object hairy(List<String> list) { return null; }"
      },
      {
        "key": "F",
        "text": "public ArrayList<String> hairy(List<String> list) { return null; }"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "A valid override of a method with generic arguments must have a return type that is \ncovariant, with matching generic type parameters. Options D and E are incorrect because \nthe return type is too broad. Additionally, the generic arguments must have the same signa\u0002ture with the same generic types. This eliminates options A and C. The remaining options are \ncorrect, making the answer options B and F.\n"
  },
  {
    "id": "oca-201",
    "question": "What is the result of the following program?\n3:  public class MyComparator implements Comparator<String> {\n4:     public int compare(String a, String b) {\n5:        return b.toLowerCase().compareTo(a.toLowerCase());\n6:     }\n7:     public static void main(String[] args) {\n8:        String[] values = { \"123\", \"Abb\", \"aab\" };\n9:        Arrays.sort(values, new MyComparator());\n10:       for (var s: values)\n11:          System.out.print(s + \" \");\n12:    }\n13: }",
    "choices": [
      {
        "key": "A",
        "text": "Abb aab 123"
      },
      {
        "key": "B",
        "text": "aab Abb 123"
      },
      {
        "key": "C",
        "text": "123 Abb aab"
      },
      {
        "key": "D",
        "text": "123 aab Abb"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The array is sorted using MyComparator, which sorts the elements in reverse alpha\u0002betical order in a case-insensitive fashion. Normally, numbers sort before letters. This code \nreverses that by calling the compareTo() method on b instead of a. Therefore, option A \nis correct.\n"
  },
  {
    "id": "oca-202",
    "question": "Which of these statements can fill in the blank so that the Helper class compiles successfully? \n(Choose all that apply.)\n2:  public class Helper {\n3:     public static <U extends Exception>\n4:        void printException(U u) {\n5:\n6:        System.out.println(u.getMessage());\n7:     }\n8:     public static void main(String[] args) {\n9:        Helper.                                    ;\n10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "printException(new FileNotFoundException(\"A\"))"
      },
      {
        "key": "B",
        "text": "printException(new Exception(\"B\"))"
      },
      {
        "key": "C",
        "text": "<Throwable>printException(new Exception(\"C\"))"
      },
      {
        "key": "D",
        "text": "<NullPointerException>printException(new NullPointerException \n(\"D\"))"
      },
      {
        "key": "E",
        "text": "printException(new Throwable(\"E\"))"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "The generic type must be Exception or a subclass of Exception since this is an \nupper bound, making options A and B correct. Options C and E are wrong because \nThrowable is a superclass of Exception. Additionally, option D is correct despite the odd \nsyntax by explicitly listing the type. You should still be able to recognize it as acceptable.\n"
  },
  {
    "id": "oca-203",
    "question": "Which of the following will compile when filling in the blank? (Choose all that apply.)\nvar list = List.of(1, 2, 3);\nvar set = Set.of(1, 2, 3);\nvar map = Map.of(1, 2, 3, 4);\n \n.forEach(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "list"
      },
      {
        "key": "B",
        "text": "set"
      },
      {
        "key": "C",
        "text": "map"
      },
      {
        "key": "D",
        "text": "map.keys()"
      },
      {
        "key": "E",
        "text": "map.keySet()"
      },
      {
        "key": "F",
        "text": "map.values()"
      },
      {
        "key": "G",
        "text": "map.valueSet()"
      }
    ],
    "answer": [
      "A",
      "B",
      "E",
      "F"
    ],
    "explanation": "The forEach() method works with a List or a Set. Therefore, options A and \nB are correct. Additionally, options E and F return a Set and can be used as well. Options \nD and G refer to methods that do not exist. Option C is tricky because a Map does have a \nforEach() method. However, it uses two lambda parameters rather than one. Since there is \nno matching System.out.println method, it does not compile.\n"
  },
  {
    "id": "oca-204",
    "question": "Which of these statements can fill in the blank so that the Wildcard class compiles success-\nfully? (Choose all that apply.)\n3:  public class Wildcard {\n4:     public void showSize(List<?> list) {\n5:        System.out.println(list.size());\n6:     }\n7:     public static void main(String[] args) {\n8:        Wildcard card = new Wildcard();\n9:        ;\n10:       card.showSize(list);\n11:    } }",
    "choices": [
      {
        "key": "A",
        "text": "List<?> list = new HashSet <String>()"
      },
      {
        "key": "B",
        "text": "ArrayList<? super Date> list = new ArrayList<Date>()"
      },
      {
        "key": "C",
        "text": "List<?> list = new ArrayList<?>()"
      },
      {
        "key": "D",
        "text": "List<Exception> list = new LinkedList<java.io.IOException>()"
      },
      {
        "key": "E",
        "text": "ArrayList <? extends Number> list = new ArrayList <Integer>()"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "The showSize() method can take any type of List since it uses an unbounded wild\u0002card. Option A is incorrect because it is a Set and not a List. Option C is incorrect because \nthe wildcard is not allowed to be on the right side of an assignment. Option D is incorrect \nbecause the generic types are not compatible.\nOption B is correct because a lower-bounded wildcard allows that same type to be the \ngeneric. Option E is correct because Integer is a subclass of Number.\n"
  },
  {
    "id": "oca-205",
    "question": "What is the result of the following program?\n3:  public record Sorted(int num, String text)\n4:     implements Comparable<Sorted>, Comparator<Sorted> {\n5:\n6:     public String toString() { return \"\" + num; }\n7:     public int compareTo(Sorted s) {\n8:        return text.compareTo(s.text);\n9:     }\n10:    public int compare(Sorted s1, Sorted s2) {\n11:       return s1.num -  s2.num;\n12:    }\n13:    public static void main(String[] args) {\n14:       var s1 = new Sorted(88, \"a\");\n15:       var s2 = new Sorted(55, \"b\");\n16:       var t1 = new TreeSet<Sorted>();\n17:       t1.add(s1); t1.add(s2);\n18:       var t2 = new TreeSet<Sorted>(s1);\n19:       t2.add(s1); t2.add(s2);\n20:       System.out.println(t1 + \" \" + t2);\n21:    } }",
    "choices": [
      {
        "key": "A",
        "text": "[55, 88] [55, 88]"
      },
      {
        "key": "B",
        "text": "[55, 88] [88, 55]"
      },
      {
        "key": "C",
        "text": "[88, 55] [55, 88]"
      },
      {
        "key": "D",
        "text": "[88, 55] [88, 55]"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This question is difficult because it defines both Comparable and Comparator on \nthe same object. The t1 object doesn’t specify a Comparator, so it uses the Comparable\nobject’s compareTo() method. This sorts by the text instance variable. The t2 object \ndoes specify a Comparator when calling the constructor, so it uses the compare() method, \nwhich sorts by the int. This gives us option C as the answer.\n"
  },
  {
    "id": "oca-206",
    "question": "What is the result of the following code? (Choose all that apply.)\nComparator<Integer> c1 = (o1, o2) - > o2 -  o1;\nComparator<Integer> c2 = Comparator.naturalOrder();\nComparator<Integer> c3 = Comparator.reverseOrder();\n \nvar list = Arrays.asList(5, 4, 7, 2);\nCollections.sort(list,         );\nCollections.reverse(list);\nCollections.reverse(list);\nSystem.out.println(Collections.binarySearch(list, 2));",
    "choices": [
      {
        "key": "A",
        "text": "One or more of the comparators can fill in the blank so that the code prints 0."
      },
      {
        "key": "B",
        "text": "One or more of the comparators can fill in the blank so that the code prints 1."
      },
      {
        "key": "C",
        "text": "One or more of the comparators can fill in the blank so that the code prints 2."
      },
      {
        "key": "D",
        "text": "The result is undefined regardless of which comparator is used."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown regardless of which comparator is used."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "When using binarySearch(), the List must be sorted in the same order that the \nComparator uses. Since the binarySearch() method does not specify a Comparator\nexplicitly, the default sort order is used. Only c2 uses that sort order and correctly identifies \nthat the value 2 is at index 0. Therefore, option A is correct. The other two comparators sort \nin descending order. Therefore, the precondition for binarySearch() is not met, and the \nresult is undefined for those two. The two calls to reverse() are just there to distract you; \nthey cancel each other out.\n"
  },
  {
    "id": "oca-207",
    "question": "Which of the following lines can be inserted to make the code compile? (Choose all \nthat apply.)\nclass W {}\nclass X extends W {}\nclass Y extends X {}\nclass Z<Y> {\n   // INSERT CODE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "W w1 = new W();"
      },
      {
        "key": "B",
        "text": "W w2 = new X();"
      },
      {
        "key": "C",
        "text": "W w3 = new Y();"
      },
      {
        "key": "D",
        "text": "Y y1 = new W();"
      },
      {
        "key": "E",
        "text": "Y y2 = new X();"
      },
      {
        "key": "F",
        "text": "Y y1 = new Y();"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Y is both a class and a type parameter. This means that within the class Z, when we \nrefer to Y, it uses the type parameter. All of the choices that mention class Y are incorrect \nbecause it no longer means the class Y. Only options A and B are correct.\n"
  },
  {
    "id": "oca-208",
    "question": "Which options are true of the following code? (Choose all that apply.)\n3:  q = new LinkedList<>();\n4: q.add(10);\n5: q.add(12);\n6: q.remove(1);\n7: System.out.print(q);",
    "choices": [
      {
        "key": "A",
        "text": "If we fill in the blank with List<Integer>, the output is [10]."
      },
      {
        "key": "B",
        "text": "If we fill in the blank with Queue<Integer>, the output is [10]."
      },
      {
        "key": "C",
        "text": "If we fill in the blank with var, the output is [10]."
      },
      {
        "key": "D",
        "text": "One or more of the scenarios does not compile."
      },
      {
        "key": "E",
        "text": "One or more of the scenarios throws a runtime exception."
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "A LinkedList implements both List and Queue. The List interface has a method \nto remove by index. Since this method exists, Java does not autobox to call the other method, \nmaking the output [10] and option A correct. Similarly, option C is correct because the \nmethod to remove an element by index is available on a LinkedList<Object> (which is \nwhat var represents here). By contrast, Queue has only the remove by object method, so \nJava does autobox there. Since the number 1 is not in the list, Java does not remove anything \nfor the Queue, and the output is [10, 12].\n"
  },
  {
    "id": "oca-209",
    "question": "What is the result of the following code?\n4: Map m = new HashMap();\n5: m.put(123, \"456\");\n6: m.put(\"abc\", \"def\");\n7: System.out.println(m.contains(\"123\"));",
    "choices": [
      {
        "key": "A",
        "text": "false"
      },
      {
        "key": "B",
        "text": "true"
      },
      {
        "key": "C",
        "text": "Compiler error on line 4"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5"
      },
      {
        "key": "E",
        "text": "Compiler error on line 7"
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This question looks like it is about generics, but it’s not. It is trying to see whether you \nnoticed that Map does not have a contains() method. It has containsKey() and \ncontainsValue() instead, making option E the answer. If containsKey() were \ncalled, the answer would be false because 123 is an Integer key in the Map, rather \nthan a String.\n"
  },
  {
    "id": "oca-210",
    "question": "What is the result of the following code? (Choose all that apply.)\n48: var map = Map.of(1,2, 3, 6);\n49: var list = List.copyOf(map.entrySet());\n50:\n51: List<Integer> one = List.of(8, 16, 2);\n52: var copy = List.copyOf(one);\n53: var copyOfCopy = List.copyOf(copy);\n54: var thirdCopy = new ArrayList<>(copyOfCopy);\n55:\n56: list.replaceAll(x - > x * 2);\n57: one.replaceAll(x - > x * 2);\n58: thirdCopy.replaceAll(x - > x * 2);\n59:\n60: System.out.println(thirdCopy);",
    "choices": [
      {
        "key": "A",
        "text": "One line fails to compile."
      },
      {
        "key": "B",
        "text": "Two lines fail to compile."
      },
      {
        "key": "C",
        "text": "Three lines fail to compile."
      },
      {
        "key": "D",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "E",
        "text": "If any lines with compiler errors are removed, the code throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "If any lines with compiler errors are removed, the code prints [16, 32, 4]."
      },
      {
        "key": "G",
        "text": "The code compiles and prints [16, 32, 4] without any changes."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The key to this question is keeping track of the types. Line 48 is a \nMap<Integer, Integer>. Line 49 builds a List out of a Set of Entry objects, giving \nus List<Entry<Integer, Integer>>. This causes a compiler error on line 56 since we \ncan’t multiply an Entry object by two.\nLines 51–54 are all of type List<Integer>. The first three are immutable, and the one on \nline 54 is mutable. This means line 57 throws an UnsupportedOperationException\nsince we attempt to modify the list. Line 58 would work if we could get to it. Since there is \none compiler error and one runtime error, options A and E are correct.\n"
  },
  {
    "id": "oca-211",
    "question": "What code change is needed to make the method compile, assuming there is no \nclass named T?\npublic static T identity(T t) {\n   return t;\n}",
    "choices": [
      {
        "key": "A",
        "text": "Add <T> after the public keyword."
      },
      {
        "key": "B",
        "text": "Add <T> after the static keyword."
      },
      {
        "key": "C",
        "text": "Add <T> after T."
      },
      {
        "key": "D",
        "text": "Add <?> after the public keyword."
      },
      {
        "key": "E",
        "text": "Add <?> after the static keyword."
      },
      {
        "key": "F",
        "text": "No change is required. The code already compiles."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "When using generic types in a method, the generic specification goes before the return \ntype and option B is correct.\n"
  },
  {
    "id": "oca-212",
    "question": "What is the result of the following?\nvar map = new HashMap<Integer, Integer>();\nmap.put(1, 10);\nmap.put(2, 20);\nmap.put(3, null);\nmap.merge(1, 3, (a,b) - > a + b);\nmap.merge(3, 3, (a,b) - > a + b);\nSystem.out.println(map);",
    "choices": [
      {
        "key": "A",
        "text": "{1=10, 2=20}"
      },
      {
        "key": "B",
        "text": "{1=10, 2=20, 3=null}"
      },
      {
        "key": "C",
        "text": "{1=10, 2=20, 3=3}"
      },
      {
        "key": "D",
        "text": "{1=13, 2=20}"
      },
      {
        "key": "E",
        "text": "{1=13, 2=20, 3=null}"
      },
      {
        "key": "F",
        "text": "{1=13, 2=20, 3=3}"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The first call to merge() calls the mapping function and adds the numbers to get 13. It \nthen updates the map. The second call to merge() sees that the map currently has a null\nvalue for that key. It does not call the mapping function but instead replaces it with the new \nvalue of 3. Therefore, option F is correct.\n"
  },
  {
    "id": "oca-213",
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Comparable is in the java.util package."
      },
      {
        "key": "B",
        "text": "Comparator is in the java.util package."
      },
      {
        "key": "C",
        "text": "compare() is in the Comparable interface."
      },
      {
        "key": "D",
        "text": "compare() is in the Comparator interface."
      },
      {
        "key": "E",
        "text": "compare() takes one method parameter."
      },
      {
        "key": "F",
        "text": "compare() takes two method parameters."
      }
    ],
    "answer": [
      "B",
      "D",
      "F"
    ],
    "explanation": "The java.lang.Comparable interface is implemented on the object to \ncompare. It specifies the compareTo() method, which takes one parameter. The \njava.util.Comparator interface specifies the compare() method, which takes two \nparameters. This gives us options B, D, and F as the answers.\n"
  },
  {
    "id": "oca-214",
    "question": "What could be the output of the following?\nvar stream = Stream.iterate(\"\", (s) - > s + \"1\");\nSystem.out.println(stream.limit(2).map(x - > x + \"2\"));",
    "choices": [
      {
        "key": "A",
        "text": "12112"
      },
      {
        "key": "B",
        "text": "212"
      },
      {
        "key": "C",
        "text": "212112"
      },
      {
        "key": "D",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      },
      {
        "key": "G",
        "text": "The code hangs."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "No terminal operation is called, so the stream never executes. The first line creates an infi\u0002nite stream reference. If the stream were executed on the second line, it would get the first \ntwo elements from that infinite stream, \"\" and \"1\", and add an extra character, resulting in \n\"2\" and \"12\", respectively. Since the stream is not executed, the reference is printed instead, \ngiving us option D.\n"
  },
  {
    "id": "oca-215",
    "question": "What could be the output of the following?\nPredicate<String> predicate = s - > s.startsWith(\"g\");\nvar stream1 = Stream.generate(() - > \"growl!\");\nvar stream2 = Stream.generate(() - > \"growl!\");\nvar b1 = stream1.anyMatch(predicate);\nvar b2 = stream2.allMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
    "choices": [
      {
        "key": "A",
        "text": "true false"
      },
      {
        "key": "B",
        "text": "true true"
      },
      {
        "key": "C",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code hangs."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Both streams created in this code snippet are infinite streams. The variable b1 is set to \ntrue since anyMatch() terminates. Even though the stream is infinite, Java finds a match \non the first element and stops looking. However, when allMatch() runs, it needs to keep \ngoing until the end of the stream since it keeps finding matches. Since all elements continue \nto match, the program hangs, making option F the answer.\n"
  },
  {
    "id": "oca-216",
    "question": "What could be the output of the following?\nPredicate<String> predicate = s - > s.length()> 3;\nvar stream = Stream.iterate(\"- \",\n    s - > ! s.isEmpty(), (s) - > s + s);\nvar b1 = stream.noneMatch(predicate);\nvar b2 = stream.anyMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
    "choices": [
      {
        "key": "A",
        "text": "false false"
      },
      {
        "key": "B",
        "text": "false true"
      },
      {
        "key": "C",
        "text": "java.util.stream.ReferencePipeline$3@4517d9a3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code hangs."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "An infinite stream is generated where each element is twice as long as the previous one. \nWhile this code uses the three-parameter iterate() method, the condition is never false. \nThe variable b1 is set to false because Java finds an element that matches when it gets to \nthe element of length 4. However, the next line tries to operate on the same stream. Since \nstreams can be used only once, this throws an exception that the “stream has already been \noperated upon or closed” and making option E the answer. If two different streams were \nused, the result would be option B.\n"
  },
  {
    "id": "oca-217",
    "question": "Which are true statements about terminal operations in a stream that runs successfully? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "At most one terminal operation can exist in a stream pipeline."
      },
      {
        "key": "B",
        "text": "Terminal operations are a required part of the stream pipeline in order to get a result."
      },
      {
        "key": "C",
        "text": "Terminal operations have Stream as the return type."
      },
      {
        "key": "D",
        "text": "The peek() method is an example of a terminal operation."
      },
      {
        "key": "E",
        "text": "The referenced Stream may be used after calling a terminal operation."
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Terminal operations are the final step in a stream pipeline. Exactly one is required, \nbecause it triggers the execution of the entire stream pipeline. Therefore, options A and B are \ncorrect. Option C is true of intermediate operations rather than terminal operations. Option \nD is incorrect because peek() is an intermediate operation. Finally, option E is incorrect \nbecause once a stream pipeline is run, the Stream is marked invalid.\n"
  },
  {
    "id": "oca-218",
    "question": "Which of the following sets result to 8.0? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      },
      {
        "key": "B",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      },
      {
        "key": "C",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x))\n   .keySet()\n    .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      },
      {
        "key": "D",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      },
      {
        "key": "E",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      },
      {
        "key": "F",
        "text": "double result = LongStream.of(6L, 8L, 10L)\ndouble result = LongStream.of(6L, 8L, 10L)\n   .mapToInt(x - > (int) x)\n   .boxed()\n   .collect(Collectors.groupingBy(x - > x, Collectors.toSet()))\n   .keySet()\n   .stream()\n   .collect(Collectors.averagingInt(x - > x));"
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "Yes, we know this question is a lot of reading. Remember to look for the differences \nbetween options rather than studying each line. These options all have much in common. All \nof them start out with a LongStream and attempt to convert it to an IntStream. How\u0002ever, options B and E are incorrect because they do not cast the long to an int, resulting in \na compiler error on the mapToInt() calls.\nNext, we hit the second difference. Options A and D are incorrect because they are missing \nboxed() before the collect() call. Since groupingBy() is creating a Collection, we \nneed a nonprimitive Stream. The final difference is that option F specifies the type of \nCollection. This is allowed, though, meaning both options C and F are correct.\n"
  },
  {
    "id": "oca-219",
    "question": "Which of the following can fill in the blank so that the code prints out false? (Choose all \nthat apply.)\nvar s = Stream.generate(() - > \"meow\");\nvar match = s. (String::isEmpty);\nSystem.out.println(match);",
    "choices": [
      {
        "key": "A",
        "text": "allMatch"
      },
      {
        "key": "B",
        "text": "anyMatch"
      },
      {
        "key": "C",
        "text": "findAny"
      },
      {
        "key": "D",
        "text": "findFirst"
      },
      {
        "key": "E",
        "text": "noneMatch"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Options C and D do not compile because these methods do not take a Predicate\nparameter and do not return a boolean. When working with streams, it is important to \nremember the behavior of the underlying functional interfaces. Options B and E are incor\u0002rect. While the code compiles, it runs infinitely. The stream has no way to know that a match \nwon’t show up later. Option A is correct because it is safe to return false as soon as one \nelement passes through the stream that doesn’t match.\n"
  },
  {
    "id": "oca-220",
    "question": "We have a method that returns a sorted list without changing the original. Which of the fol-\nlowing can replace the method implementation to do the same with streams?\nprivate static List<String> sort(List<String> list) {\n   var copy = new ArrayList<String>(list);\n   Collections.sort(copy, (a, b) - > b.compareTo(a));\n   return copy;\n}",
    "choices": [
      {
        "key": "A",
        "text": "return list.stream()\nreturn list.stream()\n   .compare((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());"
      },
      {
        "key": "B",
        "text": "return list.stream()\nreturn list.stream()\n   .compare((a, b) - > b.compareTo(a))\n   .sort();"
      },
      {
        "key": "C",
        "text": "return list.stream()\nreturn list.stream()\n   .compareTo((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());"
      },
      {
        "key": "D",
        "text": "return list.stream()\nreturn list.stream()\n   .compareTo((a, b) - > b.compareTo(a))\n   .sort();"
      },
      {
        "key": "E",
        "text": "return list.stream()\nreturn list.stream()\n   .sorted((a, b) - > b.compareTo(a))\n    .collect();"
      },
      {
        "key": "F",
        "text": "return list.stream()\nreturn list.stream()\n   .sorted((a, b) - > b.compareTo(a))\n   .collect(Collectors.toList());"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "There is no Stream<T> method called compare() or compareTo(), so options A \nthrough D can be eliminated. The sorted() method is correct to use in a stream pipeline \nto return a sorted Stream. The collect() method can be used to turn the stream into a \nList. The collect() method requires a collector be selected, making option E incorrect \nand option F correct.\n"
  },
  {
    "id": "oca-221",
    "question": "Which of the following are true given this declaration? (Choose all that apply.)\nvar is = IntStream.empty();",
    "choices": [
      {
        "key": "A",
        "text": "is.average() returns the type int."
      },
      {
        "key": "B",
        "text": "is.average() returns the type OptionalInt."
      },
      {
        "key": "C",
        "text": "is.findAny() returns the type int."
      },
      {
        "key": "D",
        "text": "is.findAny() returns the type OptionalInt."
      },
      {
        "key": "E",
        "text": "is.sum() returns the type int."
      },
      {
        "key": "F",
        "text": "is.sum() returns the type OptionalInt."
      }
    ],
    "answer": [
      "D",
      "E"
    ],
    "explanation": "The average() method returns an OptionalDouble since averages of any type can \nresult in a fraction. Therefore, options A and B are both incorrect. The findAny() method \nreturns an OptionalInt because there might not be any elements to find. Therefore, option \nD is correct. The sum() method returns an int rather than an OptionalInt because the \nsum of an empty list is zero. Therefore, option E is correct.\n"
  },
  {
    "id": "oca-222",
    "question": "Which of the following can we add after line 6 for the code to run without error and not pro-\nduce any output? (Choose all that apply.)\n4: var stream = LongStream.of(1, 2, 3);\n5: var opt = stream.map(n - > n * 10)\n6:    .filter(n - > n < 5).findFirst();",
    "choices": [
      {
        "key": "A",
        "text": "if (opt.isPresent())\nif (opt.isPresent())\n   System.out.println(opt.get());"
      },
      {
        "key": "B",
        "text": "if (opt.isPresent())\nif (opt.isPresent())\n   System.out.println(opt.getAsLong());"
      },
      {
        "key": "C",
        "text": "opt.ifPresent(System.out.println);\nopt.ifPresent(System.out.println);"
      },
      {
        "key": "D",
        "text": "opt.ifPresent(System.out::println);\nopt.ifPresent(System.out::println);"
      },
      {
        "key": "E",
        "text": "None of these; the code does not compile."
      },
      {
        "key": "F",
        "text": "None of these; line 6 throws an exception at runtime."
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Lines 4–6 compile and run without issue, making option F incorrect. Line 4 creates a \nstream of elements [1, 2, 3]. Line 5 maps the stream to a new stream with values \n[10, 20, 30]. Line 6 filters out all items not less than 5, which in this case results in an \nempty stream. For this reason, findFirst() returns an empty Optional.\nOption A does not compile. It would work for a Stream<T> object, but we have a \nLongStream and therefore need to call getAsLong(). Option C also does not compile, as \nit is missing the :: that would make it a method reference. Options B and D both compile \nand run without error, although neither produces any output at runtime since the stream is \nempty.\n"
  },
  {
    "id": "oca-223",
    "question": "Given the four statements (L, M, N, O), select and order the ones that would complete the \nexpression and cause the code to output 10 lines. (Choose all that apply.)\nStream.generate(() - > \"1\")\n   L: .filter(x - > x.length()> 1)\n   M: .forEach(System.out::println)\n   N: .limit(10)\n   O: .peek(System.out::println)\n;",
    "choices": [
      {
        "key": "A",
        "text": "L, N"
      },
      {
        "key": "B",
        "text": "L, N, O"
      },
      {
        "key": "C",
        "text": "L, N, M"
      },
      {
        "key": "D",
        "text": "L, N, M, O"
      },
      {
        "key": "E",
        "text": "L, O, M"
      },
      {
        "key": "F",
        "text": "N, M"
      },
      {
        "key": "G",
        "text": "N, O"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Only one of the method calls, forEach(), is a terminal operation, so any answer in \nwhich M is not the last line will not execute the pipeline. This eliminates all but options C, E, \nand F. Option C is incorrect because filter() is called before limit(). Since none of the \nelements of the stream meets the requirement for the Predicate<String>, the filter()\noperation will run infinitely, never passing any elements to limit(). Option E is incorrect \nbecause there is no limit() operation, which means that the code would run infinitely. \nOnly option F is correct. It first limits the infinite stream to a finite stream of ten elements \nand then prints the result.\n"
  },
  {
    "id": "oca-224",
    "question": "What changes need to be made together for this code to print the string 12345? (Choose all \nthat apply.)\nStream.iterate(1, x - > x++)\n   .limit(5).map(x - > x)\n   .collect(Collectors.joining());",
    "choices": [
      {
        "key": "A",
        "text": "Change Collectors.joining() to Collectors.joining(\",\")."
      },
      {
        "key": "B",
        "text": "Change map(x - > x) to map(x - > \"\" + x)."
      },
      {
        "key": "C",
        "text": "Change x - > x++ to x - > ++x."
      },
      {
        "key": "D",
        "text": "Add .forEach(System.out::print) after the call to collect()."
      },
      {
        "key": "E",
        "text": "Wrap the entire line in a System.out.print statement."
      },
      {
        "key": "F",
        "text": "None of the above. The code already prints 12345."
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "As written, the code doesn’t compile because the Collectors.joining() expects \nto get a Stream<String>. Option B fixes this, at which point nothing is output because \nthe collector creates a String without outputting the result. Option E fixes this and causes \nthe output to be 11111. Since the post-increment operator is used, the stream contains an \ninfinite number of the character 1. Option C fixes this and causes the stream to contain \nincreasing numbers.\n"
  },
  {
    "id": "oca-225",
    "question": "Which is true of the following code?\nSet<String> birds = Set.of(\"oriole\", \"flamingo\");\nStream.concat(birds.stream(), birds.stream(), birds.stream())\n   .sorted()       // line X\n   .distinct()\n   .findAny()\n   .ifPresent(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "It is guaranteed to print flamingo as is and when line X is removed."
      },
      {
        "key": "B",
        "text": "It is guaranteed to print oriole as is and when line X is removed."
      },
      {
        "key": "C",
        "text": "It is guaranteed to print flamingo as is, but not when line X is removed."
      },
      {
        "key": "D",
        "text": "It is guaranteed to print oriole as is, but not when line X is removed."
      },
      {
        "key": "E",
        "text": "The output may vary as is."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "It throws an exception because the same list is used as the source for multiple streams."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because Stream.concat() takes two parameters, not the \nthree provided. This makes the answer option F.\n"
  },
  {
    "id": "oca-226",
    "question": "Which of the following is true?\nList<Integer> x1 = List.of(1, 2, 3);\nList<Integer> x2 = List.of(4, 5, 6);\nList<Integer> x3 = List.of();\nStream.of(x1, x2, x3).map(x - > x + 1)\n   .flatMap(x - > x.stream())\n   .forEach(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles and prints 123456."
      },
      {
        "key": "B",
        "text": "The code compiles and prints 234567."
      },
      {
        "key": "C",
        "text": "The code compiles but does not print anything."
      },
      {
        "key": "D",
        "text": "The code compiles but prints stream references."
      },
      {
        "key": "E",
        "text": "The code runs infinitely."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code throws an exception."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "If the map() and flatMap() calls were reversed, option B would be correct. In this case, \nthe Stream created from the source is of type Stream<List>. Trying to use the addition \noperator (+) on a List is not supported in Java. Therefore, the code does not compile, and \noption F is correct.\n"
  },
  {
    "id": "oca-227",
    "question": "Which of the following are true? (Choose all that apply.)\n4: Stream<Integer> s = Stream.of(1);\n5: IntStream is = s.boxed();\n6: DoubleStream ds = s.mapToDouble(x - > x);\n7: Stream<Integer> s2 = ds.mapToInt(x - > x);\n8: s2.forEach(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "Line 4 causes a compiler error."
      },
      {
        "key": "B",
        "text": "Line 5 causes a compiler error."
      },
      {
        "key": "C",
        "text": "Line 6 causes a compiler error."
      },
      {
        "key": "D",
        "text": "Line 7 causes a compiler error."
      },
      {
        "key": "E",
        "text": "Line 8 causes a compiler error."
      },
      {
        "key": "F",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "G",
        "text": "The code compiles and prints 1."
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Line 4 creates a Stream and uses autoboxing to put the Integer wrapper of 1\ninside. Line 5 does not compile because boxed() is available only on primitive streams like \nIntStream, not Stream<Integer>. This makes option B one answer. Line 6 converts \nto a double primitive, which works since Integer can be unboxed to a value that can be \nimplicitly cast to a double. Line 7 does not compile for two reasons making option D the \nsecond answer. First, converting from a double to an int would require an explicit cast. \nAlso, mapToInt() returns an IntStream, so the data type of s2 is incorrect. The rest of \nthe lines compile without issue.\n"
  },
  {
    "id": "oca-228",
    "question": "Given the generic type String, the partitioningBy() collector creates a \nMap<Boolean, List<String>> when passed to collect() by default. When a down-\nstream collector is passed to partitioningBy(), which return types can be created? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Map<boolean, List<String>>"
      },
      {
        "key": "B",
        "text": "Map<Boolean, List<String>>"
      },
      {
        "key": "C",
        "text": "Map<Boolean, Map<String>>"
      },
      {
        "key": "D",
        "text": "Map<Boolean, Set<String>>"
      },
      {
        "key": "E",
        "text": "Map<Long, TreeSet<String>>"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Options A and C do not compile because they are invalid generic declarations. Prim\u0002itives are not allowed as generics, and Map must have two generic type parameters. Option \nE is incorrect because partitioning only gives a Boolean key. Options B and D are correct \nbecause they return a Map with a Boolean key and a value type that can be customized to \nany Collection.\n"
  },
  {
    "id": "oca-229",
    "question": "Which of the following statements are true about this code? (Choose all that apply.)\n20: Predicate<String> empty = String::isEmpty;\n21: Predicate<String> notEmpty = empty.negate();\n22:\n23: var result = Stream.generate(() - > \"\")\n24:    .limit(10)\n25:    .filter(notEmpty)\n26:    .collect(Collectors.groupingBy(k - > k))\n27:    .entrySet()\n28:    .stream()\n29:    .map(Entry::getValue)\n30:    .flatMap(Collection::stream)\n31:    .collect(Collectors.partitioningBy(notEmpty));\n32: System.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs {}."
      },
      {
        "key": "B",
        "text": "It outputs {false=[], true=[]}."
      },
      {
        "key": "C",
        "text": "If we changed line 31 from partitioningBy(notEmpty) to  \ngroupingBy(n - > n), it would output {}."
      },
      {
        "key": "D",
        "text": "If we changed line 31 from partitioningBy(notEmpty) to  \ngroupingBy(n - > n), it would output {false=[], true=[]}."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but does not terminate at runtime."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "First, this mess of code does compile. While it starts with an infinite stream on line \n23, it becomes finite on line 24 thanks to limit(), making option F incorrect. The pipeline \npreserves only nonempty elements on line 25. Since there aren’t any of those, the pipeline is \nempty. Line 26 converts this to an empty map.\nLines 27 and 28 create a Set with no elements and then another empty stream. Lines 29 and \n30 convert the generic type of the Stream to List<String> and then String. Finally, \nline 31 gives us another Map<Boolean, List<String>>.\nThe partitioningBy() operation always returns a map with two Boolean keys, even \nif there are no corresponding values. Therefore, option B is correct if the code is kept as is. \nBy contrast, groupingBy() returns only keys that are actually needed, making option C \ncorrect if the code is modified on line 31.\n"
  },
  {
    "id": "oca-230",
    "question": "What is the result of the following?\nvar s = DoubleStream.of(1.2, 2.4);\ns.peek(System.out::println).filter(x - > x> 2).count();",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "2.4"
      },
      {
        "key": "D",
        "text": "1.2 and 2.4"
      },
      {
        "key": "E",
        "text": "There is no output."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The terminal operation is count(). Since there is a terminal operation, the intermediate \noperations run. The peek() operation comes before the filter(), so both numbers are \nprinted, making option D the answer. After the filter(), the count() happens to be 1\nsince one of the numbers is filtered out. However, the result of the stream pipeline isn’t stored \nin a variable or printed, and it is ignored.\n"
  },
  {
    "id": "oca-231",
    "question": "What is the output of the following?\n11: public class Paging {\n12:    record Sesame(String name, boolean human)  {\n13:       @Override public String toString() {\n14:          return name();\n15:       }\n16:    } \n17:    record Page(List<Sesame> list, long count)  {}\n18:\n19:    public static void main(String[] args) {\n20:       var monsters = Stream.of(new Sesame(\"Elmo\", false));\n21:       var people = Stream.of(new Sesame(\"Abby\", true));\n22:       printPage(monsters, people);\n23:    }\n24:\n25:    private static void printPage(Stream<Sesame> monsters, \n26:          Stream<Sesame> people) {\n27:       Page page = Stream.concat(monsters, people)\n28:          .collect(Collectors.teeing(\n29:             Collectors.filtering(s - > s.name().startsWith(\"E\"), \n30:                Collectors.toList()),\n31:             Collectors.counting(),\n32:             (l, c) - > new Page(l, c)));\n33:       System.out.println(page);\n34:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Page[list=[Abby], count=1]"
      },
      {
        "key": "B",
        "text": "Page[list=[Abby], count=2]"
      },
      {
        "key": "C",
        "text": "Page[list=[Elmo], count=1]"
      },
      {
        "key": "D",
        "text": "Page[list=[Elmo], count=2]"
      },
      {
        "key": "E",
        "text": "The code does not compile due to Stream.concat()."
      },
      {
        "key": "F",
        "text": "The code does not compile due to Collectors.teeing()."
      },
      {
        "key": "G",
        "text": "The code does not compile for another reason."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This compiles, ruling out options E, F, and G. Since line 29 filters by names starting with \nE, that rules out options A and B. Finally, line 31 counts the entire list, which is of size 2, \ngiving us option D as the answer.\n"
  },
  {
    "id": "oca-232",
    "question": "What is the simplest way of rewriting this code?\nList<Integer> x = IntStream.range(1, 6)\n   .mapToObj(i - > i)\n   .collect(Collectors.toList());\nx.forEach(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "IntStream.range(1, 6);\nIntStream.range(1, 6);"
      },
      {
        "key": "B",
        "text": "IntStream.range(1, 6)\nIntStream.range(1, 6)\n   .forEach(System.out::println);"
      },
      {
        "key": "C",
        "text": " IntStream.range(1, 6)\n IntStream.range(1, 6)\n    .mapToObj(i - > i)\n    .forEach(System.out::println);"
      },
      {
        "key": "D",
        "text": "None of the above is equivalent."
      },
      {
        "key": "E",
        "text": "The provided code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Both lists and streams have forEach() methods. There is no reason to collect into a list \njust to loop through it. Option A is incorrect because it does not contain a terminal operation \nor print anything. Options B and C both work. However, the question asks about the sim\u0002plest way, which is option B.\n"
  },
  {
    "id": "oca-233",
    "question": "Which of the following throw an exception when an Optional is empty? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "opt.orElse(\"\");"
      },
      {
        "key": "B",
        "text": "opt.orElseGet(() - > \"\");"
      },
      {
        "key": "C",
        "text": "opt.orElseThrow();"
      },
      {
        "key": "D",
        "text": "opt.orElseThrow(() - > throw new Exception());"
      },
      {
        "key": "E",
        "text": "opt.orElseThrow(RuntimeException::new);"
      },
      {
        "key": "F",
        "text": "opt.get();"
      },
      {
        "key": "G",
        "text": "opt.get(\"\");"
      }
    ],
    "answer": [
      "C",
      "E",
      "F"
    ],
    "explanation": "Options A and B compile and return an empty string without throwing an \nexception, using a String and Supplier parameter, respectively. Option G does \nnot compile as the get() method does not take a parameter. Options C and F throw a \nNoSuchElementException. Option E throws a RuntimeException. Option D looks \ncorrect but will compile only if the throw is removed. Remember, the orElseThrow()\nshould get a lambda expression or method reference that returns an exception, not one that \nthrows an exception.\n"
  },
  {
    "id": "oca-234",
    "question": "What is the output of the following?\nvar spliterator = Stream.generate(() - > \"x\")\n   .spliterator();\n \nspliterator.tryAdvance(System.out::print);  \nvar split = spliterator.trySplit();\nsplit.tryAdvance(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "x"
      },
      {
        "key": "B",
        "text": "xx"
      },
      {
        "key": "C",
        "text": "A long list of x’s"
      },
      {
        "key": "D",
        "text": "There is no output."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code compiles but does not terminate at runtime.\nExceptions and"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "We start with an infinite stream where each element is x. The spliterator()\nmethod is a terminal operation since it returns a Spliterator rather than a Stream. \nThe tryAdvance() method gets the first element and prints a single x. The trySplit()\nmethod takes a large number of elements from the stream. Since this is an infinite stream, it \ndoesn’t attempt to take half. Then tryAdvance() is called on the new split variable, and \nanother x is printed. Since there are two values printed, option B is correct.\n"
  },
  {
    "id": "oca-235",
    "question": "Which of the following can be inserted on line 8 to make this code compile? (Choose all \nthat apply.)\n    7: public void whatHappensNext() throws IOException {\n    8:    // INSERT CODE HERE\n    9: }",
    "choices": [
      {
        "key": "A",
        "text": "System.out.println(\"it's ok\");"
      },
      {
        "key": "B",
        "text": "throw new Exception();"
      },
      {
        "key": "C",
        "text": "throw new IllegalArgumentException();"
      },
      {
        "key": "D",
        "text": "throw new java.io.IOException();"
      },
      {
        "key": "E",
        "text": "throw new RuntimeException();"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "A method that declares an exception isn’t required to throw one, making option \nA correct. Unchecked exceptions can be thrown in any method, making options C and E \ncorrect. Option D matches the exception type declared, so it’s also correct. Option B is incor\u0002rect because a broader exception is not allowed.\n"
  },
  {
    "id": "oca-236",
    "question": "Which statement about the following class is correct?\n    1:  class Problem extends Exception {\n    2:     public Problem() {}\n    3:  }\n    4:  class YesProblem extends Problem {}\n    5:  public class MyDatabase {\n    6:     public static void connectToDatabase() throw Problem {\n    7:        throws new YesProblem();\n    8:     }\n    9:     public static void main(String[] c) throw Exception {\n    10:       connectToDatabase();\n    11:    }\n    12: }",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles and prints a stack trace for YesProblem at runtime."
      },
      {
        "key": "B",
        "text": "The code compiles and prints a stack trace for Problem at runtime."
      },
      {
        "key": "C",
        "text": "The code does not compile because Problem defines a constructor."
      },
      {
        "key": "D",
        "text": "The code does not compile because YesProblem does not define a constructor."
      },
      {
        "key": "E",
        "text": "The code does not compile but would if Problem and YesProblem were switched on lines \n6 and 7."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because the throw and throws keywords are incorrectly used \non lines 6, 7, and 9. If the keywords were fixed, the rest of the code would compile and print \na stack trace with YesProblem at runtime. For this reason, option F is correct.\n"
  },
  {
    "id": "oca-237",
    "question": "Which of the following are common types to localize? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Dates"
      },
      {
        "key": "B",
        "text": "Lambda expressions"
      },
      {
        "key": "C",
        "text": "Class names"
      },
      {
        "key": "D",
        "text": "Currency"
      },
      {
        "key": "E",
        "text": "Numbers"
      },
      {
        "key": "F",
        "text": "Variable names"
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "Localization refers to user-facing elements. Dates, currency, and numbers are com\u0002monly used in different formats for different countries, making options A, D, and E correct. \nClass and variable names, along with lambda expressions, are internal to the application, so \nthere is no need to translate them for users.\n"
  },
  {
    "id": "oca-238",
    "question": "What is the output of the following snippet, assuming a and b are both 0?\n    3:  try {\n    4:     System.out.print(a / b);\n    5:  } catch (RuntimeException e) {\n    6:     System.out.print(- 1);\n    7:  } catch (ArithmeticException e) {\n    8:     System.out.print(0);\n    9:  } finally {\n    10:    System.out.print(\"done\");\n    11: }",
    "choices": [
      {
        "key": "A",
        "text": "- 1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "done- 1"
      },
      {
        "key": "D",
        "text": "done0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The order of catch blocks is important because they’re checked in the order \nthey appear after the try block. Because ArithmeticException is a child \nclass of RuntimeException, the catch block on line 7 is unreachable (if an \nArithmeticException is thrown in the try block, it will be caught on line 5). Line 7 \ngenerates a compiler error because it is unreachable code, making option E correct.\n"
  },
  {
    "id": "oca-239",
    "question": "Assuming the current locale uses dollars ($) and the following method is called with a double \nvalue of 100_102.2, which of the following values are printed? (Choose all that apply.)\n    public void print(double t) {\n       System.out.print(NumberFormat.getCompactNumberInstance().format(t));\n \n       System.out.print(\n          NumberFormat.getCompactNumberInstance(\n             Locale.getDefault(), Style.SHORT).format(t));\n \n       System.out.print(NumberFormat.getCurrencyInstance().format(t));\n    }",
    "choices": [
      {
        "key": "A",
        "text": "100"
      },
      {
        "key": "B",
        "text": "$100,000.00"
      },
      {
        "key": "C",
        "text": "100K"
      },
      {
        "key": "D",
        "text": "100 thousand"
      },
      {
        "key": "E",
        "text": "100M"
      },
      {
        "key": "F",
        "text": "$100,102.20"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C",
      "F"
    ],
    "explanation": "The code compiles and runs without issue. When a CompactNumberFormat instance \nis requested without a style, it uses the SHORT style by default. This results in both of the first \ntwo statements printing 100K, making option C correct. If the LONG style were used, then \n100 thousand would be printed. Option F is also correct, as the full value is printed with a \ncurrency formatter.\n"
  },
  {
    "id": "oca-240",
    "question": "What is the output of the following code?\n    LocalDate date = LocalDate.parse(\"2022- 04- 30\", \n       DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    System.out.println(date.getYear() + \" \" \n       + date.getMonth() + \" \"+ date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2022 APRIL 2"
      },
      {
        "key": "B",
        "text": "2022 APRIL 30"
      },
      {
        "key": "C",
        "text": "2022 MAY 2"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "A LocalDate does not have a time element. Therefore, a date/time formatter is not \nappropriate. The code compiles but throws an exception at runtime, making option E correct. \nIf ISO_LOCAL_DATE were used, the code would print 2022 APRIL 30.\n"
  },
  {
    "id": "oca-241",
    "question": "What does the following method print?\n    11: public void tryAgain(String s) {\n    12:    try (FileReader r = null, p = new FileReader(\"\")) {\n    13:       System.out.print(\"X\");\n    14:       throw new IllegalArgumentException();\n    15:    } catch (Exception s) {\n    16:       System.out.print(\"A\");\n    17:       throw new FileNotFoundException();\n    18:    } finally {\n    19:       System.out.print(\"O\");\n    20:    }\n    21: }",
    "choices": [
      {
        "key": "A",
        "text": "XAO"
      },
      {
        "key": "B",
        "text": "XOA"
      },
      {
        "key": "C",
        "text": "One line of this method contains a compiler error."
      },
      {
        "key": "D",
        "text": "Two lines of this method contain compiler errors."
      },
      {
        "key": "E",
        "text": "Three or more lines of this method contain compiler errors."
      },
      {
        "key": "F",
        "text": "The code compiles, but a NullPointerException is thrown at runtime."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The first compiler error is on line 12 because each resource in a try-with-resources state\u0002ment must have its own data type and be separated by a semicolon (;). Line 15 does not \ncompile because the variable s is already declared in the method. Line 17 also does not com\u0002pile. The FileNotFoundException, which inherits from IOException and Exception, \nis a checked exception, so it must be handled in a try/catch block or declared by the \nmethod. Because these three lines of code do not compile, option E is the correct answer. \n"
  },
  {
    "id": "oca-242",
    "question": "Assume that all of the files mentioned in the answer choices exist and define the same keys. \nWhich one will be used to find the key in line 8?\n    6: Locale.setDefault(new Locale(\"en\", \"US\"));\n    7: var b = ResourceBundle.getBundle(\"Dolphins\");\n    8: System.out.println(b.getString(\"name\"));",
    "choices": [
      {
        "key": "A",
        "text": "Dolphins.properties"
      },
      {
        "key": "B",
        "text": "Dolphins_US.properties"
      },
      {
        "key": "C",
        "text": "Dolphins_en.properties"
      },
      {
        "key": "D",
        "text": "Whales.properties"
      },
      {
        "key": "E",
        "text": "Whales_en_US.properties"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Java will first look for the most specific matches it can find, starting with \nDolphins_en_US.properties. Since that is not an answer choice, it drops the country \nand looks for Dolphins_en.properties, making option C correct. Option B is incorrect \nbecause a country without a language is not a valid locale.\n"
  },
  {
    "id": "oca-243",
    "question": "For what value of pattern will the following print <005.21> <008.49> <1,234.0>?\n    String pattern = \"                 \";\n    var message = DoubleStream.of(5.21, 8.49, 1234)\n       .mapToObj(v - > new DecimalFormat(pattern).format(v))\n       .collect(Collectors.joining(\"> <\"));\n    System.out.println(\"<\"+message+\">\");",
    "choices": [
      {
        "key": "A",
        "text": "##.#"
      },
      {
        "key": "B",
        "text": "0,000.0#"
      },
      {
        "key": "C",
        "text": "#,###.0"
      },
      {
        "key": "D",
        "text": "#,###,000.0#"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "When working with a custom number formatter, the 0 symbol displays the digit as 0, even \nif it’s not present, while the # symbol omits the digit from the start or end of the String if \nit is not present. Based on the requested output, a String that displays at least three digits \nbefore the decimal (including a comma) and at least one after the decimal is required. It \nshould display a second digit after the decimal if one is available. For this reason, option D is \nthe correct answer.\n"
  },
  {
    "id": "oca-244",
    "question": "Which scenario is the best use of an exception?",
    "choices": [
      {
        "key": "A",
        "text": "An element is not found when searching a list."
      },
      {
        "key": "B",
        "text": "An unexpected parameter is passed into a method."
      },
      {
        "key": "C",
        "text": "The computer caught fire."
      },
      {
        "key": "D",
        "text": "You want to loop through a list."
      },
      {
        "key": "E",
        "text": "You don’t know how to code a method."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "An IllegalArgumentException is used when an unexpected parameter is passed into \na method, making option B correct. Option A is incorrect because returning null or -1 is a \ncommon return value for searching for data. Option D is incorrect because a for loop is typ\u0002ically used for this scenario. Option E is incorrect because you should find out how to code \nthe method and not leave it for the unsuspecting programmer who calls your method. Option \nC is incorrect because you should run!\n"
  },
  {
    "id": "oca-245",
    "question": "Which of the following exceptions must be handled or declared in the method in which they \nare thrown? (Choose all that apply.)\n    class Apple extends RuntimeException {}\n    class Orange extends Exception {}\n    class Banana extends Error {}\n    class Pear extends Apple {}\n    class Tomato extends Orange {}\n    class Peach extends Throwable {}",
    "choices": [
      {
        "key": "A",
        "text": "Apple"
      },
      {
        "key": "B",
        "text": "Orange"
      },
      {
        "key": "C",
        "text": "Banana"
      },
      {
        "key": "D",
        "text": "Pear"
      },
      {
        "key": "E",
        "text": "Tomato"
      },
      {
        "key": "F",
        "text": "Peach"
      }
    ],
    "answer": [
      "B",
      "E",
      "F"
    ],
    "explanation": "An exception that must be handled or declared is a checked exception. A checked \nexception inherits Exception but not RuntimeException. The entire hierarchy counts, \nso options B and E are both correct. Option F is also correct, as a class that inherits \nThrowable but not RuntimeException or Error is also checked.\n"
  },
  {
    "id": "oca-246",
    "question": "Which of the following changes, when made independently, would make this code compile? \n(Choose all that apply.)\n    1:  import java.io.*; \n    2:  public class StuckTurkeyCage implements AutoCloseable {\n    3:     public void close() throws IOException {\n    4:        throw new FileNotFoundException(\"Cage not closed\");\n    5:     }\n    6:     public static void main(String[] args) {\n    7:        try (StuckTurkeyCage t = new StuckTurkeyCage()) {\n    8:           System.out.println(\"put turkeys in\");\n    9:        }\n    10:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Remove throws IOException from the declaration on line 3."
      },
      {
        "key": "B",
        "text": "Add throws Exception to the declaration on line 6."
      },
      {
        "key": "C",
        "text": "Change line 9 to } catch (Exception e) {}."
      },
      {
        "key": "D",
        "text": "Change line 9 to } finally {}."
      },
      {
        "key": "E",
        "text": "The code compiles as is."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "The code does not compile as is because the exception declared by the close()\nmethod must be handled or declared. Option A is incorrect because removing the exception \nfrom the declaration causes a compilation error on line 4, as FileNotFoundException\nis a checked exception that must be handled or declared. Option B is correct because the \nunhandled exception within the main() method becomes declared. Option C is also correct \nbecause the exception becomes handled. Option D is incorrect because the exception remains \nunhandled.\n"
  },
  {
    "id": "oca-247",
    "question": "Which of the following are true statements about exception handling in Java? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A traditional try statement without a catch block requires a finally block."
      },
      {
        "key": "B",
        "text": "A traditional try statement without a finally block requires a catch block."
      },
      {
        "key": "C",
        "text": "A traditional try statement with only one statement can omit the {}."
      },
      {
        "key": "D",
        "text": "A try- with- resources statement without a catch block requires a finally block."
      },
      {
        "key": "E",
        "text": "A try- with- resources statement without a finally block requires a catch block."
      },
      {
        "key": "F",
        "text": "A try- with- resources statement with only one statement can omit the {}."
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "A try-with-resources statement does not require a catch or finally block. A tra\u0002ditional try statement requires at least one of the two. Neither statement can be written \nwithout a body encased in braces, {}. For these reasons, options A and B are correct.\n"
  },
  {
    "id": "oca-248",
    "question": "Assuming -g:vars is used when the code is compiled to include debug information, what is \nthe output of the following code snippet?\n    var huey = (String)null;\n    Integer dewey = null;\n    Object louie = null;\n    if(louie == huey.substring(dewey.intValue())) {\n       System.out.println(\"Quack!\");\n    }",
    "choices": [
      {
        "key": "A",
        "text": "A NullPointerException that does not include any variable names in the stack \ntrace"
      },
      {
        "key": "B",
        "text": "A NullPointerException naming huey in the stack trace"
      },
      {
        "key": "C",
        "text": "A NullPointerException naming dewey in the stack trace"
      },
      {
        "key": "D",
        "text": "A NullPointerException naming louie in the stack trace"
      },
      {
        "key": "E",
        "text": "A NullPointerException naming huey and louie in the stack trace"
      },
      {
        "key": "F",
        "text": "A NullPointerException naming huey and dewey in the stack trace"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Starting with Java 15, NullPointerException stack traces include the \nname of the variable that is null by default, making option A incorrect. The first \nNullPointerException encountered at runtime is when dewey.intValue()\nis called, making option C correct. Options E and F are incorrect as only one \nNullPointerException exception can be thrown at a time.\n"
  },
  {
    "id": "oca-249",
    "question": "Which of the following, when inserted independently in the blank, use locale parameters that \nare properly formatted? (Choose all that apply.)\n    import java.util.Locale;\n    public class ReadMap implements AutoCloseable {\n       private Locale locale;\n       private boolean closed = false;\n       @Override public void close() {\n          System.out.println(\"Folding map\");\n          locale = null;\n          closed = true;\n       }\n       public void open() {\n          this.locale =                  ;\n       }\n       public void use() {\n          // Implementation omitted\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "new Locale(\"xM\")"
      },
      {
        "key": "B",
        "text": "new Locale(\"MQ\", \"ks\")"
      },
      {
        "key": "C",
        "text": "new Locale(\"qw\")"
      },
      {
        "key": "D",
        "text": "new Locale(\"wp\", \"VW\")"
      },
      {
        "key": "E",
        "text": "Locale.create(\"zp\")"
      },
      {
        "key": "F",
        "text": "new Locale.Builder().setLanguage(\"yw\").setRegion(\"PM\")"
      },
      {
        "key": "G",
        "text": "The code does not compile regardless of what is placed in the blank."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "The code compiles with the appropriate input, so option G is incorrect. A locale con\u0002sists of a required lowercase language code and optional uppercase country code. In the \nLocale() constructor, the language code is provided first. For these reasons, options C \nand D are correct. Option E is incorrect because a Locale is created using a constructor \nor Locale.Builder class. Option F is really close but is missing build() at the end. \nWithout that, option F does not compile.\n"
  },
  {
    "id": "oca-250",
    "question": "Which of the following can be inserted into the blank to allow the code to compile and run \nwithout throwing an exception? (Choose all that apply.)\n    var f = DateTimeFormatter.ofPattern(\"hh o'clock\");\n    System.out.println(f.format(                 .now()));",
    "choices": [
      {
        "key": "A",
        "text": "ZonedDateTime"
      },
      {
        "key": "B",
        "text": "LocalDate"
      },
      {
        "key": "C",
        "text": "LocalDateTime"
      },
      {
        "key": "D",
        "text": "LocalTime"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code compiles, but the first line produces a runtime exception regardless of what is \ninserted into the blank, making option F correct. When creating a custom formatter, any \nnonsymbol code must be properly escaped using pairs of single quotes ('). In this case, it fails \nbecause o is not a symbol. Even if you didn’t know o wasn’t a symbol, the code contains an \nunmatched single quote. If the properly escaped value of \"hh' o''clock'\" were used, \nthen the correct answers would be ZonedDateTime, LocalDateTime, and LocalTime. \nOption B would not be correct because LocalDate values do not have an hour part.\n"
  },
  {
    "id": "oca-251",
    "question": "Which of the following statements about resource bundles are correct? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "All keys must be in the same resource bundle to be used."
      },
      {
        "key": "B",
        "text": "A resource bundle is loaded by calling the new ResourceBundle() constructor."
      },
      {
        "key": "C",
        "text": "Resource bundle values are always read using the Properties class."
      },
      {
        "key": "D",
        "text": "Changing the default locale lasts for only a single run of the program."
      },
      {
        "key": "E",
        "text": "If a resource bundle for a specific locale is requested, then the resource bundle for the \ndefault locale will not be used."
      },
      {
        "key": "F",
        "text": "It is possible to use a resource bundle for a locale without specifying a default locale."
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "Option A is incorrect because Java will look at parent bundles if a key is not found in \na specified resource bundle. Option B is incorrect because resource bundles are loaded from \nstatic factory methods. Option C is incorrect, as resource bundle values are read from the \nResourceBundle object directly. Option D is correct because the locale is changed only \nin memory. Option E is incorrect, as the resource bundle for the default locale may be used \nif there is no resource bundle for the specified locale (or its locale without a country code). \nFinally, option F is correct. The JVM will set a default locale automatically.\n"
  },
  {
    "id": "oca-252",
    "question": "What is the output of the following code?\n    import java.io.*;\n    public class FamilyCar {\n       static class Door implements AutoCloseable {\n          public void close() {\n             System.out.print(\"D\");\n       } }\n       static class Window implements Closeable {\n          public void close() {\n             System.out.print(\"W\");\n             throw new RuntimeException();\n       } }\n       public static void main(String[] args) {\n          var d = new Door();\n          try (d; var w = new Window()) {\n             System.out.print(\"T\");\n          } catch (Exception e) {\n             System.out.print(\"E\");\n          } finally {\n             System.out.print(\"F\");\n          } } }",
    "choices": [
      {
        "key": "A",
        "text": "TWF"
      },
      {
        "key": "B",
        "text": "TWDF"
      },
      {
        "key": "C",
        "text": "TWDEF"
      },
      {
        "key": "D",
        "text": "TWF followed by an exception"
      },
      {
        "key": "E",
        "text": "TWDF followed by an exception"
      },
      {
        "key": "F",
        "text": "TWEF followed by an exception"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "After both resources are declared and created in the try-with-resources statement, T is \nprinted as part of the body. Then the try-with-resources completes and closes the resources \nin the reverse of the order in which they were declared. After W is printed, an exception is \nthrown. However, the remaining resource still needs to be closed, so D is printed. Once all \nthe resources are closed, the exception is thrown and swallowed in the catch block, causing \nE to be printed. Last, the finally block is run, printing F. Therefore, the answer is TWDEF\nand option C is correct.\n"
  },
  {
    "id": "oca-253",
    "question": "Suppose that we have the following three properties files and code. Which bundles are used \non lines 8 and 9, respectively?\n    Dolphins.properties\n    name=The Dolphin\n    age=0\n \n    Dolphins_en.properties\n    name=Dolly\n    age=4\n \n    Dolphins_fr.properties\n    name=Dolly\n \n    5: var fr = new Locale(\"fr\");\n    6: Locale.setDefault(new Locale(\"en\", \"US\"));\n    7: var b = ResourceBundle.getBundle(\"Dolphins\", fr);\n    8: b.getString(\"name\");\n    9: b.getString(\"age\");",
    "choices": [
      {
        "key": "A",
        "text": "Dolphins.properties and Dolphins.properties"
      },
      {
        "key": "B",
        "text": "Dolphins.properties and Dolphins_en.properties"
      },
      {
        "key": "C",
        "text": "Dolphins_en.properties and Dolphins_en.properties"
      },
      {
        "key": "D",
        "text": "Dolphins_fr.properties and Dolphins.properties"
      },
      {
        "key": "E",
        "text": "Dolphins_fr.properties and Dolphins_en.properties"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Java will use Dolphins_fr.properties as the matching resource bundle on line 7 \nbecause it is an exact match on the language of the requested locale. Line 8 finds a match\u0002ing key in this file. Line 9 does not find a match in that file; therefore, it has to look higher \nup in the hierarchy. Once a bundle is chosen, only resources in that hierarchy are allowed. It \ncannot use the default locale anymore, but it can use the default resource bundle specified by \nDolphins.properties. For these reasons, option D is correct.\n"
  },
  {
    "id": "oca-254",
    "question": "What is printed by the following program?\n    1:  public class DriveBus {\n    2:     public void go() {\n    3:        System.out.print(\"A\");\n    4:        try {\n    5:           stop();\n    6:        } catch (ArithmeticException e) {\n    7:           System.out.print(\"B\");\n    8:        } finally {\n    9:           System.out.print(\"C\");\n    10:       }\n    11:       System.out.print(\"D\");\n    12:    }\n    13:    public void stop() {\n    14:       System.out.print(\"E\");\n    15:       Object x = null;\n    16:       x.toString();\n    17:       System.out.print(\"F\");\n    18:    }\n    19:    public static void main(String n[]) {\n    20:       new DriveBus().go();\n    21:    } }",
    "choices": [
      {
        "key": "A",
        "text": "AE"
      },
      {
        "key": "B",
        "text": "AEBCD"
      },
      {
        "key": "C",
        "text": "AEC"
      },
      {
        "key": "D",
        "text": "AECD"
      },
      {
        "key": "E",
        "text": "AE followed by a stack trace"
      },
      {
        "key": "F",
        "text": "AEBCD followed by a stack trace"
      },
      {
        "key": "G",
        "text": "AEC followed by a stack trace"
      },
      {
        "key": "H",
        "text": "A stack trace with no other output"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The main() method invokes go(), and A is printed on line 3. The stop() method \nis invoked, and E is printed on line 14. Line 16 throws a NullPointerException, so \nstop() immediately ends, and line 17 doesn’t execute. The exception isn’t caught in go(), \n\nso the go() method ends as well, but not before its finally block executes and C is \nprinted on line 9. Because main() doesn’t catch the exception, the stack trace displays, and \nno further output occurs. For these reasons, AEC is printed followed by a stack trace for a \nNullPointerException, making option G correct.\n"
  },
  {
    "id": "oca-255",
    "question": "Which changes, when made independently, allow the following program to compile? (Choose \nall that apply.)\n    1: public class AhChoo {\n    2:    static class SneezeException extends Exception {}\n    3:    static class SniffleException extends SneezeException {}\n    4:    public static void main(String[] args) {\n    5:       try {\n    6:          throw new SneezeException();\n    7:       } catch (SneezeException | SniffleException e) {\n    8:       } finally {}\n    9:    } }",
    "choices": [
      {
        "key": "A",
        "text": "Add throws SneezeException to the declaration on line 4."
      },
      {
        "key": "B",
        "text": "Add throws Throwable to the declaration on line 4."
      },
      {
        "key": "C",
        "text": "Change line 7 to } catch (SneezeException e) {."
      },
      {
        "key": "D",
        "text": "Change line 7 to } catch (SniffleException e) {."
      },
      {
        "key": "E",
        "text": "Remove line 7."
      },
      {
        "key": "F",
        "text": "The code compiles correctly as is."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code does not compile because the multi-catch block on line 7 cannot catch both \na superclass and a related subclass. Options A and B do not address this problem, so they \nare incorrect. Since the try body throws SneezeException, it can be caught in a catch\nblock, making option C correct. Option D allows the catch block to compile but causes a \ncompiler error on line 6. Both of the custom exceptions are checked and must be handled or \ndeclared in the main() method. A SneezeException is not a SniffleException, so \nthe exception is not handled. Likewise, option E leads to an unhandled exception compiler \nerror on line 6.\n"
  },
  {
    "id": "oca-256",
    "question": "What is the output of the following code?\n    try {\n       LocalDateTime book = LocalDateTime.of(2022, 4, 5, 12, 30, 20);\n       System.out.print(book.format(DateTimeFormatter.ofPattern(\"m\")));\n       System.out.print(book.format(DateTimeFormatter.ofPattern(\"z\")));\n       System.out.print(DateTimeFormatter.ofPattern(\"y\").format(book));\n    } catch (Throwable e) {}",
    "choices": [
      {
        "key": "A",
        "text": "4"
      },
      {
        "key": "B",
        "text": "30"
      },
      {
        "key": "C",
        "text": "402"
      },
      {
        "key": "D",
        "text": "3002"
      },
      {
        "key": "E",
        "text": "3002022"
      },
      {
        "key": "F",
        "text": "402022"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "For this question, the date used is April 5, 2022 at 12:30:20pm. The code compiles, \nand either form of the formatter is correct: dateTime.format(formatter) or \nformatter.format(dateTime). The custom format m returns the minute, so 30 is \noutput first. The next line throws an exception as z relates to time zone, and date/time does \nnot have a zone component. This exception is then swallowed by the try/catch block. Since \nthis is the only value printed, option B is correct. If the code had not thrown an exception, \nthe last line would have printed 2022.\n"
  },
  {
    "id": "oca-257",
    "question": "Fill in the blank: A class that implements _________________ may be in a try- with- resources \nstatement. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "AutoCloseable"
      },
      {
        "key": "B",
        "text": "Resource"
      },
      {
        "key": "C",
        "text": "Exception"
      },
      {
        "key": "D",
        "text": "AutomaticResource"
      },
      {
        "key": "E",
        "text": "Closeable"
      },
      {
        "key": "F",
        "text": "RuntimeException"
      },
      {
        "key": "G",
        "text": "Serializable"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Resources must inherit AutoCloseable to be used in a try-with-resources block. \nSince Closeable, which is used for I/O classes, extends AutoCloseable, both may be \nused, making options A and E correct.\n"
  },
  {
    "id": "oca-258",
    "question": "What is the output of the following program?\n    public class SnowStorm {\n       static class WalkToSchool implements AutoCloseable {\n          public void close() {\n             throw new RuntimeException(\"flurry\");\n          } }\n       public static void main(String[] args) {\n          WalkToSchool walk1 = new WalkToSchool();\n          try (walk1; WalkToSchool walk2 = new WalkToSchool()) {\n             throw new RuntimeException(\"blizzard\");\n          } catch(Exception e) {\n             System.out.println(e.getMessage()\n                + \" \" + e.getSuppressed().length);\n          }\n          walk1 = null;\n       } }",
    "choices": [
      {
        "key": "A",
        "text": "blizzard 0"
      },
      {
        "key": "B",
        "text": "blizzard 1"
      },
      {
        "key": "C",
        "text": "blizzard 2"
      },
      {
        "key": "D",
        "text": "flurry 0"
      },
      {
        "key": "E",
        "text": "flurry 1"
      },
      {
        "key": "F",
        "text": "flurry 2"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code does not compile because the resource walk1 is not final or effectively final \nand cannot be used in the declaration of a try-with-resources statement. For this reason, \noption G is correct. If the line that set walk1 to null were removed, then the code would \ncompile and print blizzard 2 at runtime, with the exception inside the try block being \nthe primary exception since it is thrown first. Then two suppressed exceptions would be \nadded to it when trying to close the AutoCloseable resources.\n"
  },
  {
    "id": "oca-259",
    "question": "Assuming U.S. currency is in dollars ($) and German currency is in euros (€), what is the \noutput of the following program?\n    import java.text.NumberFormat;\n    import java.util.Locale;\n    import java.util.Locale.Category;\n    public record Wallet(double money) {\n       private String openWallet() {\n          Locale.setDefault(Category.DISPLAY,\n             new Locale.Builder().setRegion(\"us\").build());\n          Locale.setDefault(Category.FORMAT,\n             new Locale.Builder().setLanguage(\"en\").build());\n          return NumberFormat.getCurrencyInstance(Locale.GERMANY)\n             .format(money);\n       }\n       public void printBalance() {\n          System.out.println(openWallet());\n       }   \n       public static void main(String... unused) {\n          new Wallet(2.4).printBalance();\n       } }",
    "choices": [
      {
        "key": "A",
        "text": "2,40 €"
      },
      {
        "key": "B",
        "text": "$2.40"
      },
      {
        "key": "C",
        "text": "2.4"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and prints the value for Germany, 2,40 €, making option A the \ncorrect answer. Note that the default locale category is ignored since an explicit currency \nlocale is selected.\n"
  },
  {
    "id": "oca-260",
    "question": "Which lines can fill in the blank to make the following code compile? (Choose all that apply.)\n    void rollOut() throws ClassCastException {}\n \n    public void transform(String c) {\n       try {\n          rollOut();\n       } catch (IllegalArgumentException | ) {\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "IOException a"
      },
      {
        "key": "B",
        "text": "Error b"
      },
      {
        "key": "C",
        "text": "NullPointerException c"
      },
      {
        "key": "D",
        "text": "RuntimeException d"
      },
      {
        "key": "E",
        "text": "NumberFormatException e"
      },
      {
        "key": "F",
        "text": "ClassCastException f"
      },
      {
        "key": "G",
        "text": "None of the above. The code contains a compiler error regardless of what is inserted \ninto the blank."
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The try block is not capable of throwing an IOException, making the catch block \nunreachable code and option A incorrect. Options B and F are correct, as both are unchecked \nexceptions that do not extend or inherit from IllegalArgumentException. Remember, \nit is not a good idea to catch Error in practice, although because it is possible, it may come \nup on the exam. Option C is incorrect because the variable c is declared already in the \nmethod declaration. Option D is incorrect because the IllegalArgumentException\ninherits from RuntimeException, making the first declaration unnecessary. \nSimilarly, option E is incorrect because NumberFormatException inherits from \nIllegalArgumentException, making the second declaration unnecessary. Since options \nB and F are correct, option G is incorrect.\n"
  },
  {
    "id": "oca-261",
    "question": "Which statement is true of the following module?\n    |- - - zoo\n       |- -  staff\n          |- -  Vet.java",
    "choices": [
      {
        "key": "A",
        "text": "The directory structure shown is a valid module."
      },
      {
        "key": "B",
        "text": "The directory structure would be a valid module if module.java were added directly \nunderneath zoo/staff."
      },
      {
        "key": "C",
        "text": "The directory structure would be a valid module if module.java were added directly \nunderneath zoo."
      },
      {
        "key": "D",
        "text": "The directory structure would be a valid module if module- info.java were added \ndirectly underneath zoo/staff."
      },
      {
        "key": "E",
        "text": "The directory structure would be a valid module if module- info.java were added \ndirectly underneath zoo."
      },
      {
        "key": "F",
        "text": "None of these changes would make this directory structure a valid module."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Modules are required to have a module-info.java file at the root directory of the \nmodule. Option E matches this requirement.\n"
  },
  {
    "id": "oca-262",
    "question": "Suppose module puppy depends on module dog and module dog depends on module \nanimal. Fill in the blank so that code in module dog can access the animal.behavior \npackage in module animal.\n    module animal {\n                animal.behavior;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "export"
      },
      {
        "key": "B",
        "text": "exports"
      },
      {
        "key": "C",
        "text": "require"
      },
      {
        "key": "D",
        "text": "requires"
      },
      {
        "key": "E",
        "text": "require transitive"
      },
      {
        "key": "F",
        "text": "requires transitive"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Options A, C, and E are incorrect because they refer to directives that don’t exist. The \nexports directive is used when allowing a package to be called by code outside of the \nmodule, making option B the correct answer. Notice that options D and F are incorrect \nbecause of requires.\n"
  },
  {
    "id": "oca-263",
    "question": "Fill in the blanks so this command to run the program is correct:\n    java\n            zoo.animal.talks/zoo/animal/talks/Peacocks\n            modules",
    "choices": [
      {
        "key": "A",
        "text": "- d and - m"
      },
      {
        "key": "B",
        "text": "- d and –p"
      },
      {
        "key": "C",
        "text": "- m and - d"
      },
      {
        "key": "D",
        "text": "- m and - p"
      },
      {
        "key": "E",
        "text": "- p and - d"
      },
      {
        "key": "F",
        "text": "- p and - m"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The -m or --module option is used to specify the module and class name. The -p or \n--module-path option is used to specify the location of the modules. Option D would be \ncorrect if the rest of the command were correct. However, running a program requires spec\u0002ifying the package name with periods (.) instead of slashes. Since the command is incorrect, \noption G is correct.\n"
  },
  {
    "id": "oca-264",
    "question": "Which of the following pairs make up a service?",
    "choices": [
      {
        "key": "A",
        "text": "Consumer and service locator"
      },
      {
        "key": "B",
        "text": "Consumer and service provider interface"
      },
      {
        "key": "C",
        "text": "Service locator and service provider"
      },
      {
        "key": "D",
        "text": "Service locator and service provider interface"
      },
      {
        "key": "E",
        "text": "Service provider and service provider interface"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "A service consists of the service provider interface and logic to look up implementations \nusing a service locator. This makes option D correct. Make sure you know that the service \nprovider itself is the implementation, which is not considered part of the service.\n"
  },
  {
    "id": "oca-265",
    "question": "A(n) _______________ module is on the classpath while a(n) ____________ module is on the \nmodule path. (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "automatic, named"
      },
      {
        "key": "B",
        "text": "automatic, unnamed"
      },
      {
        "key": "C",
        "text": "named, automatic"
      },
      {
        "key": "D",
        "text": "named, unnamed"
      },
      {
        "key": "E",
        "text": "unnamed, automatic"
      },
      {
        "key": "F",
        "text": "unnamed, named"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E",
      "F"
    ],
    "explanation": "Automatic modules are on the module path but do not have a module-info.java\nfile. Named modules are on the module path and do have a module-info. Unnamed mod\u0002ules are on the classpath. Therefore, options E and F are correct.\n"
  },
  {
    "id": "oca-266",
    "question": "Which of the following statements are true in a module- info.java file? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The opens directive allows the use of reflection."
      },
      {
        "key": "B",
        "text": "The opens directive declares that an API is called."
      },
      {
        "key": "C",
        "text": "The use directive allows the use of reflection."
      },
      {
        "key": "D",
        "text": "The use directive declares that an API is called."
      },
      {
        "key": "E",
        "text": "The uses directive allows the use of reflection."
      },
      {
        "key": "F",
        "text": "The uses directive declares that an API is called."
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Options C and D are incorrect because there is no use directive. Options A and F are \ncorrect because opens is for reflection and uses declares that an API consumes a service. \n"
  },
  {
    "id": "oca-267",
    "question": "An automatic module name is generated if one is not supplied. Which of the following JAR \nfilenames and generated automatic module name pairs are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "emily- 1.0.0.jar and emily"
      },
      {
        "key": "B",
        "text": "emily- 1.0.0- SNAPSHOT.jar and emily"
      },
      {
        "key": "C",
        "text": "emily_the_cat- 1.0.0.jar and emily_the_cat"
      },
      {
        "key": "D",
        "text": "emily_the_cat- 1.0.0.jar and emily- the- cat"
      },
      {
        "key": "E",
        "text": "emily.$.jar and emily"
      },
      {
        "key": "F",
        "text": "emily.$.jar and emily."
      },
      {
        "key": "G",
        "text": "emily.$.jar and emily.."
      }
    ],
    "answer": [
      "A",
      "B",
      "E"
    ],
    "explanation": "Any version information at the end of the JAR filename is removed, making options \nA and B correct. Underscores (_) are turned into dots (.), making options C and D incorrect. \nOther special characters like a dollar sign ($) are also turned into dots. However, adjacent \ndots are merged, and leading/trailing dots are removed. Therefore, option E is correct.\n"
  },
  {
    "id": "oca-268",
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Modules with cyclic dependencies will not compile."
      },
      {
        "key": "B",
        "text": "Packages with a cyclic dependency will not compile."
      },
      {
        "key": "C",
        "text": "A cyclic dependency always involves exactly two modules."
      },
      {
        "key": "D",
        "text": "A cyclic dependency always involves at least two requires statements."
      },
      {
        "key": "E",
        "text": "An unnamed module can be involved in a cyclic dependency with an automatic module."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "A cyclic dependency is when a module graph forms a circle. Option A is correct \nbecause the Java Platform Module System does not allow cyclic dependencies between mod\u0002ules. No such restriction exists for packages, making option B incorrect. A cyclic dependency \ncan involve two or more modules that require each other, making option D correct, while \noption C is incorrect. Finally, option E is incorrect because unnamed modules cannot be \nreferenced from an automatic module. \n"
  },
  {
    "id": "oca-269",
    "question": "Suppose you are creating a service provider that contains the following class. Which line of \ncode needs to be in your module- info.java?\n    package dragon;\n    import magic.*;\n     public class Dragon implements Magic {\n       public String getPower() {\n         return \"breathe fire\";\n       }\n    }",
    "choices": [
      {
        "key": "A",
        "text": "provides dragon.Dragon by magic.Magic;"
      },
      {
        "key": "B",
        "text": "provides dragon.Dragon using magic.Magic;"
      },
      {
        "key": "C",
        "text": "provides dragon.Dragon with magic.Magic;"
      },
      {
        "key": "D",
        "text": "provides magic.Magic by dragon.Dragon;"
      },
      {
        "key": "E",
        "text": "provides magic.Magic using dragon.Dragon;"
      },
      {
        "key": "F",
        "text": "provides magic.Magic with dragon.Dragon;"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The provides directive takes the interface name first and the implementing class \nname second and also uses with. Only option F meets these two criteria, making it the \ncorrect answer.\n"
  },
  {
    "id": "oca-270",
    "question": "What is true of a module containing a file named module- info.java with the following \ncontents? (Choose all that apply.)\n    module com.food.supplier {}",
    "choices": [
      {
        "key": "A",
        "text": "All packages inside the module are automatically exported."
      },
      {
        "key": "B",
        "text": "No packages inside the module are automatically exported."
      },
      {
        "key": "C",
        "text": "A main method inside the module can be run."
      },
      {
        "key": "D",
        "text": "A main method inside the module cannot be run since the class is not exposed."
      },
      {
        "key": "E",
        "text": "The module- info.java file contains a compiler error."
      },
      {
        "key": "F",
        "text": "The module- info.java filename is incorrect."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "Packages inside a module are not exported by default, making option B correct and \noption A incorrect. Exporting is necessary for other code to use the packages; it is not \nnecessary to call the main() method at the command line, making option C correct and \noption D incorrect. The module-info.java file has the correct name and compiles, mak\u0002ing options E and F incorrect.\n"
  },
  {
    "id": "oca-271",
    "question": "Suppose module puppy depends on module dog and module dog depends on module \nanimal. Which lines allow module puppy to access the animal.behavior package in \nmodule animal? (Choose all that apply.)\n    module animal {\n       exports animal.behavior;\n    }\n    module dog {\n               animal;  // line S\n    }\n    module puppy {\n               dog;     // line T\n    }",
    "choices": [
      {
        "key": "A",
        "text": "require on line S"
      },
      {
        "key": "B",
        "text": "require on line T"
      },
      {
        "key": "C",
        "text": "requires on line S"
      },
      {
        "key": "D",
        "text": "requires on line T"
      },
      {
        "key": "E",
        "text": "require transitive on line S"
      },
      {
        "key": "F",
        "text": "require transitive on line T"
      },
      {
        "key": "G",
        "text": "requires transitive on line S"
      },
      {
        "key": "H",
        "text": "requires transitive on line T"
      }
    ],
    "answer": [
      "D",
      "G",
      "H"
    ],
    "explanation": "Options A, B, E, and F are incorrect because they refer to directives that don’t exist. \nThe requires transitive directive is used when specifying a module to be used by the \nrequesting module and any other modules that use the requesting module. Therefore, dog\nneeds to specify the transitive relationship, and option G is correct. The module puppy just \nneeds requires dog, and it gets the transitive dependencies, making option D correct. \nHowever, requires transitive does everything requires does and more, which \nmakes option H the final answer.\n"
  },
  {
    "id": "oca-272",
    "question": "Which of the following modules are provided by the JDK? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "java.base"
      },
      {
        "key": "B",
        "text": "java.desktop"
      },
      {
        "key": "C",
        "text": "java.logging"
      },
      {
        "key": "D",
        "text": "java.util"
      },
      {
        "key": "E",
        "text": "jdk.base"
      },
      {
        "key": "F",
        "text": "jdk.compiler"
      },
      {
        "key": "G",
        "text": "jdk.xerces"
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "F"
    ],
    "explanation": "Option D is incorrect because it is a package name rather than a module name. \nOption E is incorrect because java.base is the module name, not jdk.base. Option G is \nwrong because we made it up. Options A, B, C, and F are correct.\n"
  },
  {
    "id": "oca-273",
    "question": "Which of the following compiles and is equivalent to this loop?\n    List<Unicorn> all  = new ArrayList<>();\n    for (Unicorn current : ServiceLoader.load(Unicorn.class))\n       all.add(current);",
    "choices": [
      {
        "key": "A",
        "text": "    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .getStream()\n    .collect(Collectors.toList());"
      },
      {
        "key": "B",
        "text": "    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .stream()\n    .collect(Collectors.toList());"
      },
      {
        "key": "C",
        "text": "    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .getStream()\n    .map(Provider::get)\n    .collect(Collectors.toList());"
      },
      {
        "key": "D",
        "text": "    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    List<Unicorn> all = ServiceLoader.load(Unicorn.class)\n    .stream()\n    .map(Provider::get)\n    .collect(Collectors.toList());"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "There is no getStream() method on a ServiceLoader, making options A and C \nincorrect. Option B does not compile because the stream() method returns a list of \nProvider interfaces and needs to be converted to the Unicorn interface we are interested \nin. Therefore, option D is correct.\n"
  },
  {
    "id": "oca-274",
    "question": "Which of the following are legal commands to run a modular program where n is the module \nname and c is the fully qualified class name? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "java --module- path x - m n.c"
      },
      {
        "key": "B",
        "text": "java - - module- path x - p n.c"
      },
      {
        "key": "C",
        "text": "java - - module- path x- x - m n/c"
      },
      {
        "key": "D",
        "text": "java - - module- path x - p n/c"
      },
      {
        "key": "E",
        "text": "java - - module- path x- x - m n- c"
      },
      {
        "key": "F",
        "text": "java - - module- path x - p n- c"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The -p option is a shorter form of --module-path. Since the same option cannot \nbe specified twice, options B, D, and F are incorrect. The --module-path option is an \nalternate form of -p. The module name and class name are separated with a slash, making \noption C the answer. Note that x-x is legal because the module path is a folder name, so \ndashes are allowed.\n"
  },
  {
    "id": "oca-275",
    "question": "For a top- down migration, all modules other than named modules are _____________  \nmodules and are on the ____________.",
    "choices": [
      {
        "key": "A",
        "text": "automatic, classpath"
      },
      {
        "key": "B",
        "text": "automatic, module path"
      },
      {
        "key": "C",
        "text": "unnamed, classpath"
      },
      {
        "key": "D",
        "text": "unnamed, module path"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "A top-down migration strategy first places all JARs on the module path. Then it migrates \nthe top-level module to be a named module, leaving the other modules as automatic modules. \nOption B is correct as it matches both of those characteristics.\n"
  },
  {
    "id": "oca-276",
    "question": "Suppose you have separate modules for a service provider interface, service provider, service \nlocator, and consumer. If you add a second service provider module, how many of these mod-\nules do you need to recompile?",
    "choices": [
      {
        "key": "A",
        "text": "Zero"
      },
      {
        "key": "B",
        "text": "One"
      },
      {
        "key": "C",
        "text": "Two"
      },
      {
        "key": "D",
        "text": "Three"
      },
      {
        "key": "E",
        "text": "Four"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Since this is a new module, you need to compile it. However, none of the existing modules \nneeds to be recompiled, making option A correct. The service locator will see the new service \nprovider simply by having that new service provider on the module path.\n"
  },
  {
    "id": "oca-277",
    "question": "Suppose we have a JAR file named cat- 1.2.3- RC1.jar, and  \nAutomatic- Module- Name in the MANIFEST.MF is set to dog. What should an unnamed \nmodule referencing this automatic module include in module- info.java?",
    "choices": [
      {
        "key": "A",
        "text": "requires cat;"
      },
      {
        "key": "B",
        "text": "requires cat.RC;"
      },
      {
        "key": "C",
        "text": "requires cat- RC;"
      },
      {
        "key": "D",
        "text": "requires dog;"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Trick question! An unnamed module doesn’t use a module-info.java file. Therefore, \noption E is correct. An unnamed module can access an automatic module. The unnamed \nmodule would simply treat the automatic module as a regular JAR without involving the \nmodule.info file.\n"
  },
  {
    "id": "oca-278",
    "question": "Which commands are used to create a smaller Java image and work with native code, \nrespectively?",
    "choices": [
      {
        "key": "A",
        "text": "jimage and jlink"
      },
      {
        "key": "B",
        "text": "jimage and jmod"
      },
      {
        "key": "C",
        "text": "jlink and jimage"
      },
      {
        "key": "D",
        "text": "jlink and jmod"
      },
      {
        "key": "E",
        "text": "jmod and jimage"
      },
      {
        "key": "F",
        "text": "jmod and jmod"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The jlink command creates a directory with a smaller Java runtime containing just \nwhat is needed. The JMOD format is for native code. Therefore, option D is correct.\n"
  },
  {
    "id": "oca-279",
    "question": "Which are true statements about the following module? (Choose all that apply.)\n    class dragon {\n       exports com.dragon.fire;\n       exports com.dragon.scales to castle;\n    }",
    "choices": [
      {
        "key": "A",
        "text": "All modules can reference the com.dragon.fire package."
      },
      {
        "key": "B",
        "text": "All modules can reference the com.dragon.scales package."
      },
      {
        "key": "C",
        "text": "Only the castle module can reference the com.dragon.fire package."
      },
      {
        "key": "D",
        "text": "Only the castle module can reference the com.dragon.scales package."
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "There is a trick here. A module definition uses the keyword module rather than class. \nSince the code does not compile, option E is correct. If the code did compile, options A and D \nwould be correct.\n"
  },
  {
    "id": "oca-280",
    "question": "Which would you expect to see when describing any module?",
    "choices": [
      {
        "key": "A",
        "text": "requires java.base mandated"
      },
      {
        "key": "B",
        "text": "requires java.core mandated"
      },
      {
        "key": "C",
        "text": "requires java.lang mandated"
      },
      {
        "key": "D",
        "text": "requires mandated java.base"
      },
      {
        "key": "E",
        "text": "requires mandated java.core"
      },
      {
        "key": "F",
        "text": "requires mandated java.lang"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "When running java with the -d option, all the required modules are listed. Addition\u0002ally, the java.base module is listed since it is included automatically. The line ends with \nmandated, making option A correct. The java.lang is a trick since it is a package that is \nimported by default in a class rather than a module.\n"
  },
  {
    "id": "oca-281",
    "question": "Suppose you have separate modules for a service provider interface, service provider, ser -\nvice locator, and consumer. Which module(s) need to specify a requires directive on the ser -\nvice provider?",
    "choices": [
      {
        "key": "A",
        "text": "Service locator"
      },
      {
        "key": "B",
        "text": "Service provider interface"
      },
      {
        "key": "C",
        "text": "Consumer"
      },
      {
        "key": "D",
        "text": "Consumer and service locator"
      },
      {
        "key": "E",
        "text": "Consumer and service provider"
      },
      {
        "key": "F",
        "text": "Service locator and service provider interface"
      },
      {
        "key": "G",
        "text": "Consumer, service locator, and service provider interface"
      },
      {
        "key": "H",
        "text": "None of the above"
      }
    ],
    "answer": [
      "H"
    ],
    "explanation": "This question is tricky. The service locator must have a uses directive, but that is on the \nservice provider interface. No modules need to specify requires on the service provider \nsince that is the implementation. Since none are correct, option H is the answer.\n"
  },
  {
    "id": "oca-282",
    "question": "Which are true statements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An automatic module exports all packages to named modules."
      },
      {
        "key": "B",
        "text": "An automatic module exports only the specified packages to named modules."
      },
      {
        "key": "C",
        "text": "An automatic module exports no packages to named modules."
      },
      {
        "key": "D",
        "text": "An unnamed module exports only the named packages to named modules."
      },
      {
        "key": "E",
        "text": "An unnamed module exports all packages to named modules."
      },
      {
        "key": "F",
        "text": "An unnamed module exports no packages to named modules."
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "An automatic module exports all packages, making option A correct. An unnamed \nmodule is not available to any modules on the module path. Therefore, it doesn’t export any \npackages, and option F is correct.\n"
  },
  {
    "id": "oca-283",
    "question": "Which is the first line to contain a compiler error?\n    1: module snake {\n    2:    exports com.snake.tail;\n    3:    exports com.snake.fangs to bird;\n    4:    requires skin;\n    5:    requires transitive skin;\n    6: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 1"
      },
      {
        "key": "B",
        "text": "Line 2"
      },
      {
        "key": "C",
        "text": "Line 3"
      },
      {
        "key": "D",
        "text": "Line 4"
      },
      {
        "key": "E",
        "text": "Line 5"
      },
      {
        "key": "F",
        "text": "The code does not contain any compiler errors."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The module name is valid, as are the exports statements. Lines 4 and 5 are tricky \nbecause each is valid independently. However, the same module name is not allowed to be \nused in two requires statements. The second one fails to compile on line 5, making option \nE the answer.\n"
  },
  {
    "id": "oca-284",
    "question": "Which are true statements about a package in a JAR on the classpath containing a  \nmodule- info.java file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "It is possible to make the package available to all other modules on the classpath."
      },
      {
        "key": "B",
        "text": "It is possible to make the package available to all other modules on the module path."
      },
      {
        "key": "C",
        "text": "It is possible to make the package available to exactly one other specific module on the \nclasspath."
      },
      {
        "key": "D",
        "text": "It is possible to make the package available to exactly one other specific module on the \nmodule path."
      },
      {
        "key": "E",
        "text": "It is possible to make sure the package is not available to any other modules on the \nclasspath."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Since the JAR is on the classpath, it is treated as a regular unnamed module even though \nit has a module-info.java file inside. Remember from learning about top-down migra\u0002tion that modules on the module path are not allowed to refer to the classpath, making \noptions B and D incorrect. The classpath does not have a facility to restrict packages, making \noption A correct and options C and E incorrect.\n"
  },
  {
    "id": "oca-285",
    "question": "Suppose you have separate modules for a service provider interface, service provider, service \nlocator, and consumer. Which statements are true about the directives you need to specify? \n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The consumer must use the requires directive."
      },
      {
        "key": "B",
        "text": "The consumer must use the uses directive."
      },
      {
        "key": "C",
        "text": "The service locator must use the requires directive."
      },
      {
        "key": "D",
        "text": "The service locator must use the uses directive."
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Options A and C are correct because both the consumer and the service locator \ndepend on the service provider interface. Additionally, option D is correct because the service \nlocator must specify that it uses the service provider interface to look it up.\n"
  },
  {
    "id": "oca-286",
    "question": "Given the following code snippet, which options correctly create a parallel stream? (Choose \nall that apply.)\nvar c = new ArrayList<Thread>();\nvar s = c.stream();\nvar p =                ;",
    "choices": [
      {
        "key": "A",
        "text": "new ParallelStream(s)"
      },
      {
        "key": "B",
        "text": "c.parallel()"
      },
      {
        "key": "C",
        "text": "s.parallelStream()"
      },
      {
        "key": "D",
        "text": "c.parallelStream()"
      },
      {
        "key": "E",
        "text": "new ParallelStream(c)"
      },
      {
        "key": "F",
        "text": "s.parallel()"
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "There is no such class within the Java API called ParallelStream, so options A and \nE are incorrect. The method defined in the Stream class to create a parallel stream from \nan existing stream is parallel(); therefore, option F is correct, and option C is incorrect. \nThe method defined in the Collection class to create a parallel stream from a collection is \nparallelStream(); therefore, option D is correct, and option B is incorrect.\n"
  },
  {
    "id": "oca-287",
    "question": "Given that the sum of the numbers from 1 (inclusive) to 10 (exclusive) is 45, what are the \npossible results of executing the following program? (Choose all that apply.)\n1:  import java.util.concurrent.locks.*;\n2:  import java.util.stream.*;\n3:  public class Bank {\n4:     private Lock vault = new ReentrantLock();\n5:     private int total = 0;\n6:     public void deposit(int value) {\n7:        try {\n8:           vault.tryLock();\n9:           total += value;\n10:       } finally { vault.unlock(); }\n11:    }\n12:    public static void main(String[] unused) {\n13:       var bank = new Bank();\n14:       IntStream.range(1, 10).parallel()\n15:          .forEach(s - > bank.deposit(s));\n16:       System.out.println(bank.total);\n17:    } }",
    "choices": [
      {
        "key": "A",
        "text": "45 is printed."
      },
      {
        "key": "B",
        "text": "A number less than 45 is printed."
      },
      {
        "key": "C",
        "text": "A number greater than 45 is printed."
      },
      {
        "key": "D",
        "text": "An exception is thrown."
      },
      {
        "key": "E",
        "text": "None of the above, as the code does not compile."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The tryLock() method returns immediately with a value of false if the lock cannot \nbe acquired. Unlike lock(), it does not wait for a lock to become available. This code fails \nto check the return value on line 8, resulting in the protected code being entered regardless of \nwhether the lock is obtained. In some executions (when tryLock() returns true on every \ncall), the code will complete successfully and print 45 at runtime, making option A correct. \nOn other executions (when tryLock() returns false at least once), the unlock()\nmethod on line 10 will throw an IllegalMonitorStateException at runtime, making \noption D correct. Option B would be possible if line 10 did not throw an exception.\n"
  },
  {
    "id": "oca-288",
    "question": "Which of the following statements about the Callable call() and Runnable run() \nmethods are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Both methods return void."
      },
      {
        "key": "B",
        "text": "Both can throw unchecked exceptions."
      },
      {
        "key": "C",
        "text": "Both can be implemented with lambda expressions."
      },
      {
        "key": "D",
        "text": "Runnable returns a generic type."
      },
      {
        "key": "E",
        "text": "Both can throw checked exceptions."
      },
      {
        "key": "F",
        "text": "Callable returns a generic type."
      }
    ],
    "answer": [
      "B",
      "C",
      "F"
    ],
    "explanation": "Runnable returns void and Callable returns a generic type, making options A \nand D incorrect and option F correct. All methods are capable of throwing unchecked excep\u0002tions, so option B is correct. Only Callable is capable of throwing checked exceptions, so \noption E is incorrect. Both Runnable and Callable are functional interfaces that can be \nimplemented with a lambda expression, so option C is also correct. \n"
  },
  {
    "id": "oca-289",
    "question": "Which lines need to be changed to make the code compile? (Choose all that apply.)\nExecutorService service =   // w1\n   Executors.newSingleThreadScheduledExecutor();\nservice.scheduleWithFixedDelay(() - > {\n   System.out.println(\"Open Zoo\");\n   return null;   // w2\n}, 0, 1, TimeUnit.MINUTES);\nvar result = service.submit(() - >   // w3\n   System.out.println(\"Wake Staff\"));\nSystem.out.println(result.get());   // w4",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "Line w1"
      },
      {
        "key": "C",
        "text": "Line w2"
      },
      {
        "key": "D",
        "text": "Line w3"
      },
      {
        "key": "E",
        "text": "Line w4"
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "The code does not compile, so options A and F are incorrect. The first problem \nis that although a ScheduledExecutorService is created, it is assigned to an \nExecutorService. The type of the variable on line w1 would have to be updated to \nScheduledExecutorService for the code to compile, making option B correct. The \nsecond problem is that scheduleWithFixedDelay() supports only Runnable, not \nCallable, and any attempt to return a value is invalid in a Runnable lambda expression; \ntherefore, line w2 will also not compile, and option C is correct. The rest of the lines compile \nwithout issue, so options D and E are incorrect.\n"
  },
  {
    "id": "oca-290",
    "question": "What statement about the following code is true?\nvar value1 = new AtomicLong(0);\nfinal long[] value2 = {0};\nIntStream.iterate(1, i - > 1).limit(100).parallel()\n   .forEach(i - > value1.incrementAndGet());\nIntStream.iterate(1, i - > 1).limit(100).parallel()\n   .forEach(i - > ++value2[0]);\nSystem.out.println(value1+\" \"+value2[0]);",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 100 100."
      },
      {
        "key": "B",
        "text": "It outputs 100 99."
      },
      {
        "key": "C",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "It compiles but enters an infinite loop at runtime."
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without throwing an exception or entering an infinite loop, \nso options D, E, and F are incorrect. The key here is that the increment operator ++ is not \natomic. While the first part of the output will always be 100, the second part is nondetermin\u0002istic. It may output any value from 1 to 100, because the threads can overwrite each other’s \nwork. Therefore, option C is the correct answer, and options A and B are incorrect.\n"
  },
  {
    "id": "oca-291",
    "question": "Which statements about the following code are correct? (Choose all that apply.)\nvar data = List.of(2,5,1,9,8);\ndata.stream().parallel()\n   .mapToInt(s - > s)\n   .peek(System.out::print)\n   .forEachOrdered(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "The peek() method will print the entries in the sorted order: 12589."
      },
      {
        "key": "B",
        "text": "The peek() method will print the entries in the original order: 25198."
      },
      {
        "key": "C",
        "text": "The peek() method will print the entries in an order that cannot be determined ahead \nof time."
      },
      {
        "key": "D",
        "text": "The forEachOrdered() method will print the entries in the sorted order: 12589."
      },
      {
        "key": "E",
        "text": "The forEachOrdered() method will print the entries in the original order: 25198."
      },
      {
        "key": "F",
        "text": "The forEachOrdered() method will print the entries in an order that cannot be \ndetermined ahead of time."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The code compiles, so option G is incorrect. The peek() method on a parallel stream \nwill process the elements concurrently, so the order cannot be determined ahead of time, and \noption C is correct. The forEachOrdered() method will process the elements in the order \nin which they are stored in the stream, making option E correct. None of the methods sort \nthe elements, so options A and D are incorrect.\n"
  },
  {
    "id": "oca-292",
    "question": "Fill in the blanks: __________ occur(s) when two or more threads are blocked forever but \nboth appear active. _______ occur(s) when two or more threads try to complete a related task \nat the same time, resulting in invalid or unexpected data.",
    "choices": [
      {
        "key": "A",
        "text": "Livelock, Deadlock"
      },
      {
        "key": "B",
        "text": "Deadlock, Starvation"
      },
      {
        "key": "C",
        "text": "Race conditions, Deadlock"
      },
      {
        "key": "D",
        "text": "Livelock, Race conditions"
      },
      {
        "key": "E",
        "text": "Starvation, Race conditions"
      },
      {
        "key": "F",
        "text": "Deadlock, Livelock"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Livelock occurs when two or more threads are conceptually blocked forever, although \nthey are each still active and trying to complete their task. A race condition is an undesirable \nresult that occurs when two tasks that should have been completed sequentially are com\u0002pleted at the same time. For these reasons, option D is correct.\n"
  },
  {
    "id": "oca-293",
    "question": "Assuming this class is accessed by only a single thread at a time, what is the result of calling \nthe countIceCreamFlavors() method?\nimport java.util.stream.LongStream;\npublic class Flavors {\n   private static int counter;\n   public static void countIceCreamFlavors()  {\n      counter = 0;\n      Runnable task = () - > counter++;\n      LongStream.range(0, 500)\n         .forEach(m - > new Thread(task).run());\n      System.out.println(counter);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "The method consistently prints a number less than 500."
      },
      {
        "key": "B",
        "text": "The method consistently prints 500."
      },
      {
        "key": "C",
        "text": "The method compiles and prints a value, but that value cannot be determined ahead of \ntime."
      },
      {
        "key": "D",
        "text": "The method does not compile."
      },
      {
        "key": "E",
        "text": "The method compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Be wary of run() vs. start() on the exam! The method looks like it executes a task \nconcurrently, but it runs synchronously. In each iteration of the forEach() loop, the pro\u0002cess waits for the run() method to complete before moving on. For this reason, the code \nis thread-safe. Since the program consistently prints 500 at runtime, option B is correct. \nNote that if start() had been used instead of run() (or the stream was parallel), then the \noutput would be indeterminate, and option C would have been correct.\n"
  },
  {
    "id": "oca-294",
    "question": "Which happens when a new task is submitted to an ExecutorService  in which no threads are \navailable?",
    "choices": [
      {
        "key": "A",
        "text": "The executor throws an exception when the task is submitted."
      },
      {
        "key": "B",
        "text": "The executor discards the task without completing it."
      },
      {
        "key": "C",
        "text": "The executor adds the task to an internal queue and completes when there is an avail-\nable thread."
      },
      {
        "key": "D",
        "text": "The thread submitting the task waits on the submit call until a thread is available before \ncontinuing."
      },
      {
        "key": "E",
        "text": "The executor stops an existing task and starts the newly submitted one."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "If a task is submitted to a thread executor, and the thread executor does not have any \navailable threads, the call to the task will return immediately with the task being queued \ninternally by the thread executor. For this reason, option C is the correct answer.\n"
  },
  {
    "id": "oca-295",
    "question": "What is the result of executing the following code snippet?\nList<Integer> lions = new ArrayList<>(List.of(1,2,3));\nList<Integer> tigers = new CopyOnWriteArrayList<>(lions);\nSet<Integer> bears = new ConcurrentSkipListSet<>();\nbears.addAll(lions);\nfor(Integer item: tigers) tigers.add(4); // x1\nfor(Integer item: bears) bears.add(5);   // x2\nSystem.out.println(lions.size() + \" \" + tigers.size()\n   + \" \" + bears.size());",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 3 6 4."
      },
      {
        "key": "B",
        "text": "It outputs 6 6 6."
      },
      {
        "key": "C",
        "text": "It outputs 6 3 4."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime on line x1."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime on line x2."
      },
      {
        "key": "G",
        "text": "It compiles but enters an infinite loop at runtime."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles without issue, so option D is incorrect. The \nCopyOnWriteArrrayList class is designed to preserve the original list on iteration, so \nthe first loop will be executed exactly three times and, in the process, will increase the size of \ntigers to six elements. The ConcurrentSkipListSet class allows modifications, and \nsince it enforces the uniqueness of its elements, the value 5 is added only once, leading to a \ntotal of four elements in bears. Finally, despite using the elements of lions to populate \nthe collections, tigers and bears are not backed by the original list, so the size of lions\nis 3 throughout this program. For these reasons, the program prints 3 6 4, and option A \nis correct.\n"
  },
  {
    "id": "oca-296",
    "question": "What statements about the following code are true? (Choose all that apply.)\nInteger i1 = List.of(1, 2, 3, 4, 5).stream().findAny().get();\nsynchronized(i1) { // y1\n   Integer i2 = List.of(6, 7, 8, 9, 10)\n      .parallelStream()\n      .sorted()\n      .findAny().get(); // y2\n   System.out.println(i1 + \" \" + i2);\n}",
    "choices": [
      {
        "key": "A",
        "text": "The first value printed is always 1."
      },
      {
        "key": "B",
        "text": "The second value printed is always 6."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line y1."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line y2."
      },
      {
        "key": "E",
        "text": "The code compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "G",
        "text": "It compiles but waits forever at runtime."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code compiles and runs without issue, so options C, D, E, and G are incorrect. \nThere are two important things to notice. First, synchronizing on the first variable doesn’t \nimpact the results of the code. Second, sorting on a parallel stream does not mean that \nfindAny() will return the first record. The findAny() method will return the value from \nthe first thread that retrieves a record. Therefore, the output is not guaranteed, and option \nF is correct. Option A looks correct, but even on serial streams, findAny() is free to select \nany element.\n"
  },
  {
    "id": "oca-297",
    "question": "Assuming each call to takeNap() takes five seconds to execute without throwing an exception, \nwhat is the expected result of executing the following code snippet?\nExecutorService service = Executors.newFixedThreadPool(4);\ntry {\n   service.execute(() - > takeNap());\n   service.execute(() - > takeNap());\n   service.execute(() - > takeNap());\n} finally {\n   service.shutdown();\n}\nservice.awaitTermination(2, TimeUnit.SECONDS);\nSystem.out.println(\"DONE!\");",
    "choices": [
      {
        "key": "A",
        "text": "It will immediately print DONE!."
      },
      {
        "key": "B",
        "text": "It will pause for 2 seconds and then print DONE!."
      },
      {
        "key": "C",
        "text": "It will pause for 5 seconds and then print DONE!."
      },
      {
        "key": "D",
        "text": "It will pause for 15 seconds and then print DONE!."
      },
      {
        "key": "E",
        "text": "It will throw an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above, as the code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The code snippet submits three tasks to an ExecutorService, shuts it down, and then \nwaits for the results. The awaitTermination() method waits a specified amount of time \nfor all tasks to complete and the service to finish shutting down. Since each five-second task \nis still executing, the awaitTermination() method will return with a value of false\nafter two seconds but not throw an exception. For these reasons, option B is correct.\n"
  },
  {
    "id": "oca-298",
    "question": "What statements about the following code are true? (Choose all that apply.)\nSystem.out.print(List.of(\"duck\",\"flamingo\",\"pelican\")\n   .parallelStream().parallel()   // q1\n   .reduce(0,\n      (c1, c2) - > c1.length() + c2.length(),  // q2\n      (s1, s2) - > s1 + s2));      // q3",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue, outputting the total length of all strings in the stream."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line q1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line q2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line q3."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code does not compile, so options A and E are incorrect. The problem here is that \nc1 is an Integer and c2 is a String, so the code fails to combine on line q2, since calling \nlength() on an Integer is not allowed, and option C is correct. The rest of the lines com\u0002pile without issue. Note that calling parallel() on an already parallel stream is allowed, \nand it may return the same object.\n"
  },
  {
    "id": "oca-299",
    "question": "What statements about the following code snippet are true? (Choose all that apply.)\nObject o1 = new Object();\nObject o2 = new Object();\nvar service = Executors.newFixedThreadPool(2);\nvar f1 = service.submit(() - > {\n   synchronized (o1) {\n      synchronized (o2) { System.out.print(\"Tortoise\"); }\n   }\n});\nvar f2 = service.submit(() - > {\n   synchronized (o2) {\n      synchronized (o1) { System.out.print(\"Hare\"); }\n   }\n});\nf1.get();\nf2.get();",
    "choices": [
      {
        "key": "A",
        "text": "The code will always output Tortoise followed by Hare."
      },
      {
        "key": "B",
        "text": "The code will always output Hare followed by Tortoise."
      },
      {
        "key": "C",
        "text": "If the code does output anything, the order cannot be determined."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "The code compiles but may produce a deadlock at runtime."
      },
      {
        "key": "F",
        "text": "The code compiles but may produce a livelock at runtime."
      },
      {
        "key": "G",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The code compiles without issue, so option D is incorrect. Since both tasks are sub\u0002mitted to the same thread executor pool, the order cannot be determined, so options A and \nB are incorrect, and option C is correct. The key here is that the order in which the resources \no1 and o2 are synchronized could result in a deadlock. For example, if the first thread gets a \nlock on o1 and the second thread gets a lock on o2 before either thread can get their second \nlock, the code will hang at runtime, making option E correct. The code cannot produce a \nlivelock, since both threads are waiting, so option F is incorrect. Finally, if a deadlock does \noccur, an exception will not be thrown, so option G is incorrect.\n"
  },
  {
    "id": "oca-300",
    "question": "Which statement about the following code snippet is correct?\n2: var cats = Stream.of(\"leopard\", \"lynx\", \"ocelot\", \"puma\")\n3:    .parallel();\n4: var bears = Stream.of(\"panda\",\"grizzly\",\"polar\").parallel();\n5: var data = Stream.of(cats,bears).flatMap(s - > s)\n6:    .collect(Collectors.groupingByConcurrent(\n7:       s - > !s.startsWith(\"p\")));\n8: System.out.println(data.get(false).size()\n9:    + \" \" + data.get(true).size());",
    "choices": [
      {
        "key": "A",
        "text": "It outputs 3 4."
      },
      {
        "key": "B",
        "text": "It outputs 4 3."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so options C, D, E, and F are incorrect. The \ncollect() operation groups the animals into those that do and do not start with the letter \np. Note that there are four animals that do not start with the letter p and three animals that \ndo. The logical complement operator (!) before the startsWith() method means that \nresults are reversed, so the output is 3 4, and option A is correct, making option B incorrect.\n"
  },
  {
    "id": "oca-301",
    "question": "Assuming one minute is enough time for all the threads within this program to complete, \nwhat are the possible results of executing the following program? (Choose all that apply.)\npublic class RocketShip {\n   private volatile int fuel;\n   private void launch(int checks) {\n      var p = new ArrayList<Thread>();\n      for (int i = 0; i < checks; i++)\n         p.add(new Thread(() - > fuel++));\n      p.forEach(Thread::interrupt);\n      p.forEach(Thread::start);\n      p.forEach(Thread::interrupt);\n   }\n   public static void main(String[] args) throws Exception {\n      var ship = new RocketShip();\n      ship.launch(100);\n      Thread.sleep(60*1000);\n      System.out.print(ship.fuel);\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints a number less than 100."
      },
      {
        "key": "B",
        "text": "It prints 100."
      },
      {
        "key": "C",
        "text": "It prints a number greater than 100."
      },
      {
        "key": "D",
        "text": "It does not compile."
      },
      {
        "key": "E",
        "text": "It compiles but throws an InterruptedException at runtime."
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "The code compiles just fine. If the calls to fuel++ are ordered sequentially, then the \nprogram will print 100 at runtime, making option B correct. On the other hand, the calls \nmay overwrite each other. The volatile attribute only guarantees memory consistency, not \nthread-safety, making option A correct and option C incorrect. Option E is also incorrect, \nas no InterruptedException is thrown by this code. Remember, interrupt() only \nimpacts a thread that is in a WAITING or TIMED_WAITING state. Calling interrupt() on \na thread in a NEW or RUNNABLE state has no impact unless the code is running and explicitly \nchecking the isInterrupted() method.\n"
  },
  {
    "id": "oca-302",
    "question": "Which statements about methods in ReentrantLock are correct? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "The lock() method will attempt to acquire a lock without waiting indefinitely for it."
      },
      {
        "key": "B",
        "text": "The testLock() method will attempt to acquire a lock without waiting indefinitely for it."
      },
      {
        "key": "C",
        "text": "The attemptLock() method will attempt to acquire a lock without waiting indefi-\nnitely for it."
      },
      {
        "key": "D",
        "text": "By default, a ReentrantLock fairly releases to each thread in the order in which it was \nrequested."
      },
      {
        "key": "E",
        "text": "Calling the unlock() method once will release a resource so that other threads can \nobtain the lock."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The lock() method will wait indefinitely for a lock, so option A is incorrect. Options B \nand C are also incorrect, as the correct method name to attempt to acquire a lock is \ntryLock(). Option D is incorrect, as fairness is set to false by default and must be \nenabled by using an overloaded constructor. Finally, option E is incorrect because a thread \nthat holds the lock may have called lock() or tryLock() multiple times. A thread needs \nto call unlock() once for each call to lock() and successful tryLock(). Option F is the \ncorrect answer since none of the other options are valid statements.\n"
  },
  {
    "id": "oca-303",
    "question": "Which of the following are valid Callable expressions? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "a - > {return 10;}"
      },
      {
        "key": "B",
        "text": "() - > {String s = \"\";}"
      },
      {
        "key": "C",
        "text": "() - > 5"
      },
      {
        "key": "D",
        "text": "() - > {return null}"
      },
      {
        "key": "E",
        "text": "() - > \"The\" + \"Zoo\""
      },
      {
        "key": "F",
        "text": "(int count) - > count+1"
      },
      {
        "key": "G",
        "text": "() - > {System.out.println(\"Giraffe\"); return 10;}"
      }
    ],
    "answer": [
      "C",
      "E",
      "G"
    ],
    "explanation": "A Callable lambda expression takes no values and returns a generic type; there\u0002fore, options C, E, and G are correct. Options A and F are incorrect because they both take \nan input parameter. Option B is incorrect because it does not return a value. Option D is not \na valid lambda expression, because it is missing a semicolon at the end of the return state\u0002ment, which is required when inside braces {}.\n"
  },
  {
    "id": "oca-304",
    "question": "What is the result of executing the following application? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintConstants {\n   public static void main(String[] args) {\n      var s = Executors.newScheduledThreadPool(10);\n      DoubleStream.of(3.14159,2.71828)   // b1\n         .forEach(c - > s.submit(         // b2\n            () - > System.out.println(10*c)));  // b3\n      s.execute(() - > System.out.println(\"Printed\"));\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and outputs the two numbers followed by Printed."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line b1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line b2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line b3."
      },
      {
        "key": "E",
        "text": "It compiles, but the output cannot be determined ahead of time."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "G",
        "text": "It compiles but waits forever at runtime."
      }
    ],
    "answer": [
      "E",
      "G"
    ],
    "explanation": "The application compiles and does not throw an exception. Even though the stream \nis processed in sequential order, the tasks are submitted to a thread executor, which may \ncomplete the tasks in any order. Therefore, the output cannot be determined ahead of time, \nand option E is correct. Finally, the thread executor is never shut down; therefore, the code \nwill run but never terminate, making option G also correct.\n"
  },
  {
    "id": "oca-305",
    "question": "What is the result of executing the following program? (Choose all that apply.)\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintCounter {\n   static int count = 0;\n   public static void main(String[] args) throws\n                     InterruptedException, ExecutionException {\n      var service = Executors.newSingleThreadExecutor();\n      try {\n         var r = new ArrayList<Future<?>>();\n         IntStream.iterate(0,i - > i+1).limit(5).forEach(\n            i - > r.add(service.execute(() - > {count++;})) // n1\n         );\n         for(Future<?> result : r) {\n            System.out.print(result.get()+\" \"); // n2\n         }\n      } finally { service.shutdown(); }\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It prints 0 1 2 3 4"
      },
      {
        "key": "B",
        "text": "It prints 1 2 3 4 5"
      },
      {
        "key": "C",
        "text": "It prints null null null null null"
      },
      {
        "key": "D",
        "text": "It hangs indefinitely at runtime."
      },
      {
        "key": "E",
        "text": "The output cannot be determined."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line n1."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line n2."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The key to solving this question is to remember that the execute() method returns \nvoid, not a Future object. Therefore, line n1 does not compile, and option F is the \ncorrect answer. If the submit() method had been used instead of execute(), option C \nwould have been the correct answer, as the output of the submit(Runnable) task is a \nFuture<?> object that can only return null on its get() method.\n"
  },
  {
    "id": "oca-306",
    "question": "Given the following code snippet and blank lines on p1 and p2, which values guarantee that \n1 is printed at runtime? (Choose all that apply.)\nvar data = List.of(List.of(1,2),\n   List.of(3,4),\n   List.of(5,6));\ndata.              // p1\n   .flatMap(s - > s.stream())\n   .              // p2\n   .ifPresent(System.out::print);",
    "choices": [
      {
        "key": "A",
        "text": "stream() on line p1, findFirst() on line p2"
      },
      {
        "key": "B",
        "text": "stream() on line p1, findAny() on line p2"
      },
      {
        "key": "C",
        "text": "parallelStream() on line p1, findAny() on line p2"
      },
      {
        "key": "D",
        "text": "parallelStream() on line p1, findFirst() on line p2"
      },
      {
        "key": "E",
        "text": "The code does not compile regardless of what is inserted into the blanks."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The findFirst() method guarantees the first element in the stream will be returned, \nwhether it is serial or parallel, making options A and D correct. While option B may con\u0002sistently print 1 at runtime, the behavior of findAny() on a serial stream is not guaran\u0002teed, so option B is incorrect. Option C is likewise incorrect, with the output being random \nat runtime.\n"
  },
  {
    "id": "oca-307",
    "question": "Assuming one minute is enough time for the tasks submitted to the service executor to \ncomplete, what is the result of executing countSheep()? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class BedTime {\n   private AtomicInteger s1 = new AtomicInteger(0); // w1\n   private int s2 = 0;\n \n   private void countSheep() throws InterruptedException {\n      var service = Executors.newSingleThreadExecutor(); // w2\n      try {\n         for (int i = 0; i < 100; i++)\n         service.execute(() - > {\n            s1.getAndIncrement(); s2++; }); // w3\n         Thread.sleep(60*1000);\n         System.out.println(s1 + \" \" + s2);\n      } finally { service.shutdown(); }\n   }\n   public static void main(String... nap) throws InterruptedException {\n      new BedTime().countSheep();\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "The method consistently prints 100 99."
      },
      {
        "key": "B",
        "text": "The method consistently prints 100 100."
      },
      {
        "key": "C",
        "text": "The output cannot be determined ahead of time."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line w1."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line w2."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line w3."
      },
      {
        "key": "G",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The code compiles and runs without issue. The key aspect to notice in the code is that a \nsingle-thread executor is used, meaning that no task will be executed concurrently. There\u0002fore, the results are valid and predictable, with 100 100 being the output, and option B is \nthe correct answer. If a thread executor with more threads was used, then the s2++ opera\u0002tions could overwrite each other, making the second value indeterminate at the end of the \nprogram. In this case, option C would be the correct answer.\n"
  },
  {
    "id": "oca-308",
    "question": "What is the result of executing the following application? (Choose all that apply.)\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class StockRoomTracker {\n   public static void await(CyclicBarrier cb) { // j1\n      try { cb.await(); } catch (Exception e) {}\n   }\n   public static void main(String[] args) {\n      var cb = new CyclicBarrier(10,\n         () - > System.out.println(\"Stock Room Full!\")); // j2\n      IntStream.iterate(1, i - > 1).limit(9).parallel()\n         .forEach(i - > await(cb)); // j3\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It outputs Stock Room Full!"
      },
      {
        "key": "B",
        "text": "The code will not compile because of line j1."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line j2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line j3."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      },
      {
        "key": "F",
        "text": "It compiles but waits forever at runtime."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code compiles without issue, so options B, C, and D are incorrect. The limit on the \ncyclic barrier is 10, but the stream can generate only up to 9 threads that reach the barrier; \ntherefore, the limit can never be reached, and option F is the correct answer, making options \nA and E incorrect. Even if the limit(9) statement was changed to limit(10), the \nprogram could still hang since the JVM might not allocate 10 threads to the parallel stream.\n"
  },
  {
    "id": "oca-309",
    "question": "What statements about the following class definition are true? (Choose all that apply.)\npublic final class TicketManager {\n   private int tickets;\n   private static TicketManager instance;\n   private TicketManager() {}\n   static synchronized TicketManager getInstance() {      // k1\n      if (instance==null) instance = new TicketManager(); // k2\n      return instance;\n   }\n \n   public int getTicketCount() { return tickets; }\n   public void addTickets(int value) {tickets += value;}  // k3\n   public void sellTickets(int value) {\n      synchronized (this) {                               // k4\n         tickets - = value;\n      } } }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line k2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line k3."
      },
      {
        "key": "D",
        "text": "The locks acquired on k1 and k4 are on the same object."
      },
      {
        "key": "E",
        "text": "The class correctly protects the tickets data from race conditions."
      },
      {
        "key": "F",
        "text": "At most one instance of TicketManager will be created in an application that uses this \nclass."
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "The class compiles without issue, so option A is correct. Since getInstance() is a \nstatic method and sellTickets() is an instance method, lines k1 and k4 synchro\u0002nize on different objects, making option D incorrect. The class is not thread-safe because the \naddTickets() method is not synchronized, and option E is incorrect. One thread could \ncall sellTickets() while another thread calls addTickets(), possibly resulting in bad \ndata. Finally, option F is correct because the getInstance() method is synchronized. \nSince the constructor is private, this method is the only way to create an instance of \nTicketManager outside the class. The first thread to enter the method will set the \ninstance variable, and all other threads will use the existing value. This is a singleton \npattern.\n"
  },
  {
    "id": "oca-310",
    "question": "Assuming an implementation of the performCount() method is provided prior to runtime, \nwhich of the following are possible results of executing the following application? (Choose \nall that apply.)\nimport java.util.*;\nimport java.util.concurrent.*;\npublic class CountZooAnimals {\n   public static void performCount(int animal) {\n      // IMPLEMENTATION OMITTED\n   }\n   public static void printResults(Future<?> f) {\n      try {\n         System.out.println(f.get(1, TimeUnit.DAYS)); // o1\n      } catch (Exception e) {\n         System.out.println(\"Exception!\");\n      }\n   }\n   public static void main(String[] args) throws Exception {\n      final var r = new ArrayList<Future<?>>();\n      ExecutorService s = Executors.newSingleThreadExecutor();\n      try {\n         for(int i = 0; i < 10; i++) {\n            final int animal = i;\n            r.add(s.submit(() - > performCount(animal))); // o2\n         }\n         r.forEach(f - > printResults(f));\n      } finally { s.shutdown(); }\n   } }",
    "choices": [
      {
        "key": "A",
        "text": "It outputs a number 10 times."
      },
      {
        "key": "B",
        "text": "It outputs a Boolean value 10 times."
      },
      {
        "key": "C",
        "text": "It outputs a null value 10 times."
      },
      {
        "key": "D",
        "text": "It outputs Exception! 10 times."
      },
      {
        "key": "E",
        "text": "It hangs indefinitely at runtime."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line o1."
      },
      {
        "key": "G",
        "text": "The code will not compile because of line o2."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "The code compiles and runs without issue, so options F and G are incorrect. The return \ntype of performCount() is void, so submit() is interpreted as being applied to a \nRunnable expression. While submit(Runnable) does return a Future<?>, calling \nget() on it always returns null. For this reason, options A and B are incorrect, and option \nC is correct. The performCount() method can also throw a runtime exception, which will \nthen be thrown by the get() call as an ExecutionException; therefore, option D is also \na correct answer. Finally, it is also possible for our performCount() to hang indefinitely, \nsuch as with a deadlock or infinite loop. Luckily, the call to get() includes a timeout value. \nWhile each call to Future.get() can wait up to a day for a result, it will eventually finish, \nso option E is incorrect.\n"
  },
  {
    "id": "oca-311",
    "question": "Which class would be best to use to read a binary file into a Java object?",
    "choices": [
      {
        "key": "A",
        "text": "BufferedStream"
      },
      {
        "key": "B",
        "text": "FileReader"
      },
      {
        "key": "C",
        "text": "ObjectInputStream"
      },
      {
        "key": "D",
        "text": "ObjectReader"
      },
      {
        "key": "E",
        "text": "ObjectOutputStream"
      },
      {
        "key": "F",
        "text": "ObjectWriter"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since the question asks about putting data into a structured object, the best class would \nbe one that deserializes the data. Therefore, ObjectInputStream is the best choice, which \nis option C. ObjectWriter, BufferedStream, and ObjectReader are not I/O stream \nclasses. ObjectOutputStream is an I/O class but is used to serialize data, not deserialize \nit. FileReader can be used to read text file data and construct an object, but the question \nasks what would be the best class to use for binary data.\n"
  },
  {
    "id": "oca-312",
    "question": "Assuming that / is the root directory within the file system, which of the following are true \nstatements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "/home/parrot is an absolute path."
      },
      {
        "key": "B",
        "text": "/home/parrot is a directory."
      },
      {
        "key": "C",
        "text": "/home/parrot is a relative path."
      },
      {
        "key": "D",
        "text": "new File(\"/home\") will throw an exception if /home does not exist."
      },
      {
        "key": "E",
        "text": "new File(\"/home\").delete() will throw an exception if /home does not exist."
      },
      {
        "key": "F",
        "text": "A Reader offers character encoding, making it more useful when working with String \ndata than an InputStream."
      },
      {
        "key": "G",
        "text": "A Reader offers multithreading support, making it more useful than an InputStream."
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Paths that begin with the root directory are absolute paths, so option A is correct, and \noption C is incorrect. Option B is incorrect because the path could be a file or directory \nwithin the file system. There is no rule that files have to end with a file extension. Option D is \nincorrect, as it is possible to create a File reference to files and directories that do not exist. \nOption E is also incorrect. The delete() method returns false if the file or directory \ncannot be deleted. Character stream classes often include built-in convenience methods for \nworking with String data, so option F is correct. There is no such optimization for multi\u0002threading, making option G incorrect.\n"
  },
  {
    "id": "oca-313",
    "question": "What are possible results of executing the following code? (Choose all that apply.)\npublic static void main(String[] args) throws IOException {\n   String line;\n   var c = System.console();\n   Writer w = c.writer();\n   try (w) {\n      if ((line = c.readLine(\"Enter your name: \")) != null)\n         w.append(line);\n         w.flush();\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code runs, but nothing is printed."
      },
      {
        "key": "B",
        "text": "The code prints what was entered by the user."
      },
      {
        "key": "C",
        "text": "The code behaves the same if throws IOException is removed."
      },
      {
        "key": "D",
        "text": "A NullPointerException may be thrown."
      },
      {
        "key": "E",
        "text": "A NullPointerException will always be thrown."
      },
      {
        "key": "F",
        "text": "A NullPointerException will never be thrown."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "If the console is unavailable, System.console() will return null, making \noption D correct and options E and F incorrect. The writer methods throw a checked \nIOException, making option C incorrect. The code works correctly, prompting for input \nand printing it. Therefore, option A is incorrect and option B is correct.\n"
  },
  {
    "id": "oca-314",
    "question": "For which values of path sent to this method would it be possible for the following code to \noutput Success? (Choose all that apply.)\npublic void removeBadFile(Path path) {\n   if(Files.isDirectory(path))\n     System.out.println(Files.deleteIfExists(path)\n        ? \"Success\": \"Try Again\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "path refers to a regular file in the file system."
      },
      {
        "key": "B",
        "text": "path refers to a symbolic link in the file system."
      },
      {
        "key": "C",
        "text": "path refers to an empty directory in the file system."
      },
      {
        "key": "D",
        "text": "path refers to a directory with content in the file system."
      },
      {
        "key": "E",
        "text": "path does not refer to a record that exists within the file system."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile, as Files.deleteIfExists() declares the checked \nIOException that must be handled or declared. Remember, most Files methods declare \nIOException, especially the ones that modify a file or directory. For this reason, option F is \ncorrect. If the method were corrected to declare the appropriate exceptions, option C would \nbe correct. Option B would also be correct if the method were provided a symbolic link \nthat pointed to an empty directory. Options A and E would not print anything, as \nFiles.isDirectory() returns false for both. Finally, option D would throw a \nDirectoryNotEmptyException at runtime.\n"
  },
  {
    "id": "oca-315",
    "question": "Assume that the directory /animals exists and is empty. What is the result of executing the \nfollowing code?\nPath path = Path.of(\"/animals\");\ntry (var z = Files.walk(path)) {\n   boolean b = z\n      .filter((p,a) - > a.isDirectory() && !path.equals(p)) // x\n      .findFirst().isPresent();  // y\n   System.out.print(b ? \"No Sub\": \"Has Sub\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "It prints No Sub."
      },
      {
        "key": "B",
        "text": "It prints Has Sub."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line x."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line y."
      },
      {
        "key": "E",
        "text": "The output cannot be determined."
      },
      {
        "key": "F",
        "text": "It produces an infinite loop at runtime."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The filter() operation applied to a Stream<Path> takes only one parameter, not \ntwo, so the code does not compile, and option C is correct. If the code were rewritten to \nuse the Files.find() method with the BiPredicate as input (along with a maxDepth\nvalue), the output would be option B, Has Sub, since the directory is given to be empty. For \nfun, we reversed the expected output of the ternary operation.\n"
  },
  {
    "id": "oca-316",
    "question": "What would be the value of name if the instance of Eagle created in the main() method were \nserialized and then deserialized?\nimport java.io.Serializable;\nclass Bird {\n   protected transient String name;\n   public void setName(String name) { this.name = name; }\n   public String getName() { return name; }\n   public Bird() {\n      this.name = \"Matt\";\n   }\n}\npublic class Eagle extends Bird implements Serializable {\n   { this.name = \"Olivia\"; }\n   public Eagle() {\n      this.name = \"Bridget\";\n   }\n   public static void main(String[] args) {\n      var e = new Eagle();\n      e.name = \"Adeline\";\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Adeline"
      },
      {
        "key": "B",
        "text": "Bridget"
      },
      {
        "key": "C",
        "text": "Matt"
      },
      {
        "key": "D",
        "text": "Olivia"
      },
      {
        "key": "E",
        "text": "null"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without issue, so options F and G are incorrect. The key \nhere is that while Eagle is serializable, its parent class, Bird, is not. Therefore, none of the \nmembers of Bird will be serialized. Even if you didn’t know that, you should know what \nhappens on deserialization. During deserialization, Java calls the constructor of the first non\u0002serializable parent. In this case, the Bird constructor is called, with name being set to \nMatt, making option C correct. Note that none of the constructors or instance initializers in \nEagle are executed as part of deserialization.\n"
  },
  {
    "id": "oca-317",
    "question": "Assume that /kang exists as a symbolic link to the directory /mammal/kangaroo within \nthe file system. Which of the following statements are correct about this code snippet? \n(Choose all that apply.)\nvar path = Paths.get(\"/kang\");\nif(Files.isDirectory(path) && Files.isSymbolicLink(path))\n   Files.createDirectory(path.resolve(\"joey\"));",
    "choices": [
      {
        "key": "A",
        "text": "A new directory will always be created."
      },
      {
        "key": "B",
        "text": "A new directory may be created."
      },
      {
        "key": "C",
        "text": "If the code creates a directory, it will be reachable at /kang/joey."
      },
      {
        "key": "D",
        "text": "If the code creates a directory, it will be reachable at /mammal/joey."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code will compile but will always throw an exception at runtime."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "The code snippet will attempt to create a directory if the target of the symbolic link \nexists and is a directory. If the directory already exists, though, it will throw an exception. \nFor this reason, option A is incorrect, and option B is correct. It will be created in \n/mammal/kangaroo/joey and also reachable at /kang/joey because of the symbolic \nlink, making option C correct.\n"
  },
  {
    "id": "oca-318",
    "question": "Assuming that the /fox/food- schedule.csv file exists with the specified contents, what \nis the expected output of calling printData() on it?\n/fox/food-  schedule.csv\n6am,Breakfast\n9am,SecondBreakfast\n12pm,Lunch\n6pm,Dinner\n \nvoid printData(Path path) throws IOException {\n   Files.readAllLines(path) // r1\n      .flatMap(p - > Stream.of(p.split(\",\"))) // r2\n      .map(q - > q.toUpperCase())  // r3\n      .forEach(System.out::println);\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code will not compile because of line r1."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line r2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line r3."
      },
      {
        "key": "D",
        "text": "It throws an exception at runtime."
      },
      {
        "key": "E",
        "text": "It does not print anything at runtime."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The readAllLines() method returns a List, not a Stream. Therefore, the call \nto flatMap() is invalid, and option B is correct. If the Files.lines() method were \nused instead, it would print the contents of the file one capitalized word at a time with the \ncommas removed.\n"
  },
  {
    "id": "oca-319",
    "question": "Given the following method, which statements are correct? (Choose all that apply.)\npublic void copyFile(File file1, File file2) throws Exception {\n   var reader = new InputStreamReader(new FileInputStream(file1));\n   try (var writer = new FileWriter(file2)) {\n      char[] buffer = new char[10];\n      while(reader.read(buffer) != - 1) {\n          writer.write(buffer);\n          // n1\n      }\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code does not compile because reader is not a buffered stream."
      },
      {
        "key": "B",
        "text": "The code does not compile because writer is not a buffered stream."
      },
      {
        "key": "C",
        "text": "The code compiles and correctly copies the data between some files."
      },
      {
        "key": "D",
        "text": "The code compiles and correctly copies the data between all files."
      },
      {
        "key": "E",
        "text": "If we check file2 on line n1 within the file system after five iterations of the while \nloop, it may be empty."
      },
      {
        "key": "F",
        "text": "If we check file2 on line n1 within the file system after five iterations, it will contain \nexactly 50 characters."
      },
      {
        "key": "G",
        "text": "This method contains a resource leak."
      }
    ],
    "answer": [
      "C",
      "E",
      "G"
    ],
    "explanation": "First, the method does compile, so options A and B are incorrect. Methods to \nread/write byte[] values exist in the abstract parent of all I/O stream classes. This imple\u0002mentation is not correct, though, as the return value of read(buffer) is not used properly. \nIt will only correctly copy files whose character count is a multiple of 10, making option C \ncorrect and option D incorrect. Option E is also correct as the data may not have made it to \ndisk yet. Option F would be correct if the flush() method were called after every write. \nFinally, option G is correct as the reader stream is never closed.\n"
  },
  {
    "id": "oca-320",
    "question": "Which of the following correctly create Path instances? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "new Path(\"jaguar.txt\")"
      },
      {
        "key": "B",
        "text": "FileSystems.getDefault().getPath(\"puma.txt\")"
      },
      {
        "key": "C",
        "text": "Path.get(\"cats\",\"lynx.txt\")"
      },
      {
        "key": "D",
        "text": "new java.io.File(\"tiger.txt\").toPath()"
      },
      {
        "key": "E",
        "text": "new FileSystem().getPath(\"lion\")"
      },
      {
        "key": "F",
        "text": "Paths.getPath(\"ocelot.txt\")"
      },
      {
        "key": "G",
        "text": "Path.of(Path.of(\".\").toUri())"
      }
    ],
    "answer": [
      "B",
      "D",
      "G"
    ],
    "explanation": "Options A and E are incorrect because Path and FileSystem, respectively, are \nabstract types that should be instantiated using a factory method. Option C is incorrect \nbecause the static method in the Path interface is of(), not get(). Option F is incorrect \nbecause the static method in the Paths class is get(), not getPath(). Options B and \nD are correct ways to obtain a Path instance. Option G is also correct, as there is an over\u0002loaded static method in Path that takes a URI instead of a String.\n"
  },
  {
    "id": "oca-321",
    "question": "Which classes will allow the following to compile? (Choose all that apply.)\nvar is = new BufferedInputStream(new FileInputStream(\"z.txt\"));\nInputStream wrapper = new  (is);\ntry (wrapper) {}",
    "choices": [
      {
        "key": "A",
        "text": "BufferedInputStream"
      },
      {
        "key": "B",
        "text": "BufferedReader"
      },
      {
        "key": "C",
        "text": "BufferedWriter"
      },
      {
        "key": "D",
        "text": "FileInputStream"
      },
      {
        "key": "E",
        "text": "ObjectInputStream"
      },
      {
        "key": "F",
        "text": "ObjectOutputStream"
      },
      {
        "key": "G",
        "text": "None of the above, as the first line does not compile"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The code will compile if the correct classes are used, so option G is incorrect. \nRemember, a try-with-resources statement can use resources declared before the start of the \nstatement. The reference type of wrapper is InputStream, so we need a class that inherits \nInputStream. We can eliminate BufferedWriter, ObjectOutputStream, and \nBufferedReader since their names do not end in InputStream. Next, we see the class \nmust take another stream as input, so we need to choose the remaining streams that are high\u0002level streams. BufferedInputStream is a high-level stream, so option A is correct. Even \nthough the instance is already a BufferedInputStream, there’s no rule that it can’t be \nwrapped multiple times by a high-level stream. Option D is incorrect, as \nFileInputStream operates on a file, not another stream. Finally, option E is correct—an \nObjectInputStream is a high-level stream that operates on other streams.\n"
  },
  {
    "id": "oca-322",
    "question": "What is the result of executing the following code? (Choose all that apply.)\n4: var p = Paths.get(\"sloth.schedule\");\n5: var a = Files.readAttributes(p, BasicFileAttributes.class);\n6: Files.mkdir(p.resolve(\".backup\"));\n7: if(a.size()>0 && a.isDirectory()) {\n8:    a.setTimes(null,null,null);\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The method to create a directory in the Files class is createDirectory(), not \nmkdir(). For this reason, line 6 does not compile, and option C is correct. In addition, the \nsetTimes() method is available only on BasicFileAttributeView, not the read-only \nBasicFileAttributes, so line 8 will also not compile, making option E correct.\n"
  },
  {
    "id": "oca-323",
    "question": "Which of the following are true statements about serialization in Java? (Choose all \nthat apply.)",
    "choices": [
      {
        "key": "A",
        "text": "All non- null instance members of the class must be serializable or marked transient."
      },
      {
        "key": "B",
        "text": "Records are automatically serializable."
      },
      {
        "key": "C",
        "text": "Serialization involves converting data into Java objects."
      },
      {
        "key": "D",
        "text": "Serializable is a functional interface."
      },
      {
        "key": "E",
        "text": "The class must declare a static serialVersionUID variable."
      },
      {
        "key": "F",
        "text": "The class must extend the Serializable class."
      },
      {
        "key": "G",
        "text": "The class must implement the Serializable interface."
      }
    ],
    "answer": [
      "A",
      "G"
    ],
    "explanation": "For a class to be serialized, it must implement the Serializable interface and \ncontain instance members that are serializable or marked transient. For these reasons, \noptions A and G are correct and option F is incorrect. Option B is incorrect because even \nrecords are required to implement Serializable to be serialized. Option C is incorrect \nbecause it describes deserialization. The Serializable interface is a marker interface that \ndoes not contain any abstract methods, making option D incorrect. While it is a good prac\u0002tice for a serializable class to include a static serialVersionUID variable, it is not \nrequired. Therefore, option E is incorrect as well.\n"
  },
  {
    "id": "oca-324",
    "question": "What is the output of the following code? (Choose all that apply.)\n22: var p1 = Path.of(\"/zoo/./bear\",\"../food.txt\");\n23: p1.normalize().relativize(Path.of(\"/lion\"));\n24: System.out.println(p1);\n25:\n26: var p2 = Paths.get(\"/zoo/animals/bear/koala/food.txt\");\n27: System.out.println(p2.subpath(1,3).getName(1));\n28:\n29: var p3 = Path.of(\"/pets/../cat.txt\");\n30: var p4 = Paths.get(\"./dog.txt\");\n31: System.out.println(p4.resolve(p3));",
    "choices": [
      {
        "key": "A",
        "text": "../../lion"
      },
      {
        "key": "B",
        "text": "/zoo/./bear/../food.txt"
      },
      {
        "key": "C",
        "text": "animal"
      },
      {
        "key": "D",
        "text": "bear"
      },
      {
        "key": "E",
        "text": "/pets/../cat.txt"
      },
      {
        "key": "F",
        "text": "/pets/../cat.txt/./dog.txt"
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Path is immutable, so line 23 is ignored. If it were assigned to p1, option A would \nbe correct. Since it is not assigned, the original value is still present, which is option B. \nMoving on to the second section, the subpath() method on line 27 is applied to the abso\u0002lute path, which returns the relative path animals/bear. Next, the getName() method \nis applied to the relative path, and since this is indexed from 0, it returns the relative path \nbear. Therefore, option D is correct. Finally, remember calling resolve() with an absolute \npath as a parameter returns the absolute path, so option E is correct.\n"
  },
  {
    "id": "oca-325",
    "question": "Suppose that the working directory is /weather and the absolute path  \n/weather/winter/snow.dat represents a file that exists within the file system. Which of \nthe following lines of code create an object that represents the file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "new File(\"/weather\", \"winter\", \"snow.dat\")"
      },
      {
        "key": "B",
        "text": "new File(\"/weather/winter/snow.dat\")"
      },
      {
        "key": "C",
        "text": "new File(\"/weather/winter\", new File(\"snow.dat\"))"
      },
      {
        "key": "D",
        "text": "new File(\"weather\", \"/winter/snow.dat\")"
      },
      {
        "key": "E",
        "text": "new File(new File(\"/weather/winter\"), \"snow.dat\")"
      },
      {
        "key": "F",
        "text": "Path.of(\"/weather/winer/snow.dat\").toFile();"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "E",
      "F"
    ],
    "explanation": "Option A does not compile, as there is no File constructor that takes three param\u0002eters. Option B is correct and is the proper way to create a File instance with a single \nString parameter. Option C is incorrect, as there is no constructor that takes a String\nfollowed by a File. There is a constructor that takes a File followed by a String, mak\u0002ing option E correct. Option D is incorrect because the first parameter is missing a slash \n(/) to indicate it is an absolute path. Since it’s a relative path, it is correct only when the \nuser’s current directory is the root directory. Finally, option F is correct as it creates a File\nfrom a Path.\n"
  },
  {
    "id": "oca-326",
    "question": "Assuming zoo- data.txt exists and is not empty, what statements about the following \nmethod are correct? (Choose all that apply.)\nprivate void echo() throws IOException {\n   var o = new FileWriter(\"new- zoo.txt\");\n   try (var f = new FileReader(\"zoo- data.txt\");\n      var b = new BufferedReader(f); o) {\n   \n      o.write(b.readLine());\n   }\n   o.write(\"\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "When run, the method creates a new file with one line of text in it."
      },
      {
        "key": "B",
        "text": "When run, the method creates a new file with two lines of text in it."
      },
      {
        "key": "C",
        "text": "When run, the method creates a new file with the same number of lines as the original \nfile."
      },
      {
        "key": "D",
        "text": "The method compiles but will produce an exception at runtime."
      },
      {
        "key": "E",
        "text": "The method does not compile."
      },
      {
        "key": "F",
        "text": "The method uses byte stream classes."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The method compiles, so option E is incorrect. The method creates a new-zoo.txt\nfile and copies the first line from zoo-data.txt into it, making option A correct. The try\u0002with-resources statement closes all of the declared resources, including the FileWriter o. \nFor this reason, the Writer is closed when the last o.write() is called, resulting in an \nIOException at runtime and making option D correct. Option F is incorrect because this \nimplementation uses the character stream classes, which inherit from Reader or Writer.\n"
  },
  {
    "id": "oca-327",
    "question": "Which are true statements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "NIO.2 includes a method to delete an entire directory tree."
      },
      {
        "key": "B",
        "text": "NIO.2 includes a method to traverse a directory tree."
      },
      {
        "key": "C",
        "text": "NIO.2 includes methods that are aware of symbolic links."
      },
      {
        "key": "D",
        "text": "Files.readAttributes() cannot access file-system dependent attributes."
      },
      {
        "key": "E",
        "text": "Files.readAttributes() is often more performant since it reads multiple attrib-\nutes rather than accessing individual attributes."
      },
      {
        "key": "F",
        "text": "Files.readAttributes() works with the File object."
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "Options B and C are properties of NIO.2 and are good reasons to use it over the \njava.io.File class. Option A is incorrect as both APIs can delete only empty directories, \nnot a directory tree. Using a view to read multiple attributes leads to fewer round trips \nbetween the process and the file system and better performance, making option E correct. \nViews can be used to access file system–specific attributes that are not available in Files\nmethods; therefore, option D is correct. Files is part of NIO.2, whereas File is part of \njava.io, which means option F is incorrect.\n"
  },
  {
    "id": "oca-328",
    "question": "Assume that reader is a valid stream whose next characters are PEACOCKS. What is true \nabout the output of the following code snippet? (Choose all that apply.)\nvar sb = new StringBuilder();\nsb.append((char)reader.read());\nreader.mark(10);\nfor(int i=0; i<2; i++) {\n   sb.append((char)reader.read());\n   reader.skip(2);\n}\nreader.reset();\nreader.skip(0);\nsb.append((char)reader.read());\nSystem.out.println(sb.toString());",
    "choices": [
      {
        "key": "A",
        "text": "The code may print PEAE."
      },
      {
        "key": "B",
        "text": "The code may print PEOA."
      },
      {
        "key": "C",
        "text": "The code may print PEOE."
      },
      {
        "key": "D",
        "text": "The code may print PEOS."
      },
      {
        "key": "E",
        "text": "The code will always print PEAE."
      },
      {
        "key": "F",
        "text": "The code will always print PEOA."
      },
      {
        "key": "G",
        "text": "The code will always print PEOE."
      },
      {
        "key": "H",
        "text": "The code will always print PEOS."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since a Reader may or may not support mark(), we can rule out options E, F, G, and \nH. Assuming mark() is supported, P is added to the StringBuilder first. Next, the posi\u0002tion in the stream is marked before E. The E is added to the StringBuilder, with AC being \nskipped, and then the O is added to the StringBuilder, with CK being skipped. The stream \nis then reset() to the position before the E. The call to skip(0) doesn’t do anything since \nthere are no characters to skip, so E is added onto the StringBuilder in the next read()\ncall. The value PEOE is printed, and option C is correct.\n"
  },
  {
    "id": "oca-329",
    "question": "Assuming that the directories and files referenced exist and are not symbolic links, what is \nthe result of executing the following code?\nvar p1 = Path.of(\"/lizard\",\".\").resolve(Path.of(\"walking.txt\"));\nvar p2 = new File(\"/lizard/././actions/../walking.txt\").toPath();\nSystem.out.print(Files.isSameFile(p1,p2));\nSystem.out.print(\" \");\nSystem.out.print(p1.equals(p2));\nSystem.out.print(\" \");\nSystem.out.print(Files.mismatch(p1,p2));",
    "choices": [
      {
        "key": "A",
        "text": "true true - 1"
      },
      {
        "key": "B",
        "text": "true true 0"
      },
      {
        "key": "C",
        "text": "true false - 1"
      },
      {
        "key": "D",
        "text": "true false 0"
      },
      {
        "key": "E",
        "text": "false true - 1"
      },
      {
        "key": "F",
        "text": "false true 0"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      },
      {
        "key": "H",
        "text": "The result cannot be determined."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without issue, so option G is incorrect. If you simplify the \nredundant path symbols, p1 and p2 represent the same path, /lizard/walking.txt. \nTherefore, isSameFile() returns true. The second output is false, because equals()\nchecks only if the path values are the same, without reducing the path symbols. Finally, \nmismatch() sees that the contents are the same and returns -1. For these reasons, option C \nis correct. \n"
  },
  {
    "id": "oca-330",
    "question": "Assume that monkey.txt is a file that exists in the current working directory. Which state-\nments about the following code snippet are correct? (Choose all that apply.)\nFiles.move(Path.of(\"monkey.txt\"), Paths.get(\"/animals\"),\n   StandardCopyOption.ATOMIC_MOVE,\n   LinkOption.NOFOLLOW_LINKS);",
    "choices": [
      {
        "key": "A",
        "text": "If /animals/monkey.txt exists, it will be overwritten at runtime."
      },
      {
        "key": "B",
        "text": "If /animals exists as an empty directory, /animals/monkey.txt will be the new \nlocation of the file."
      },
      {
        "key": "C",
        "text": "If monkey.txt is a symbolic link, the file it points to will be moved at runtime."
      },
      {
        "key": "D",
        "text": "If the move is successful and another process is monitoring the file system, it will not see \nan incomplete file at runtime."
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The target path of the file after the move() operation is /animals, not \n/animals/monkey.txt, so options A and B are both incorrect. Both will throw an \nexception at runtime since /animals already exists and is a directory. Next, the \nNOFOLLOW_LINKS option means that if the source is a symbolic link, the link itself and not \nthe target will be copied at runtime, so option C is also incorrect. The option ATOMIC_MOVE\nmeans that any process monitoring the file system will not see an incomplete file during the \nmove, so option D is correct.\n"
  },
  {
    "id": "oca-331",
    "question": "Assume that /monkeys exists as a directory containing multiple files, symbolic links, and \nsubdirectories. Which statement about the following code is correct?\nvar f = Path.of(\"/monkeys\");\ntry (var m =\n   Files.find(f, 0, (p,a) - > a.isSymbolicLink())) { // y1\n      m.map(s - > s.toString())\n         .collect(Collectors.toList())\n         .stream()\n         .filter(s - > s.toString().endsWith(\".txt\")) // y2\n         .forEach(System.out::println);\n}",
    "choices": [
      {
        "key": "A",
        "text": "It will print all symbolic links in the directory tree ending in .txt."
      },
      {
        "key": "B",
        "text": "It will print the target of all symbolic links in the directory ending in .txt."
      },
      {
        "key": "C",
        "text": "It will print nothing."
      },
      {
        "key": "D",
        "text": "It does not compile because of line y1."
      },
      {
        "key": "E",
        "text": "It does not compile because of line y2."
      },
      {
        "key": "F",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles and runs without issue, so options D, E, and F are incorrect. The most \nimportant thing to notice is that the depth parameter specified as the second argument to \nfind() is 0, meaning the only record that will be searched is the top-level directory. Since \nwe know that the top directory is a directory and not a symbolic link, no other paths will be \nvisited, and nothing will be printed. For these reasons, option C is the correct answer.\n"
  },
  {
    "id": "oca-332",
    "question": "Which of the following fields will be null after an instance of the class created  \non line 17 is serialized and then deserialized using ObjectOutputStream and \nObjectInputStream? (Choose all that apply.)\n1:  import java.io.Serializable;\n2:  import java.util.List;\n3:  public class Zebra implements Serializable {\n4:     private transient String name = \"George\";\n5:     private static String birthPlace = \"Africa\";\n6:     private transient Integer age;\n7:     List<Zebra> friends = new java.util.ArrayList<>();\n8:     private Object stripes = new Object();\n9:     { age = 10;}\n10:    public Zebra() {\n11:       this.name = \"Sophia\";\n12:    }\n13:    static Zebra writeAndRead(Zebra z) {\n14:       // Implementation omitted\n15:    }\n16:    public static void main(String[] args) {\n17:       var zebra = new Zebra();\n18:       zebra = writeAndRead(zebra);\n19:    }",
    "choices": [
      {
        "key": "A",
        "text": "age"
      },
      {
        "key": "B",
        "text": "birthplace"
      },
      {
        "key": "C",
        "text": "friends"
      },
      {
        "key": "D",
        "text": "name"
      },
      {
        "key": "E",
        "text": "stripes"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "The code compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "The code compiles, so option F is incorrect. To be serializable, a class must implement \nthe Serializable interface, which Zebra does. It must also contain instance members \nthat either are marked transient or are serializable. The instance member stripes is of \ntype Object, which is not serializable. If Object implemented Serializable, all objects \nwould be serializable by default, defeating the purpose of having the Serializable inter\u0002face. Therefore, the Zebra class is not serializable, with the program throwing an exception \nat runtime if serialized and making option G correct. If stripes were removed from the \nclass, options A and D would be the correct answers, as name and age are both marked \ntransient.\n"
  },
  {
    "id": "oca-333",
    "question": "What are some possible results of executing the following code? (Choose all that apply.)\nvar x = Path.of(\"/animals/fluffy/..\");\nFiles.walk(x.toRealPath().getParent())      // u1\n   .map(p - > p.toAbsolutePath().toString()) // u2\n   .filter(s - > s.endsWith(\".java\")) \n   .forEach(System.out::println);",
    "choices": [
      {
        "key": "A",
        "text": "It prints some files in the root directory."
      },
      {
        "key": "B",
        "text": "It prints all files in the root directory."
      },
      {
        "key": "C",
        "text": "FileSystemLoopException is thrown at runtime."
      },
      {
        "key": "D",
        "text": "Another exception is thrown at runtime."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line u1."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line u2."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "The code compiles without issue, so options E and F are incorrect. The \ntoRealPath() method will simplify the path to /animals and throw an exception if it \ndoes not exist, making option D correct. If the path does exist, calling getParent() on it \nreturns the root directory. Walking the root directory with the filter expression will print all \n.java files in the root directory (along with all .java files in the directory tree), making \noption A correct. Option B is incorrect because it will skip files and directories that do not \nend in the .java extension. Option C is also incorrect as Files.walk() does not follow \nsymbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is \nencountered will the exception be thrown.\n"
  },
  {
    "id": "oca-334",
    "question": "Assume that the source instance passed to the following method represents a file that exists. \nAlso assume that /flip/sounds.txt exists as a file prior to executing this method. When \nthis method is executed, which statement correctly copies the file to the path specified by  \n/flip/sounds.txt?\nvoid copyIntoFlipDirectory(Path source) throws IOException {\n   var dolphinDir = Path.of(\"/flip\");\n   dolphinDir = Files.createDirectories(dolphinDir);\n   var n = Paths.get(\"sounds.txt\");\n   ;\n}",
    "choices": [
      {
        "key": "A",
        "text": "Files.copy(source, dolphinDir)"
      },
      {
        "key": "B",
        "text": "Files.copy(source, dolphinDir.resolve(n),  \nStandardCopyOption.REPLACE_EXISTING)"
      },
      {
        "key": "C",
        "text": "Files.copy(source, dolphinDir,  \nStandardCopyOption.REPLACE_EXISTING )"
      },
      {
        "key": "D",
        "text": "Files.copy(source, dolphinDir.resolve(n))"
      },
      {
        "key": "E",
        "text": "The method does not compile, regardless of what is placed in the blank."
      },
      {
        "key": "F",
        "text": "The method compiles but throws an exception at runtime, regardless of what is placed \nin the blank."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The method compiles without issue, so option E is incorrect. Option F is also incorrect. \nEven though /flip exists, createDirectories() does not throw an exception if the \npath already exists. If createDirectory() were used instead, option F would be correct. \nNext, the copy() command takes a target that is the path to the new file location, not the \ndirectory to be copied into. Therefore, the target path should be /flip/sounds.txt, \nnot /flip. For this reason, options A and C are incorrect. Since the question says the file \nalready exists, the REPLACE_EXISTING option must be specified or an exception will be \nthrown at runtime, making option B the correct answer.\n"
  },
  {
    "id": "oca-335",
    "question": "Suppose that you need to read text data from a file and want the data to be performant on \nlarge files. Which two java.io stream classes can be chained together to best achieve this \nresult? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "BufferedInputStream"
      },
      {
        "key": "B",
        "text": "BufferedReader"
      },
      {
        "key": "C",
        "text": "FileInputStream"
      },
      {
        "key": "D",
        "text": "FileReader"
      },
      {
        "key": "E",
        "text": "PrintInputStream"
      },
      {
        "key": "F",
        "text": "ObjectInputStream"
      },
      {
        "key": "G",
        "text": "PrintReader"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Since you need to read characters, the Reader classes are appropriate. Therefore, you \ncan eliminate options A, C, and F. Additionally, options E and G are incorrect, as they ref\u0002erence classes that do not exist. Options B and D are correct since they read from a file and \nbuffer for performance.\n"
  },
  {
    "id": "oca-336",
    "question": "Which interfaces or classes are in a database- specific JAR file? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Driver"
      },
      {
        "key": "B",
        "text": "Driver’s implementation"
      },
      {
        "key": "C",
        "text": "Manager"
      },
      {
        "key": "D",
        "text": "DriverManager’s implementation"
      },
      {
        "key": "E",
        "text": "PreparedStatement"
      },
      {
        "key": "F",
        "text": "PreparedStatement implementation"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "The Driver and PreparedStatement interfaces are part of the JDK, making \noptions A and E incorrect. Option C is incorrect because we made it up. The concrete \nDriverManager class is also part of the JDK, making option D incorrect. Options B and \nF are correct since the implementation of these interfaces is part of the database-specific \ndriver JAR file.\n"
  },
  {
    "id": "oca-337",
    "question": "Which of the following is a valid JDBC URL?",
    "choices": [
      {
        "key": "A",
        "text": "jdbc:sybase:localhost:1234/db"
      },
      {
        "key": "B",
        "text": "jdbc::sybase::localhost::/db"
      },
      {
        "key": "C",
        "text": "jdbc::sybase:localhost::1234/db"
      },
      {
        "key": "D",
        "text": "sybase:localhost:1234/db"
      },
      {
        "key": "E",
        "text": "sybase::localhost::/db"
      },
      {
        "key": "F",
        "text": "sybase::localhost::1234/db"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "A JDBC URL has three main parts separated by single colons, making options B, C, E, \nand F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the \ncorrect answer is option A. Notice that you can get this right even if you’ve never heard of \nthe Sybase database before.\n"
  },
  {
    "id": "oca-338",
    "question": "Which of the options can fill in the blank to make the code compile and run without error? \n(Choose all that apply.)\nvar sql = \"\"\"\n   UPDATE habitat SET environment = null \n   WHERE environment = ? \"\"\";\ntry (var ps = conn.prepareStatement(sql)) {\n \n   \n \n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "ps.setString(0, \"snow\");"
      },
      {
        "key": "B",
        "text": "ps.setString(1, \"snow\");"
      },
      {
        "key": "C",
        "text": "ps.setString(\"environment\", \"snow\");"
      },
      {
        "key": "D",
        "text": "ps.setString(1, \"snow\"); ps.setString(1, \"snow\");"
      },
      {
        "key": "E",
        "text": "ps.setString(1, \"snow\"); ps.setString(2, \"snow\");"
      },
      {
        "key": "F",
        "text": "ps.setString(\"environment\", \"snow\"); ps.setString(\"environment\", \n\"snow\");"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "When setting parameters on a PreparedStatement, there are only options that \ntake an index, making options C and F incorrect. The indexing starts with 1, making option \nA incorrect. This query has only one parameter, so option E is also incorrect. Option B is \ncorrect because it simply sets the parameter. Option D is also correct because it sets the \nparameter and then immediately overwrites it with the same value.\n"
  },
  {
    "id": "oca-339",
    "question": "Suppose that you have a table named animal with two rows. What is the result of the fol-\nlowing code?\n6:  var conn = new Connection(url, userName, password);\n7:  var ps = conn.prepareStatement(\n8:     \"SELECT  count(*) FROM animal\");\n9:  var rs = ps.executeQuery();\n10: if (rs.next()) System.out.println(rs.getInt(1));",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "There is a compiler error on line 6."
      },
      {
        "key": "D",
        "text": "There is a compiler error on line 10."
      },
      {
        "key": "E",
        "text": "There is a compiler error on another line."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A Connection is created using a static method on DriverManager. It does not use \na constructor. Therefore, option C is correct. If the Connection was created properly, the \nanswer would be option B.\n"
  },
  {
    "id": "oca-340",
    "question": "Which option can fill in the blanks to make the code compile?\nboolean bool = ps. ();\nint num = ps. ();\nResultSet rs = ps. ();",
    "choices": [
      {
        "key": "A",
        "text": "execute, executeQuery, executeUpdate"
      },
      {
        "key": "B",
        "text": "execute, executeUpdate, executeQuery"
      },
      {
        "key": "C",
        "text": "executeQuery, execute, executeUpdate"
      },
      {
        "key": "D",
        "text": "executeQuery, executeUpdate, execute"
      },
      {
        "key": "E",
        "text": "executeUpdate, execute, executeQuery"
      },
      {
        "key": "F",
        "text": "executeUpdate, executeQuery, execute"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line has a return type of boolean, making it an execute() call. The second \nline returns the number of modified rows, making it an executeUpdate() call. The third \nline returns the results of a query, making it an executeQuery() call. Therefore, option B \nis the answer.\n"
  },
  {
    "id": "oca-341",
    "question": "Suppose there are two rows in the table before this code is run, and executeUpdate() runs \nwithout error. How many rows are in the table after the code completes?\nconn.setAutoCommit(true);\n \nString sql = \"INSERT INTO games VALUES(3, Jenga);\";\n \ntry (PreparedStatement ps = conn.prepareStatement(sql,\n   ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {\n   ps.executeUpdate();\n}\nconn.rollback();",
    "choices": [
      {
        "key": "A",
        "text": "Two"
      },
      {
        "key": "B",
        "text": "Three"
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "The code throws an exception."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first line enables autocommit mode. This is the default and means to commit immedi\u0002ately after each update. When the rollback() runs, there are no uncommitted statements, \nso there is nothing to roll back. This gives us the initial two rows in addition to the inserted \none making option B correct. If setAutoCommit(false) were called, option A would \nbe the answer. The ResultSet types are just there to mislead you. Any types are valid for \nexecuteUpdate() since no ResultSet is involved.\n"
  },
  {
    "id": "oca-342",
    "question": "Suppose that the table names has five rows and the following SQL statement updates all of \nthem. What is the result of this code?\npublic static void main(String[] args) throws SQLException {\n   var sql = \"UPDATE names SET name = 'Animal'\";\n   try (var conn = DriverManager.getConnection(\"jdbc:hsqldb:file:zoo\");\n      var ps = conn.prepareStatement(sql)) {\n \n      var result = ps.executeUpdate();\n      System.out.println(result);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code works as expected. It updates each of the five rows in the table and returns the \nnumber of rows updated. Therefore, option C is correct.\n"
  },
  {
    "id": "oca-343",
    "question": "Suppose learn() is a stored procedure that takes one IN parameter. What is wrong with \nthe following code? (Choose all that apply.)\n18: var sql = \"call learn()\";\n19: try (var cs = conn.prepareCall(sql)) {\n20:    cs.setString(1, \"java\");\n21:    try (var rs = cs.executeQuery()) {\n22:       while (rs.next())\n23:          System.out.println(rs.getString(3));\n24:    }\n25: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 18 is missing braces."
      },
      {
        "key": "B",
        "text": "Line 18 is missing a ?."
      },
      {
        "key": "C",
        "text": "Line 19 is not allowed to use var."
      },
      {
        "key": "D",
        "text": "Line 20 does not compile."
      },
      {
        "key": "E",
        "text": "Line 22 does not compile."
      },
      {
        "key": "F",
        "text": "Something else is wrong with the code."
      },
      {
        "key": "G",
        "text": "None of the above. This code is correct."
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Option A is one of the answers because you are supposed to use braces ({}) for all \nSQL in a CallableStatement. Option B is the other answer because each parameter \nshould be passed with a question mark (?). The rest of the code is correct. Note that your \ndatabase might not behave the way that’s described here, but you still need to know this \nsyntax for the exam.\n"
  },
  {
    "id": "oca-344",
    "question": "Suppose that the table enrichment has three rows with the animals bat, rat, and snake. How \nmany lines does this code print?\nvar sql = \"SELECT toy FROM enrichment WHERE animal = ?\";\ntry (var ps = conn.prepareStatement(sql)) {\n     try (var rs = ps.executeQuery()) {\n       while (rs.next())\n          System.out.println(rs.getString(1));\n     }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code declares a bind variable with ? but never assigns a value to it. The compiler \ndoes not enforce bind variables have values, so the code compiles, but produces a \nSQLException at runtime, making option E correct.\n"
  },
  {
    "id": "oca-345",
    "question": "Suppose that the table food has five rows, and this SQL statement updates all of them. What \nis the result of this code?\npublic static void main(String[] args) {\n   var sql = \"UPDATE food SET amount = amount + 1\";\n   try (var conn = DriverManager.getConnection(\"jdbc:hsqldb:file:zoo\");\n      var ps = conn.prepareStatement(sql)) {\n \n      var result = ps.executeUpdate();\n      System.out.println(result);\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A SQLException is thrown."
      },
      {
        "key": "F",
        "text": "A different exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC code throws a SQLException, which is a checked exception. The code does not \nhandle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t \ncompile, option D is correct. If the exception were handled or declared, the answer would be \noption C. \n"
  },
  {
    "id": "oca-346",
    "question": "Suppose we have a JDBC program that calls a stored procedure, which returns a set of \nresults. Which is the correct order in which to close database resources for this call?",
    "choices": [
      {
        "key": "A",
        "text": "Connection, ResultSet, CallableStatement"
      },
      {
        "key": "B",
        "text": "Connection, CallableStatement, ResultSet"
      },
      {
        "key": "C",
        "text": "ResultSet, Connection, CallableStatement"
      },
      {
        "key": "D",
        "text": "ResultSet, CallableStatement, Connection"
      },
      {
        "key": "E",
        "text": "CallableStatement, Connection, ResultSet"
      },
      {
        "key": "F",
        "text": "CallableStatement, ResultSet, Connection"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "JDBC resources should be closed in the reverse order from that in which they were \nopened. The order for opening is Connection, CallableStatement, and ResultSet. \nThe order for closing is ResultSet, CallableStatement, and Connection, which \nis option D.\n"
  },
  {
    "id": "oca-347",
    "question": "Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does \nthis code print?\nvar sql = \"SELECT num FROM counts WHERE num> ?\";\ntry (var ps = conn.prepareStatement(sql,\n   ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)) {\n   ps.setInt(1, 3);\n \n   try (var rs = ps.executeQuery()) {\n   while (rs.next())\n      System.out.println(rs.getObject(1));\n   }\n \n   ps.setInt(1, 100);\n \n    try (var rs = ps.executeQuery()) {\n     while (rs.next())\n        System.out.println(rs.getObject(1));\n     }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code throws an exception."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. The second time, it gets \nthe numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two \nlines are printed in total, making option C correct. The ResultSet options are just there to \ntrick you since only the default settings are used by the rest of the code.\n"
  },
  {
    "id": "oca-348",
    "question": "Which of the following can fill in the blank correctly? (Choose all that apply.)\nvar rs = ps.executeQuery();\nif (rs.next())\n   ;",
    "choices": [
      {
        "key": "A",
        "text": "String s = rs.getString(0)"
      },
      {
        "key": "B",
        "text": "String s = rs.getString(1)"
      },
      {
        "key": "C",
        "text": "String s = rs.getObject(0)"
      },
      {
        "key": "D",
        "text": "String s = rs.getObject(1)"
      },
      {
        "key": "E",
        "text": "Object s = rs.getObject(0)"
      },
      {
        "key": "F",
        "text": "Object s = rs.getObject(1)"
      }
    ],
    "answer": [
      "B",
      "F"
    ],
    "explanation": "In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, \nand E are incorrect. There are methods to get the column as a String or Object. However, \noption D is incorrect because an Object cannot be assigned to a String without a cast.\n"
  },
  {
    "id": "oca-349",
    "question": "Suppose learn() is a stored procedure that takes one IN parameter and one OUT param-\neter. What is wrong with the following code? (Choose all that apply.)\n18: var sql = \"{?= call learn(?)}\";\n19: try (var cs = conn.prepareCall(sql)) {\n20:    cs.setInt(1, 8);\n21:    cs.execute();\n22:    System.out.println(cs.getInt(1));\n23: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 18 does not call the stored procedure properly."
      },
      {
        "key": "B",
        "text": "The parameter value is not set for input."
      },
      {
        "key": "C",
        "text": "The parameter is not registered for output."
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "Something else is wrong with the code."
      },
      {
        "key": "F",
        "text": "None of the above. This code is correct."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Since an OUT parameter is used, the code should call registerOutParameter(). Since \nthis is missing, option C is correct.\n"
  },
  {
    "id": "oca-350",
    "question": "Which can fill in the blank and have the code run without error? (Choose all that apply.)\n17: conn.setAutoCommit(false);\n18: \n19: var larry = conn.setSavepoint();\n20: var curly = conn.setSavepoint();\n21: var moe = conn.setSavepoint();\n22: var shemp = conn.setSavepoint();\n23:\n24: ;\n25:\n26: conn.rollback(curly);",
    "choices": [
      {
        "key": "A",
        "text": "conn.rollback(larry)"
      },
      {
        "key": "B",
        "text": "conn.rollback(curly)"
      },
      {
        "key": "C",
        "text": "conn.rollback(moe)"
      },
      {
        "key": "D",
        "text": "conn.rollback(shemp)"
      },
      {
        "key": "E",
        "text": "conn.rollback()"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Rolling back to a point invalidates any savepoints created after it. Options A and E are \nincorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because \nyou cannot roll back to the same savepoint twice. Options C and D are the answers because \nthose savepoints were created after curly.\n"
  },
  {
    "id": "oca-351",
    "question": "Which of the following can fill in the blank? (Choose all that apply.)\nvar sql = \" \";\ntry (var ps = conn.prepareStatement(sql)) {\n   ps.setObject(3, \"red\");\n   ps.setInt(2, 8);\n   ps.setString(1, \"ball\");\n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "{ call insert_toys(?, ?) }"
      },
      {
        "key": "B",
        "text": "{ call insert_toys(?, ?, ?) }"
      },
      {
        "key": "C",
        "text": "{ call insert_toys(?, ?, ?, ?) }"
      },
      {
        "key": "D",
        "text": "INSERT INTO toys VALUES (?, ?)"
      },
      {
        "key": "E",
        "text": "INSERT INTO toys VALUES (?, ?, ?)"
      },
      {
        "key": "F",
        "text": "INSERT INTO toys VALUES (?, ?, ?, ?)"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "First, notice that this code uses a PreparedStatement. Options A, B, and C are incor\u0002rect because they are for a CallableStatement. Next, remember that the number of \nparameters must be an exact match, making option E correct. Remember that you will not be \ntested on SQL syntax. When you see a question that appears to be about SQL, think about \nwhat it might be trying to test you on.\n"
  },
  {
    "id": "oca-352",
    "question": "Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does \nthis code print?\nvar sql = \"SELECT num FROM counts WHERE num> ?\";\ntry (var ps = conn.prepareStatement(sql)) {\n   ps.setInt(1, 3);\n \n   try (var rs = ps.executeQuery()) {\n      while (rs.next())\n         System.out.println(rs.getObject(1));\n   }\n   try (var rs = ps.executeQuery()) {\n      while (rs.next())\n         System.out.println(rs.getObject(1));\n   }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "The code throws an exception."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "This code calls the PreparedStatement twice. The first time, it gets the numbers \ngreater than 3. Since there are two such numbers, it prints two lines. Since the parameter is \nnot set between the first and second calls, the second attempt also prints two rows. Four lines \nare printed in total, making option D correct.\n"
  },
  {
    "id": "oca-353",
    "question": "There are currently 100 rows in the table species before inserting a new row. What is the \noutput of the following code?\nString insert = \"INSERT INTO species VALUES (3, 'Ant', .05)\";\nString select = \"SELECT count(*) FROM species\";\ntry (var ps = conn.prepareStatement(insert)) {\n   ps.executeUpdate();\n}\ntry (var ps = conn.prepareStatement(select)) {\n   var rs = ps.executeQuery();\n   System.out.println(rs.getInt(1));\n}",
    "choices": [
      {
        "key": "A",
        "text": "100"
      },
      {
        "key": "B",
        "text": "101"
      },
      {
        "key": "C",
        "text": "The code does not compile."
      },
      {
        "key": "D",
        "text": "A SQLException is thrown."
      },
      {
        "key": "E",
        "text": "A different exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Before accessing data from a ResultSet, the cursor needs to be positioned. The call to \nrs.next() is missing from this code causing a SQLException and option D to be correct.\n"
  },
  {
    "id": "oca-354",
    "question": "Which of the options can fill in the blank to make the code compile and run without error? \n(Choose all that apply.)\nvar sql = \"UPDATE habitat WHERE environment = ?\";\ntry (var ps = conn.prepareCall(sql)) {\n \n   \n \n   ps.executeUpdate();\n}",
    "choices": [
      {
        "key": "A",
        "text": "ps.setString(0, \"snow\");"
      },
      {
        "key": "B",
        "text": "ps.setString(1, \"snow\");"
      },
      {
        "key": "C",
        "text": "ps.setString(\"environment\", \"snow\");"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "The code throws an exception at runtime."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This code should call prepareStatement() instead of prepareCall() since it is not \nexecuting a stored procedure. Since we are using var, it does compile. Java will happily cre\u0002ate a CallableStatement for you. Since this compile safety is lost, the code will not cause \nissues until runtime. At that point, Java will complain that you are trying to execute SQL as if \nit were a stored procedure, making option E correct.\n"
  },
  {
    "id": "oca-355",
    "question": "Which is the first line containing a compiler error?\n25: String url = \"jdbc:hsqldb:file:zoo\";\n26: try (var conn = DriverManager.getConnection(url);\n27:    var ps = conn.prepareStatement();\n28:    var rs = ps.executeQuery(\"SELECT * FROM swings\")) {\n29:    while (rs.next()) {\n30:       System.out.println(rs.getInteger(1));\n31:    }\n32: }",
    "choices": [
      {
        "key": "A",
        "text": "Line 26"
      },
      {
        "key": "B",
        "text": "Line 27"
      },
      {
        "key": "C",
        "text": "Line 28"
      },
      {
        "key": "D",
        "text": "Line 29"
      },
      {
        "key": "E",
        "text": "Line 30"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The prepareStatement() method requires SQL to be passed in. Since this parameter \nis omitted, line 27 does not compile, and option B is correct. \n"
  },
  {
    "id": "oca-356",
    "question": "Suppose conn is a valid connection object and the exhibits table is empty. Which are true? \n(Choose all that apply.)\ntry (conn) {\n   conn.setAutoCommit(false);\n \n  String sql = \"INSERT INTO exhibits VALUES(3, 'Test', 2)\";\n   try (PreparedStatement ps = conn.prepareStatement(sql)) {\n      ps.executeUpdate();\n  }\n \n   conn.setAutoCommit(true);   // line W\n}",
    "choices": [
      {
        "key": "A",
        "text": "As written, the table will remain empty after this code."
      },
      {
        "key": "B",
        "text": "As written, the table will contain one row after this code."
      },
      {
        "key": "C",
        "text": "As written, the code will throw an exception."
      },
      {
        "key": "D",
        "text": "When line W is commented out, the table will remain empty after this code."
      },
      {
        "key": "E",
        "text": "When line W is commented out, the table will contain one row after this code."
      },
      {
        "key": "F",
        "text": "When line W is commented out, the code will throw an exception."
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The code starts with autocommit off. As written, we turn autocommit mode back on \nand immediately commit the transaction. This is option B. When line W is commented out, \nthe update gets lost, making option D the other answer."
  }
]