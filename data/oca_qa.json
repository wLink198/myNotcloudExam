[
  {
    "id": "oca-1",
    "question": "Which of the following are valid Java identifiers? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A$B"
      },
      {
        "key": "B",
        "text": "_helloWorld"
      },
      {
        "key": "C",
        "text": "true"
      },
      {
        "key": "D",
        "text": "java.lang"
      },
      {
        "key": "E",
        "text": "Public"
      },
      {
        "key": "F",
        "text": "1980_s"
      }
    ],
    "answer": [
      "A",
      "B",
      "E"
    ],
    "explanation": "Option A is valid because you can use the dollar sign in identifiers. Option B is \nvalid because you can use an underscore in identifiers. Option C is not a valid identifier \nbecause true is a Java reserved word. Option D is not valid because the dot (.) is not \nallowed in identifiers. Option E is valid because Java is case sensitive, so Public is not \na reserved word and therefore a valid identifier. Option F is not valid because the first \ncharacter is not a letter, $, or _.\n"
  },
  {
    "id": "oca-2",
    "question": "What is the output of the following program?\npublic class WaterBottle {\n    private String brand;\n    private boolean empty;\n\n    public static void main(String[] args) {\n        WaterBottle wb = new WaterBottle();\n        System.out.print(\"Empty = \" + wb.empty);\n        System.out.print(\", Brand = \" + wb.brand);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Line 6 generates a compiler error"
      },
      {
        "key": "B",
        "text": "Line 7 generates a compiler error"
      },
      {
        "key": "C",
        "text": "There is no output"
      },
      {
        "key": "D",
        "text": "Empty = false, Brand = null"
      },
      {
        "key": "E",
        "text": "Empty = false, Brand ="
      },
      {
        "key": "F",
        "text": "Empty = null, Brand = null"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Boolean fields initialize to false and references initialize to null, so empty is false\nand brand is null. Brand = null is output. \n"
  },
  {
    "id": "oca-3",
    "question": "Which of the following are true? (Choose all that apply.)\nshort numPets = 5;\nint numGrains = 5.6;\nString name = \"Scruffy\";\nnumPets.length();\nnumGrains.length();\nname.length();",
    "choices": [
      {
        "key": "A",
        "text": "Line 4 generates a compiler error"
      },
      {
        "key": "B",
        "text": "Line 5 generates a compiler error"
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error"
      },
      {
        "key": "D",
        "text": "Line 7 generates a compiler error"
      },
      {
        "key": "E",
        "text": "Line 8 generates a compiler error"
      },
      {
        "key": "F",
        "text": "Line 9 generates a compiler error"
      },
      {
        "key": "G",
        "text": "The code compiles as is"
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Option A (line 4) compiles because short is an integral type. Option B (line \n5) generates a compiler error because int is an integral type, but 5.6 is a floating-point \ntype. Option C (line 6) compiles because it is assigned a String. Options D and E (lines \n7 and 8) do not compile because short and int are primitives. Primitives do not allow \nmethods to be called on them. Option F (line 9) compiles because length() is defined \non String.\n"
  },
  {
    "id": "oca-4",
    "question": "Given the following class, which statements are true?\npublic class Snake {\n    public void shed(boolean time) {\n        if (time) {\n        }\n        System.out.println(result);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "If String result = \"done\"; is inserted on line 2, the code will compile"
      },
      {
        "key": "B",
        "text": "If inserted on line 4"
      },
      {
        "key": "C",
        "text": "If inserted on line 6"
      },
      {
        "key": "D",
        "text": "If inserted on line 9"
      },
      {
        "key": "E",
        "text": "None of the above changes will make the code compile"
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Adding the variable at line 2 makes result an instance variable. Since instance \nvariables are in scope for the entire life of the object, option A is correct. Option B is \ncorrect because adding the variable at line 4 makes result a local variable with a scope \nof the whole method. Adding the variable at line 6 makes result a local variable with \na scope of lines 6–7. Since it is out of scope on line 8, the println does not compile and \noption C is incorrect. Adding the variable at line 9 makes result a local variable with \na scope of lines 9 and 10. Since line 8 is before the declaration, it does not compile and \noption D is incorrect. Finally, option E is incorrect because the code can be made to \ncompile.\n"
  },
  {
    "id": "oca-5",
    "question": "Given the following classes, which imports make the code compile?\npackage aquarium;\npublic class Tank { }\n\npackage aquarium.jellies;\npublic class Jelly { }\n\npackage visitor;\n// INSERT IMPORTS HERE\npublic class AquariumVisitor {\n    public void admire(Jelly jelly) { }\n}",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.*.Jelly;"
      },
      {
        "key": "C",
        "text": "import aquarium.jellies.Jelly;"
      },
      {
        "key": "D",
        "text": "import aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.jellies.Jelly.*;"
      },
      {
        "key": "F",
        "text": "None of these"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Option C is correct because it imports Jelly by classname. Option D is cor\u0002rect because it imports all the classes in the jellies package, which includes Jelly. \nOption A is incorrect because it only imports classes in the aquarium package—Tank\nin this case—and not those in lower-level packages. Option B is incorrect because you \ncannot use wildcards anyplace other than the end of an import statement. Option E is \nincorrect because you cannot import parts of a class with a regular import statement. \nOption F is incorrect because options C and D do make the code compile.\n"
  },
  {
    "id": "oca-6",
    "question": "What is the maximum number of imports that can be removed?\npackage aquarium;\nimport java.lang.*;\nimport java.lang.System;\nimport aquarium.Water;\nimport aquarium.*;\n\npublic class Tank {\n    public void print(Water water) {\n        System.out.println(water);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The first two imports can be removed because java.lang is automatically imported. \nThe second two imports can be removed because Tank and Water are in the same pack\u0002age, making the correct answer E. If Tank and Water were in different packages, one of \nthese two imports could be removed. In that case, the answer would be option D. \n"
  },
  {
    "id": "oca-7",
    "question": "Which of the following import snippets make the code compile?\npackage aquarium;\npublic class Water { boolean salty = false; }\n\npackage aquarium.jellies;\npublic class Water { boolean salty = true; }\n\npackage employee;\n// INSERT IMPORTS HERE\npublic class WaterFiller {\n    Water water;\n}",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.Water; and import aquarium.jellies.*;"
      },
      {
        "key": "C",
        "text": "import aquarium.*; and import aquarium.jellies.Water;"
      },
      {
        "key": "D",
        "text": "import aquarium.*; and import aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.Water; and import aquarium.jellies.Water;"
      },
      {
        "key": "F",
        "text": "None of these"
      }
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Option A is correct because it imports all the classes in the aquarium package \nincluding aquarium.Water. Options B and C are correct because they import Water by \nclassname. Since importing by classname takes precedence over wildcards, these com\u0002pile. Option D is incorrect because Java doesn’t know which of the two wildcard Water\nclasses to use. Option E is incorrect because you cannot specify the same classname in \ntwo imports. \n"
  },
  {
    "id": "oca-8",
    "question": "Which calls print out \"Blue Jay\"?\npublic class BirdDisplay {\n    public static void main(String[] name) {\n        System.out.println(name[1]);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "java BirdDisplay Sparrow Blue Jay"
      },
      {
        "key": "B",
        "text": "java BirdDisplay Sparrow \"Blue Jay\""
      },
      {
        "key": "C",
        "text": "java BirdDisplay Blue Jay Sparrow"
      },
      {
        "key": "D",
        "text": "java BirdDisplay \"Blue Jay\" Sparrow"
      },
      {
        "key": "E",
        "text": "java BirdDisplay.class Sparrow \"Blue Jay\""
      },
      {
        "key": "F",
        "text": "java BirdDisplay.class \"Blue Jay\" Sparrow"
      },
      {
        "key": "G",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Option B is correct because arrays start counting from zero and strings with spaces \nmust be in quotes. Option A is incorrect because it outputs Blue. C is incorrect because \nit outputs Jay. Option D is incorrect because it outputs Sparrow. Options E and F are \nincorrect because they output Error: Could not find or load main class Bird\u0002Display.class.\n"
  },
  {
    "id": "oca-9",
    "question": "Legal main method declarations (Choose all that apply.)\npublic static void main( )",
    "choices": [
      {
        "key": "A",
        "text": "String[] _names"
      },
      {
        "key": "B",
        "text": "String[] 123"
      },
      {
        "key": "C",
        "text": "String abc[]"
      },
      {
        "key": "D",
        "text": "String _Names[]"
      },
      {
        "key": "E",
        "text": "String... $n"
      },
      {
        "key": "F",
        "text": "String names"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "Option A is correct because it is the traditional main() method signature \nand variables may begin with underscores. Options C and D are correct because the \narray operator may appear after the variable name. Option E is correct because \nvarargs are allowed in place of an array. Option B is incorrect because variables are \nnot allowed to begin with a digit. Option F is incorrect because the argument must be \nan array or varargs. Option F is a perfectly good method. However, it is not one that \ncan be run from the command line because it has the wrong parameter type. \n"
  },
  {
    "id": "oca-10",
    "question": "Legal entry points (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "private static void main(String[] args)"
      },
      {
        "key": "B",
        "text": "public static final main(String[] args)"
      },
      {
        "key": "C",
        "text": "public void main(String[] args)"
      },
      {
        "key": "D",
        "text": "public static void test(String[] args)"
      },
      {
        "key": "E",
        "text": "public static void main(String[] args)"
      },
      {
        "key": "F",
        "text": "public static main(String[] args)"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Option E is the canonical main() method signature. You need to memorize it. \nOption A is incorrect because the main() method must be public. Options B and F \nare incorrect because the main() method must have a void return type. Option C is \nincorrect because the main() method must be static. Option D is incorrect because the \nmain() method must be named main. \n"
  },
  {
    "id": "oca-11",
    "question": "Which are true about instance variable defaults?",
    "choices": [
      {
        "key": "A",
        "text": "double → null"
      },
      {
        "key": "B",
        "text": "int → null"
      },
      {
        "key": "C",
        "text": "String → null"
      },
      {
        "key": "D",
        "text": "double → 0.0"
      },
      {
        "key": "E",
        "text": "int → 0.0"
      },
      {
        "key": "F",
        "text": "String → 0.0"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Option C is correct because all non-primitive values default to null. Option D is \ncorrect because float and double primitives default to 0.0. Options B and E are incor\u0002rect because int primitives default to 0.\n"
  },
  {
    "id": "oca-12",
    "question": "Which are true about local variable defaults?",
    "choices": [
      {
        "key": "A",
        "text": "boolean → null"
      },
      {
        "key": "B",
        "text": "float → 0"
      },
      {
        "key": "C",
        "text": "Object → null"
      },
      {
        "key": "D",
        "text": "boolean → false"
      },
      {
        "key": "E",
        "text": "boolean → true"
      },
      {
        "key": "F",
        "text": "float → 0.0"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "Option G is correct because local variables do not get assigned default values. The \ncode fails to compile if a local variable is not explicitly initialized. If this question \nwere about instance variables, options D and F would be correct. A boolean primitive \ndefaults to false and a float primitive defaults to 0.0.\n"
  },
  {
    "id": "oca-13",
    "question": "Which are true about instance variables?",
    "choices": [
      {
        "key": "A",
        "text": "boolean → false"
      },
      {
        "key": "B",
        "text": "boolean → true"
      },
      {
        "key": "C",
        "text": "boolean → null"
      },
      {
        "key": "D",
        "text": "int → 0"
      },
      {
        "key": "E",
        "text": "int → 0.0"
      },
      {
        "key": "F",
        "text": "int → null"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Options A and D are correct because boolean primitives default to false and \nint primitives default to 0. \n"
  },
  {
    "id": "oca-14",
    "question": "File: /my/directory/named/A/Bird.java. What goes at top?",
    "choices": [
      {
        "key": "A",
        "text": "package my.directory.named.a;"
      },
      {
        "key": "B",
        "text": "package my.directory.named.A;"
      },
      {
        "key": "C",
        "text": "package named.a;"
      },
      {
        "key": "D",
        "text": "package named.A;"
      },
      {
        "key": "E",
        "text": "package a;"
      },
      {
        "key": "F",
        "text": "package A;"
      },
      {
        "key": "G",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The package name represents any folders underneath the current path, which is \nnamed.A in this case. Option B is incorrect because package names are case sensitive, \njust like variable names and other identifiers.\n"
  },
  {
    "id": "oca-15",
    "question": "Which lines compile?",
    "choices": [
      {
        "key": "A",
        "text": "int i1 = 1_234;"
      },
      {
        "key": "B",
        "text": "double d1 = 1_234_.0;"
      },
      {
        "key": "C",
        "text": "double d2 = 1_234._0;"
      },
      {
        "key": "D",
        "text": "double d3 = 1_234.0_;"
      },
      {
        "key": "E",
        "text": "double d4 = 1_234.0;"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Underscores are allowed as long as they are directly between two other digits. \nThis means options A and E are correct. Options B and C are incorrect because the \nunderscore is adjacent to the decimal point. Option D is incorrect because the under\u0002score is the last character. \n"
  },
  {
    "id": "oca-16",
    "question": "What can replace INSERT CODE HERE?\npublic class Price {\n    public void admission() {\n        INSERT CODE HERE\n        System.out.println(amount);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "int amount = 9L;"
      },
      {
        "key": "B",
        "text": "int amount = 0b101;"
      },
      {
        "key": "C",
        "text": "int amount = 0xE;"
      },
      {
        "key": "D",
        "text": "double amount = 0xE;"
      },
      {
        "key": "E",
        "text": "double amount = 1_2_.0_0;"
      },
      {
        "key": "F",
        "text": "int amount = 1_2_;"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "C",
      "D"
    ],
    "explanation": "0b is the prefix for a binary value and is correct. 0x is the prefix for a hexa\u0002decimal value. This value can be assigned to many primitive types, including int and \ndouble, making options C and D correct. Option A is incorrect because 9L is a long \nvalue. long amount = 9L would be allowed. Option E is incorrect because the under\u0002score is immediately before the decimal. Option F is incorrect because the underscore is \nthe very last character.\n"
  },
  {
    "id": "oca-17",
    "question": "Which are true?\npublic class Bunny {\n    public static void main(String[] args) {\n        Bunny bun = new Bunny();\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Bunny is a class"
      },
      {
        "key": "B",
        "text": "bun is a class"
      },
      {
        "key": "C",
        "text": "main is a class"
      },
      {
        "key": "D",
        "text": "Bunny is a reference to an object"
      },
      {
        "key": "E",
        "text": "bun is a reference to an object"
      },
      {
        "key": "F",
        "text": "main is a reference to an object"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Bunny is a class, which can be seen from the declaration: public class Bunny. bun\nis a reference to an object. main() is a method.\n"
  },
  {
    "id": "oca-18",
    "question": "Which order compiles successfully?\nStatements:\n\nA: class Rabbit {}\n\nB: import java.util.*;\n\nC: package animals;",
    "choices": [
      {
        "key": "A",
        "text": "A, B, C"
      },
      {
        "key": "B",
        "text": "B, C, A"
      },
      {
        "key": "C",
        "text": "C, B, A"
      },
      {
        "key": "D",
        "text": "B, A"
      },
      {
        "key": "E",
        "text": "C, A"
      },
      {
        "key": "F",
        "text": "A, C"
      },
      {
        "key": "G",
        "text": "A, B"
      }
    ],
    "answer": [
      "C",
      "D",
      "E"
    ],
    "explanation": "package and import are both optional. If both are present, the order must \nbe package, then import, then class. Option A is incorrect because class is before \npackage and import. Option B is incorrect because import is before package. Option \nF is incorrect because class is before package. Option G is incorrect because class is \nbefore import.\n"
  },
  {
    "id": "oca-19",
    "question": "Which statements are true about garbage collection?\npublic class Rabbit {\n    public static void main(String[] args) {\n        Rabbit one = new Rabbit();\n        Rabbit two = new Rabbit();\n        Rabbit three = one;\n        one = null;\n        Rabbit four = one;\n        three = null;\n        two = null;\n        two = new Rabbit();\n        System.gc();\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Line 3's object eligible after line 6"
      },
      {
        "key": "B",
        "text": "Line 3's object eligible after line 8"
      },
      {
        "key": "C",
        "text": "Line 3's object eligible after line 12"
      },
      {
        "key": "D",
        "text": "Line 4's object eligible after line 9"
      },
      {
        "key": "E",
        "text": "Line 4's object eligible after line 11"
      },
      {
        "key": "F",
        "text": "Line 4's object eligible after line 12"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The Rabbit object from line 3 has two references to it: one and three. The ref\u0002erences are nulled out on lines 6 and 8, respectively. Option B is correct because this \nmakes the object eligible for garbage collection after line 8. Line 7 sets the reference \nfour to the now null one, which means it has no effect on garbage collection. The Rab\u0002bit object from line 4 only has a single reference to it: two. Option D is correct because \nthis single reference becomes null on line 9. The Rabbit object declared on line 10 \nbecomes eligible for garbage collection at the end of the method on line 12. Calling \nSystem.gc() has no effect on eligibility for garbage collection.\n"
  },
  {
    "id": "oca-20",
    "question": "What is true about this code?\npublic class Bear {\n    protected void finalize() {\n        System.out.println(\"Roar!\");\n    }\n\n    public static void main(String[] args) {\n        Bear bear = new Bear();\n        bear = null;\n        System.gc();\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "finalize() is guaranteed to be called"
      },
      {
        "key": "B",
        "text": "Might or might not be called"
      },
      {
        "key": "C",
        "text": "Guaranteed not to be called"
      },
      {
        "key": "D",
        "text": "Garbage collection is guaranteed to run"
      },
      {
        "key": "E",
        "text": "Might or might not run"
      },
      {
        "key": "F",
        "text": "Guaranteed not to run"
      },
      {
        "key": "G",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Calling System.gc() suggests that Java might wish to run the garbage collector. \nJava is free to ignore the request, making option E correct. finalize() runs if an object \nattempts to be garbage collected, making option B correct.\n"
  },
  {
    "id": "oca-21",
    "question": "What is the output?\npublic class Salmon {\n    int count;\n    public void Salmon() {\n        count = 4;\n    }\n\n    public static void main(String[] args) {\n        Salmon s = new Salmon();\n        System.out.println(s.count);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "Compilation fails on line 3"
      },
      {
        "key": "D",
        "text": "Compilation fails on line 4"
      },
      {
        "key": "E",
        "text": "Compilation fails on line 7"
      },
      {
        "key": "F",
        "text": "Compilation fails on line 8"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "While the code on line 3 does compile, it is not a constructor because it has a return \ntype. It is a method that happens to have the same name as the class. When the code \nruns, the default constructor is called and count has the default value (0) for an int.\n"
  },
  {
    "id": "oca-22",
    "question": "Which are true statements?",
    "choices": [
      {
        "key": "A",
        "text": "Java allows operator overloading"
      },
      {
        "key": "B",
        "text": "Java code compiled on Windows can run on Linux"
      },
      {
        "key": "C",
        "text": "Java has pointers"
      },
      {
        "key": "D",
        "text": "Java is procedural"
      },
      {
        "key": "E",
        "text": "Java is object-oriented"
      },
      {
        "key": "F",
        "text": "Java is a functional programming language"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "C++ has operator overloading and pointers. Java made a point of not having \neither. Java does have references to objects, but these are pointing to an object that can \nmove around in memory. Option B is correct because Java is platform independent. \nOption E is correct because Java is object oriented. While it does support some parts of \nfunctional programming, these occur within a class.\n"
  },
  {
    "id": "oca-23",
    "question": "Which are true?",
    "choices": [
      {
        "key": "A",
        "text": "javac compiles .class to .java"
      },
      {
        "key": "B",
        "text": "javac compiles .java to .bytecode"
      },
      {
        "key": "C",
        "text": "javac compiles .java to .class"
      },
      {
        "key": "D",
        "text": "java takes class name as parameter"
      },
      {
        "key": "E",
        "text": "java takes .bytecode name as parameter"
      },
      {
        "key": "F",
        "text": "java takes .class name as parameter"
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Java puts source code in .java files and bytecode in .class files. It does not use \na .bytecode file. When running a Java program, you pass just the name of the class \nwithout the .class extension.\n"
  },
  {
    "id": "oca-24",
    "question": "Which of the following Java operators can be used with boolean variables? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "=="
      },
      {
        "key": "B",
        "text": "+"
      },
      {
        "key": "C",
        "text": "--"
      },
      {
        "key": "D",
        "text": "!"
      },
      {
        "key": "E",
        "text": "%"
      },
      {
        "key": "F",
        "text": "<="
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Option A is the equality operator and can be used on numeric primitives, bool\u0002ean values, and object references. Options B and C are both arithmetic operators and \ncannot be applied to a boolean value. Option D is the logical complement operator \nand is used exclusively with boolean values. Option E is the modulus operator, which \ncan only be used with numeric primitives. Finally, option F is a relational operator that \ncompares the values of two numbers.\n"
  },
  {
    "id": "oca-25",
    "question": "What data type(s) will allow the following code to compile? (Choose all that apply.)\n\nbyte x = 5;\nbyte y = 10;\n_____ z = x + y;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "long"
      },
      {
        "key": "C",
        "text": "boolean"
      },
      {
        "key": "D",
        "text": "double"
      },
      {
        "key": "E",
        "text": "short"
      },
      {
        "key": "F",
        "text": "byte"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "The value x + y is automatically promoted to int, so int and data types that \ncan be promoted automatically from int will work. Options A, B, D are such data \ntypes. Option C will not work because boolean is not a numeric data type. Options E \nand F will not work without an explicit cast to a smaller data type.\n"
  },
  {
    "id": "oca-26",
    "question": "What is the output of the following application?\n\npublic class CompareValues {\n    public static void main(String[] args) {\n        int x = 0;\n        while(x++ < 10) {}\n        String message = x > 10 ? \"Greater than\" : false;\n        System.out.println(message + \",\" + x);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Greater than,10"
      },
      {
        "key": "B",
        "text": "false,10"
      },
      {
        "key": "C",
        "text": "Greater than,11"
      },
      {
        "key": "D",
        "text": "false,11"
      },
      {
        "key": "E",
        "text": "Does not compile (line 4)"
      },
      {
        "key": "F",
        "text": "Does not compile (line 5)"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "In this example, the ternary operator has two expressions, one of them a String and \nthe other a boolean value. The ternary operator is permitted to have expressions that \ndon’t have matching types, but the key here is the assignment to the String reference. \nThe compiler knows how to assign the first expression value as a String, but the sec\u0002ond boolean expression cannot be set as a String; therefore, this line will not compile.\n"
  },
  {
    "id": "oca-27",
    "question": "What change would allow this code to compile? (Choose all that apply.)\n\nlong x = 10;\nint y = 2 * x;",
    "choices": [
      {
        "key": "A",
        "text": "No change"
      },
      {
        "key": "B",
        "text": "Cast x to int"
      },
      {
        "key": "C",
        "text": "Change x to short"
      },
      {
        "key": "D",
        "text": "Cast 2 * x to int"
      },
      {
        "key": "E",
        "text": "Change y to short"
      },
      {
        "key": "F",
        "text": "Change y to long"
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The code will not compile as is, so option A is not correct. The value 2 * x\nis automatically promoted to long and cannot be automatically stored in y, which is \nin an int value. Options B, C, and D solve this problem by reducing the long value to \nint. Option E does not solve the problem and actually makes it worse by attempting \nto place the value in a smaller data type. Option F solves the problem by increasing the \ndata type of the assignment so that long is allowed.\n"
  },
  {
    "id": "oca-28",
    "question": "What is the output?\n\nList<Integer> list = new ArrayList<>();\nlist.add(10);\nlist.add(14);\nfor (int x : list) {\n    System.out.print(x + \", \");\n    break;\n}",
    "choices": [
      {
        "key": "A",
        "text": "10, 14,"
      },
      {
        "key": "B",
        "text": "10, 14"
      },
      {
        "key": "C",
        "text": "10,"
      },
      {
        "key": "D",
        "text": "Does not compile (line 7)"
      },
      {
        "key": "E",
        "text": "Does not compile (line 8)"
      },
      {
        "key": "F",
        "text": "Infinite loop"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code does not contain any compilation errors or an infinite loop, so options D, \nE, and F are incorrect. The break statement on line 8 causes the loop to execute once \nand finish, so option C is the correct answer.\n"
  },
  {
    "id": "oca-29",
    "question": "What is the output?\n\nint x = 4;\nlong y = x * 4 - x++;\nif (y < 10)\n    System.out.println(\"Too Low\");\nelse\n    System.out.println(\"Just right\");\nelse\n    System.out.println(\"Too High\");",
    "choices": [
      {
        "key": "A",
        "text": "Too Low"
      },
      {
        "key": "B",
        "text": "Just Right"
      },
      {
        "key": "C",
        "text": "Too High"
      },
      {
        "key": "D",
        "text": "Compiles but throws exception"
      },
      {
        "key": "E",
        "text": "Does not compile (line 6)"
      },
      {
        "key": "F",
        "text": "Does not compile (line 7)"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because two else statements cannot be chained together \nwithout additional if-then statements, so the correct answer is option F. Option E is \nincorrect as Line 6 by itself does not cause a problem, only when it is paired with Line \n\"7'. One way to fix this code so it compiles would be to add an if-then statement on \nline 6. The other solution would be to remove line 7.\n"
  },
  {
    "id": "oca-30",
    "question": "What is the output?\n\nint x = 5;\nSystem.out.println(x > 2 ? x < 4 ? 10 : 8 : 7);",
    "choices": [
      {
        "key": "A",
        "text": "5"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "7"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "As you learned in the section “Ternary Operator,” although parentheses are not \nrequired, they do greatly increase code readability, such as the following equivalent \nstatement:\nSystem.out.println((x > 2) ? ((x < 4) ? 10 : 8) : 7)\nWe apply the outside ternary operator fi rst, as it is possible the inner ternary expression \nmay never be evaluated. Since (x>2) is true, this reduces the problem to:\nSystem.out.println((x < 4) ? 10 : 8)\nSince x is greater than 2, the answer is 8, or option D in this case.\n"
  },
  {
    "id": "oca-31",
    "question": "What is the output?\n\nboolean x = true, z = true;\nint y = 20;\nx = (y != 10) ^ (z = false);\nSystem.out.println(x + \", \" + y + \", \" + z);",
    "choices": [
      {
        "key": "A",
        "text": "true, 10, true"
      },
      {
        "key": "B",
        "text": "true, 20, false"
      },
      {
        "key": "C",
        "text": "false, 20, true"
      },
      {
        "key": "D",
        "text": "false, 20, false"
      },
      {
        "key": "E",
        "text": "false, 20, true"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This example is tricky because of the second assignment operator embedded in line \n\"5\". The expression (z=false) assigns the value false to z and returns false for the \nentire expression. Since y does not equal 10, the left-hand side returns true; therefore, \nthe exclusive or (^) of the entire expression assigned to x is true. The output reflects \nthese assignments, with no change to y, so option B is the only correct answer. The \ncode compiles and runs without issue, so option F is not correct.\n"
  },
  {
    "id": "oca-32",
    "question": "How many times does it print \"Hello World\"?\n\nfor (int i = 0; i < 10; ) {\n    i = i++;\n    System.out.println(\"Hello World\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "9"
      },
      {
        "key": "B",
        "text": "10"
      },
      {
        "key": "C",
        "text": "11"
      },
      {
        "key": "D",
        "text": "Does not compile"
      },
      {
        "key": "E",
        "text": "Does not compile (line 5)"
      },
      {
        "key": "F",
        "text": "Infinite loop"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "In this example, the update statement of the for loop is missing, which is fine as the \nstatement is optional, so option D is incorrect. The expression inside the loop incre\u0002ments i but then assigns i the old value. Therefore, i ends the loop with the same value \nthat it starts with: 0. The loop will repeat infinitely, outputting the same statement over \nand over again because i remains 0 after every iteration of the loop.\n"
  },
  {
    "id": "oca-33",
    "question": "What is the output?\n\nbyte a = 40, b = 50;\nbyte sum = (byte) a + b;\nSystem.out.println(sum);",
    "choices": [
      {
        "key": "A",
        "text": "40"
      },
      {
        "key": "B",
        "text": "50"
      },
      {
        "key": "C",
        "text": "90"
      },
      {
        "key": "D",
        "text": "Does not compile (line 4)"
      },
      {
        "key": "E",
        "text": "Undefined value"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Line 4 generates a possible loss of precision compiler error. The cast operator has \nthe highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is \nevaluated, causing both a and b to be promoted to int values. The value 90 is an int\nand cannot be assigned to the byte sum without an explicit cast, so the code does not \ncompile. The code could be corrected with parentheses around (a + b), in which case \noption C would be the correct answer.\n"
  },
  {
    "id": "oca-34",
    "question": "What is the output?\n\nint x = 5 * 4 % 3;\nSystem.out.println(x);",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "6"
      },
      {
        "key": "E",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The * and % have the same operator precedence, so the expression is evaluated \nfrom left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the \nremainder is 2). The output is 2 and option A is the correct answer.\n"
  },
  {
    "id": "oca-35",
    "question": "What is the output?\n\nint x = 0;\nString s = null;\nif (x == s)\n    System.out.println(\"Success\");\nelse\n    System.out.println(\"Failure\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "Does not compile (line 4)"
      },
      {
        "key": "D",
        "text": "Does not compile (line 5)"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The variable x is an int and s is a reference to a String object. The two data types \nare incomparable because neither variable can be converted to the other variable’s type. \nThe compiler error occurs on line 5 when the comparison is attempted, so the answer \nis option D.\n"
  },
  {
    "id": "oca-36",
    "question": "What is the output?\n\nint x1 = 50, x2 = 75;\nboolean b = x1 >= x2;\nif (b = true)\n    System.out.println(\"Success\");\nelse\n    System.out.println(\"Failure\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "Does not compile (line 4)"
      },
      {
        "key": "D",
        "text": "Does not compile (line 5)"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles successfully, so options C and D are incorrect. The value of b\nafter line 4 is false. However, the if-then statement on line 5 contains an assignment, \nnot a comparison. The variable b is assigned true on line 3, and the assignment opera\u0002tor returns true, so line 5 executes and displays Success, so the answer is option A.\n"
  },
  {
    "id": "oca-37",
    "question": "What is the output?\n\nint c = 7;\nint result = 4;\nresult += ++c;\nSystem.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "8"
      },
      {
        "key": "B",
        "text": "11"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "15"
      },
      {
        "key": "E",
        "text": "16"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles successfully, so option F is incorrect. On line 5, the pre-incre\u0002ment operator is used, so c is incremented to 4 and the new value is returned to the \nexpression. The value of result is computed by adding 4 to the original value of 8, \nresulting in a new value of 12, which is output on line 6. Therefore, option C is the \ncorrect answer.\n"
  },
  {
    "id": "oca-38",
    "question": "What is the output?\n\nint x = 1, y = 15;\nwhile x < 10\n    y––;\nx++;\nSystem.out.println(x + \", \" + y);",
    "choices": [
      {
        "key": "A",
        "text": "10, 5"
      },
      {
        "key": "B",
        "text": "10, 6"
      },
      {
        "key": "C",
        "text": "11, 5"
      },
      {
        "key": "D",
        "text": "Does not compile (line 3)"
      },
      {
        "key": "E",
        "text": "Does not compile (line 4)"
      },
      {
        "key": "F",
        "text": "Infinite loop"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This is actually a much simpler problem than it appears to be. The while statement \non line 4 is missing parentheses, so the code will not compile, and option E is the cor\u0002rect answer. If the parentheses were added, though, option F would be the correct \nanswer since the loop does not use curly braces to include x++ and the boolean expres\u0002sion never changes. Finally, if curly braces were added around both expressions, the \noutput would be 10, 6 and option B would be correct.\n"
  },
  {
    "id": "oca-39",
    "question": "What is the output?\n\ndo {\n    int y = 1;\n    System.out.print(y++ + \" \");\n} while(y <= 10);",
    "choices": [
      {
        "key": "A",
        "text": "1 2 3 4 5 6 7 8 9"
      },
      {
        "key": "B",
        "text": "1 2 3 4 5 6 7 8 9 10"
      },
      {
        "key": "C",
        "text": "1 2 3 4 5 6 7 8 9 10 11"
      },
      {
        "key": "D",
        "text": "Does not compile"
      },
      {
        "key": "E",
        "text": "Infinite loop"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The variable y is declared within the body of the do-while statement, so it is out of \nscope on line 6. Line 6 generates a compiler error, so option D is the correct answer.\n"
  },
  {
    "id": "oca-40",
    "question": "What is the output?\n\nboolean keepGoing = true;\nint result = 15, i = 10;\ndo {\n    i--;\n    if (i == 8) keepGoing = false;\n    result -= 2;\n} while (keepGoing);\nSystem.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "11"
      },
      {
        "key": "E",
        "text": "15"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles without issue, so option F is incorrect. After the first execu\u0002tion of the loop, i is decremented to 9 and result to 13. Since i is not 8, keepGoing is \nfalse, and the loop continues. On the next iteration, i is decremented to 8 and result\nto 11. On the second execution, i does equal 8, so keepGoing is set to false. At the \nconclusion of the loop, the loop terminates since keepGoing is no longer true. The \nvalue of result is 11, and the correct answer is option D.\n"
  },
  {
    "id": "oca-41",
    "question": "What is the output?\n\nint count = 0;\nROW_LOOP: for (int row = 1; row <= 3; row++)\n    for (int col = 1; col <= 2; col++) {\n        if (row * col % 2 == 0) continue ROW_LOOP;\n        count++;\n    }\nSystem.out.println(count);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "6"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The expression on line 5 is true when row * col is an even number. On the first \niteration, row = 1 and col = 1, so the expression on line 6 is false, the continue is \nskipped, and count is incremented to 1. On the second iteration, row = 1 and \ncol = 2, so the expression on line 6 is true and the continue ends the outer loop with \ncount still at 1. On the third iteration, row = 2 and col = 1, so the expression on line \n6 is true and the continue ends the outer loop with count still at 1. On the fourth \niteration, row = 3 and col = 1, so the expression on line 6 is false, the continue is \nskipped, and count is incremented to 2. Finally, on the fifth and final iteration, row \n= 3 and col = 2, so the expression on line 6 is true and the continue ends the outer \nloop with count still at 2. The result of 2 is displayed, so the answer is option B.\n"
  },
  {
    "id": "oca-42",
    "question": "What is the result?\n\nint m = 9, n = 1, x = 0;\nwhile (m > n) {\n    m--;\n    n += 2;\n    x += m + n;\n}\nSystem.out.println(x);",
    "choices": [
      {
        "key": "A",
        "text": "11"
      },
      {
        "key": "B",
        "text": "13"
      },
      {
        "key": "C",
        "text": "23"
      },
      {
        "key": "D",
        "text": "36"
      },
      {
        "key": "E",
        "text": "50"
      },
      {
        "key": "F",
        "text": "Does not compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Prior to the first iteration, m = 9, n = 1, and x = 0. After the iteration of the first \nloop, m is updated to 8, n to 3, and x to the sum of the new values for m + n, 0 + 11 = 11. \nAfter the iteration of the second loop, m is updated to 7, n to 5, and x to the sum \nof the new values for m + n, 11 + 12 = 23. After the iteration of the third loop, m is \nupdated to 6, n to 7, and x to the sum of the new values for m + n, 23 + 13 = 36. On \nthe fourth iteration of the loop, m > n evaluates to false, as 6 < 7 is not true. The \nloop ends and the most recent value of x, 36, is output, so the correct answer is option \nD.\n"
  },
  {
    "id": "oca-43",
    "question": "What is the output?\n\nfinal char a = 'A', d = 'D';\nchar grade = 'B';\nswitch (grade) {\n    case a:\n    case 'B': System.out.print(\"great\");\n    case 'C': System.out.print(\"good\"); break;\n    case d:\n    case 'F': System.out.print(\"not good\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "great"
      },
      {
        "key": "B",
        "text": "greatgood"
      },
      {
        "key": "C",
        "text": "Does not compile (line 3)"
      },
      {
        "key": "D",
        "text": "Does not compile (line 6)"
      },
      {
        "key": "E",
        "text": "Does not compile (lines 6 and 9)"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The code compiles and runs without issue, so options C, D, and E are not correct. The \nvalue of grade is 'B' and there is a matching case statement that will cause \"great\" to \nbe printed. There is no break statement after the case, though, so the next case state\u0002ment will be reached, and \"good\" will be printed. There is a break after this case state\u0002ment, though, so the switch statement will end. The correct answer is thus option B.\n"
  },
  {
    "id": "oca-44",
    "question": "What is output by the following code? (Choose all that apply.)\npublic class Fish {\n    public static void main(String[] args) {\n        int numFish = 4;\n        String fishType = \"tuna\";\n        String anotherFish = numFish + 1;\n        System.out.println(anotherFish + \" \" + fishType);\n        System.out.println(numFish + \" \" + 1);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "4 1"
      },
      {
        "key": "B",
        "text": "41"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "5 tuna"
      },
      {
        "key": "E",
        "text": "5tuna"
      },
      {
        "key": "F",
        "text": "51tuna"
      },
      {
        "key": "G",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "Line 5 does not compile. This question is checking to see if you are paying attention \nto the types. numFish is an int and 1 is an int. Therefore, we use numeric addition and \nget 5. The problem is that we can’t store an int in a String variable. Supposing line 5 \nsaid String anotherFish = numFish + 1 + \"\";. In that case, the answer would be \noptions A and D. The variable defined on line 5 would be the string \"5\", and both out\u0002put statements would use concatenation.\n"
  },
  {
    "id": "oca-45",
    "question": "Which of the following are output by this code? (Choose all that apply.)\nString s = \"Hello\";\nString t = new String(s);\nif (\"Hello\".equals(s)) System.out.println(\"one\");\nif (t == s) System.out.println(\"two\");\nif (t.equals(s)) System.out.println(\"three\");\nif (\"Hello\" == s) System.out.println(\"four\");\nif (\"Hello\" == t) System.out.println(\"five\");",
    "choices": [
      {
        "key": "A",
        "text": "one"
      },
      {
        "key": "B",
        "text": "two"
      },
      {
        "key": "C",
        "text": "three"
      },
      {
        "key": "D",
        "text": "four"
      },
      {
        "key": "E",
        "text": "five"
      },
      {
        "key": "F",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 \ncalls the String constructor explicitly and is therefore a different object than s. Lines 5 \nand 7 check for object equality, which is true, and so print one and three. Line 6 uses \nobject reference equality, which is not true since we have different objects. Line 7 also \ncompares references but is true since both references point to the object from the string \npool. Finally, line 8 compares one object from the string pool with one that was explic\u0002itly constructed and returns false.\n"
  },
  {
    "id": "oca-46",
    "question": "Which are true statements? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "An immutable object can be modified"
      },
      {
        "key": "B",
        "text": "An immutable object cannot be modified"
      },
      {
        "key": "C",
        "text": "An immutable object can be garbage collected"
      },
      {
        "key": "D",
        "text": "An immutable object cannot be garbage collected"
      },
      {
        "key": "E",
        "text": "String is immutable"
      },
      {
        "key": "F",
        "text": "StringBuffer is immutable"
      },
      {
        "key": "G",
        "text": "StringBuilder is immutable"
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "Immutable means the state of an object cannot change once it is created. \nImmutable objects can be garbage collected just like mutable objects. String is immu\u0002table. StringBuilder can be mutated with methods like append(). Although \nStringBuffer isn’t on the exam, you should know about it anyway in case older ques\u0002tions haven’t been removed.\n"
  },
  {
    "id": "oca-47",
    "question": "What is the result of the following code?\n Choose all that apply.\nStringBuilder sb = new StringBuilder();\nsb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\nSystem.out.println(sb);",
    "choices": [
      {
        "key": "A",
        "text": "abbaaccc"
      },
      {
        "key": "B",
        "text": "abbaccca"
      },
      {
        "key": "C",
        "text": "bbaaaccc"
      },
      {
        "key": "D",
        "text": "bbaaccca"
      },
      {
        "key": "E",
        "text": "An exception is thrown"
      },
      {
        "key": "F",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". \nThat result is passed to the first insert() call, which inserts at index 1. At this point \nsb contains abbbaa. That result is passed to the final insert(), which inserts at index \n4, resulting in abbaccca.\n"
  },
  {
    "id": "oca-48",
    "question": "What is the result of the following code?\n Choose all that apply.\nString s1 = \"java\";\nStringBuilder s2 = new StringBuilder(\"java\");\nif (s1 == s2) System.out.print(\"1\");\nif (s1.equals(s2)) System.out.print(\"2\");",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "No output"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The question is trying to distract you into paying attention to logical equality versus \nobject reference equality. It is hoping you will miss the fact that line 4 does not com\u0002pile. Java does not allow you to compare String and StringBuilder using ==.\n"
  },
  {
    "id": "oca-49",
    "question": "What is the result of the following code?\n Choose all that apply.\npublic class Lion {\n    public void roar(String roar1, StringBuilder roar2) {\n        roar1.concat(\"!!!\");\n        roar2.append(\"!!!\");\n    }\n\n    public static void main(String[] args) {\n        String roar1 = \"roar\";\n        StringBuilder roar2 = new StringBuilder(\"roar\");\n        new Lion().roar(roar1, roar2);\n        System.out.println(roar1 + \" \" + roar2);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "roar roar"
      },
      {
        "key": "B",
        "text": "roar roar!!!"
      },
      {
        "key": "C",
        "text": "roar!!! roar"
      },
      {
        "key": "D",
        "text": "roar!!! roar!!!"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "A String is immutable. Calling concat() returns a new String but does not change \nthe original. A StringBuilder is mutable. Calling append() adds characters to the \nexisting character sequence along with returning a reference to the same object. \n"
  },
  {
    "id": "oca-50",
    "question": "What is the result of the following code?\n Choose all that apply.\nString letters = \"abcdef\";\nSystem.out.println(letters.length());\nSystem.out.println(letters.charAt(3));\nSystem.out.println(letters.charAt(6));",
    "choices": [
      {
        "key": "A",
        "text": "5"
      },
      {
        "key": "B",
        "text": "6"
      },
      {
        "key": "C",
        "text": "c"
      },
      {
        "key": "D",
        "text": "d"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "length() is simply a count of the number of characters in a String. In this \ncase, there are six characters. charAt() returns the character at that index. Remember \nthat indexes are zero based, which means that index 3 corresponds to d and index 6 \ncorresponds to 1 past the end of the array. A StringIndexOutOfBoundsException is \nthrown for the last line.\n"
  },
  {
    "id": "oca-51",
    "question": "Which are the results of the following code? (Choose all that apply.)\nString numbers = \"012345678\";\nSystem.out.println(numbers.substring(1, 3));\nSystem.out.println(numbers.substring(7, 7));\nSystem.out.println(numbers.substring(7));",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "123"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "78"
      },
      {
        "key": "E",
        "text": "A blank line"
      },
      {
        "key": "F",
        "text": "Exception is thrown"
      },
      {
        "key": "G",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "substring() has two forms. The first takes the index to start with and the \nindex to stop immediately before. The second takes just the index to start with and \ngoes to the end of the String. Remember that indexes are zero based. The first call \nstarts at index 1 and ends with index 2 since it needs to stop before index 3. The sec\u0002ond call starts at index 7 and ends in the same place, resulting in an empty String. \nThis prints out a blank line. The final call starts at index 7 and goes to the end of the \nString.\n"
  },
  {
    "id": "oca-52",
    "question": "What is the result of the following code?\n Choose all that apply.\nString s = \"purr\";\ns.toUpperCase();\ns.trim();\ns.substring(1, 3);\ns += \" two\";\nSystem.out.println(s.length());",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "8"
      },
      {
        "key": "D",
        "text": "10"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This question is trying to see if you know that String objects are immutable. Line \n\"4\" returns \"PURR\" but the result is ignored and not stored in s. Line 5 returns \"purr\"\nsince there is no whitespace present but the result is again ignored. Line 6 returns \"ur\"\nbecause it starts with index 1 and ends before index 3 using zero-based indexes. The \nresult is ignored again. Finally, on line 6 something happens. We concatenate four new \ncharacters to s and now have a String of length 8.\n"
  },
  {
    "id": "oca-53",
    "question": "What is the result of the following code?\n Choose all that apply.\nString a = \"\";\na += 2;\na += 'c';\na += false;\nif (a == \"2cfalse\") System.out.println(\"==\");\nif (a.equals(\"2cfalse\")) System.out.println(\"equals\");",
    "choices": [
      {
        "key": "A",
        "text": "Compile error on line 14"
      },
      {
        "key": "B",
        "text": "Compile error on line 15"
      },
      {
        "key": "C",
        "text": "Compile error on line 16"
      },
      {
        "key": "D",
        "text": "Compile error elsewhere"
      },
      {
        "key": "E",
        "text": "=="
      },
      {
        "key": "F",
        "text": "equals"
      },
      {
        "key": "G",
        "text": "Exception is thrown"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "a += 2 expands to a = a + 2. A String concatenated with any other type gives \na String. Lines 14, 15, and 16 all append to a, giving a result of \"2cfalse\". The if\nstatement on line 18 returns false because the values of the two String objects are the \nsame using object equality. The if statement on line 17 returns false because the two \nString objects are not the same in memory. One comes directly from the string pool \nand the other comes from building using String operations.\n"
  },
  {
    "id": "oca-54",
    "question": "What is the result of the following code?\n Choose all that apply.\nint total = 0;\nStringBuilder letters = new StringBuilder(\"abcdefg\");\ntotal += letters.substring(1, 2).length();\ntotal += letters.substring(6, 6).length();\ntotal += letters.substring(6, 5).length();\nSystem.out.println(total);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "7"
      },
      {
        "key": "E",
        "text": "An exception is thrown"
      },
      {
        "key": "F",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Line 6 adds 1 to total because substring() includes the starting index but not \nthe ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the \nindexes to be specified in reverse order and the code throws a StringIndexOutOf\u0002BoundsException.\n"
  },
  {
    "id": "oca-55",
    "question": "What is the result of the following code?\n Choose all that apply.\nStringBuilder numbers = new StringBuilder(\"0123456789\");\nnumbers.delete(2, 8);\nnumbers.append(\"-\").insert(2, \"+\");\nSystem.out.println(numbers);",
    "choices": [
      {
        "key": "A",
        "text": "01+89–"
      },
      {
        "key": "B",
        "text": "012+9–"
      },
      {
        "key": "C",
        "text": "012+–9"
      },
      {
        "key": "D",
        "text": "0123456789"
      },
      {
        "key": "E",
        "text": "An exception is thrown"
      },
      {
        "key": "F",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "First, we delete the characters at index 2 until the character one before index 8. At \nthis point, 0189 is in numbers. The following line uses method chaining. It appends a \ndash to the end of the characters sequence, resulting in 0189–, and then inserts a plus \nsign at index 2, resulting in 01+89–.\n"
  },
  {
    "id": "oca-56",
    "question": "What is the result of the following code?\n Choose all that apply.\nStringBuilder b = \"rumble\";\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);\nSystem.out.println(b);",
    "choices": [
      {
        "key": "A",
        "text": "rum"
      },
      {
        "key": "B",
        "text": "rum4"
      },
      {
        "key": "C",
        "text": "rumb4"
      },
      {
        "key": "D",
        "text": "rumble4"
      },
      {
        "key": "E",
        "text": "An exception is thrown"
      },
      {
        "key": "F",
        "text": "The code does not compile"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "This is a trick question. The first line does not compile because you cannot \nassign a String to a StringBuilder. If that line were StringBuilder b = new \nStringBuilder(\"rumble\"), the code would compile and print rum4. Watch out for this \nsort of trick on the exam. You could easily spend a minute working out the character \npositions for no reason at all.\n"
  },
  {
    "id": "oca-57",
    "question": "Which of the following can replace line 4 to print \"avaJ\"?\n Choose all that apply.\nStringBuilder puzzle = new StringBuilder(\"Java\");\n// INSERT CODE HERE\nSystem.out.println(puzzle);",
    "choices": [
      {
        "key": "A",
        "text": "puzzle.reverse();"
      },
      {
        "key": "B",
        "text": "puzzle.append(\"vaJ$\").substring(0, 4);"
      },
      {
        "key": "C",
        "text": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() - 1);"
      },
      {
        "key": "D",
        "text": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length());"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "The reverse() method is the easiest way of reversing the characters in a String\u0002Builder; therefore, option A is correct. Option B is a nice distraction—it does in fact \nreturn \"avaJ\". However, substring() returns a String, which is not stored anywhere. \nOption C uses method chaining. First it creates the value \"JavavaJ$\". Then it removes \nthe first three characters, resulting in \"avaJ$\". Finally, it removes the last character, \nresulting in \"avaJ\". Option D throws an exception because you cannot delete the char\u0002acter after the last index. Remember that deleteCharAt() uses indexes that are zero \nbased and length() counts starting with 1.\n"
  },
  {
    "id": "oca-58",
    "question": "Which of these array declarations is not legal?",
    "choices": [
      {
        "key": "A",
        "text": "int[][] scores = new int[5][];"
      },
      {
        "key": "B",
        "text": "Object[][][] cubbies = new Object[3][0][5];"
      },
      {
        "key": "C",
        "text": "String beans[] = new beans[6];"
      },
      {
        "key": "D",
        "text": "java.util.Date[] dates[] = new java.util.Date[2][];"
      },
      {
        "key": "E",
        "text": "int[][] types = new int[];"
      },
      {
        "key": "F",
        "text": "int[][] java = new int[][];"
      }
    ],
    "answer": [
      "C",
      "E",
      "F"
    ],
    "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. \nOptions E and F don’t specify any size. Although it is legal to leave out the size for later \ndimensions of a multidimensional array, the first one is required. Option A declares a \nlegal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. \nRemember that it is normal to see on the exam types you might not have learned. You \naren’t expected to know anything about them.\n"
  },
  {
    "id": "oca-59",
    "question": "Which of these compile when replacing line 8?\n Choose all that apply.\nchar[] c = new char[2];\n// INSERT CODE HERE",
    "choices": [
      {
        "key": "A",
        "text": "int length = c.capacity;"
      },
      {
        "key": "B",
        "text": "int length = c.capacity();"
      },
      {
        "key": "C",
        "text": "int length = c.length;"
      },
      {
        "key": "D",
        "text": "int length = c.length();"
      },
      {
        "key": "E",
        "text": "int length = c.size;"
      },
      {
        "key": "F",
        "text": "int length = c.size();"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Arrays define a property called length. It is not a method, so parentheses are not \nallowed.\n"
  },
  {
    "id": "oca-60",
    "question": "Which of these compile when replacing line 8?\n Choose all that apply.\nArrayList l = new ArrayList();\n// INSERT CODE HERE",
    "choices": [
      {
        "key": "A",
        "text": "int length = l.capacity;"
      },
      {
        "key": "B",
        "text": "int length = l.capacity();"
      },
      {
        "key": "C",
        "text": "int length = l.length;"
      },
      {
        "key": "D",
        "text": "int length = l.length();"
      },
      {
        "key": "E",
        "text": "int length = l.size;"
      },
      {
        "key": "F",
        "text": "int length = l.size();"
      },
      {
        "key": "G",
        "text": "None of the above"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The ArrayList class defines a method called size().\n"
  },
  {
    "id": "oca-61",
    "question": "Which of the following are true?",
    "choices": [
      {
        "key": "A",
        "text": "An array has a fixed size"
      },
      {
        "key": "B",
        "text": "An ArrayList has a fixed size"
      },
      {
        "key": "C",
        "text": "An array allows multiple dimensions"
      },
      {
        "key": "D",
        "text": "An array is ordered"
      },
      {
        "key": "E",
        "text": "An ArrayList is ordered"
      },
      {
        "key": "F",
        "text": "An array is immutable"
      },
      {
        "key": "G",
        "text": "An ArrayList is immutable"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "An array is not able to change size and can have multiple dimensions. Both \nan array and ArrayList are ordered and have indexes. Neither is immutable. The ele\u0002ments can change in value.\n"
  },
  {
    "id": "oca-62",
    "question": "Which of the following are true?",
    "choices": [
      {
        "key": "A",
        "text": "Two arrays with the same content are equal"
      },
      {
        "key": "B",
        "text": "Two ArrayLists with the same content are equal"
      },
      {
        "key": "C",
        "text": "If you call remove(0) using an empty ArrayList object, it will compile successfully"
      },
      {
        "key": "D",
        "text": "If you call remove(0) using an empty ArrayList object, it will run successfully"
      },
      {
        "key": "E",
        "text": "None of the above"
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "An array does not override equals() and so uses object equality. ArrayList does \noverride equals() and defines it as the same elements in the same order. The compiler \ndoes not know when an index is out of bounds and thus can’t give you a compiler \nerror. The code will throw an exception at runtime, though.\n"
  },
  {
    "id": "oca-63",
    "question": "What is the result of the following statements?\n Choose all that apply.\nList<String> list = new ArrayList<String>();\nlist.add(\"one\");\nlist.add(\"two\");\nlist.add(7);\nfor(String s : list) System.out.print(s);",
    "choices": [
      {
        "key": "A",
        "text": "onetwo"
      },
      {
        "key": "B",
        "text": "onetwo7"
      },
      {
        "key": "C",
        "text": "onetwo followed by an exception"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9"
      },
      {
        "key": "E",
        "text": "Compiler error on line 10"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code does not compile because list is instantiated using generics. Only String\nobjects can be added to list and 7 is an int.\n"
  },
  {
    "id": "oca-64",
    "question": "What is the result of the following?\n Choose all that apply.\nArrayList<Integer> values = new ArrayList<>();\nvalues.add(4);\nvalues.add(5);\nvalues.set(1, 6);\nvalues.remove(0);\nfor (Integer v : values) System.out.print(v);",
    "choices": [
      {
        "key": "A",
        "text": "4"
      },
      {
        "key": "B",
        "text": "5"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "46"
      },
      {
        "key": "E",
        "text": "45"
      },
      {
        "key": "F",
        "text": "Exception is thrown"
      },
      {
        "key": "G",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "After line 4, values has one element (4). After line 5, values has two elements (4, \n5). After line 6, values has two elements (4, 6) because set() does a replace. After line \n7, values has only one element (6).\n"
  },
  {
    "id": "oca-65",
    "question": "What is the result of the following?\n Choose all that apply.\nint[] random = { 6, -4, 12, 0, -10 };\nint x = 12;\nint y = Arrays.binarySearch(random, x);\nSystem.out.println(y);",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "The result is undefined"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles and runs fine. However, an array must be sorted for binarySe\u0002arch() to return a meaningful result.\n"
  },
  {
    "id": "oca-66",
    "question": "What is the result of the following?\n Choose all that apply.\nList<Integer> list = Arrays.asList(10, 4, -1, 5);\nCollections.sort(list);\nInteger[] array = list.toArray(new Integer[4]);\nSystem.out.println(array[0]);",
    "choices": [
      {
        "key": "A",
        "text": "-1"
      },
      {
        "key": "B",
        "text": "10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 4"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5"
      },
      {
        "key": "E",
        "text": "Compiler error on line 6"
      },
      {
        "key": "F",
        "text": "Exception is thrown"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Line 4 creates a fixed size array of size 4. Line 5 sorts it. Line 6 converts it back to \nan array. The brackets aren’t in the traditional place, but they are still legal. Line 7 \nprints the first element, which is now –1.\n"
  },
  {
    "id": "oca-67",
    "question": "What is the result of the following?\n Choose all that apply.\nString[] names = {\"Tom\", \"Dick\", \"Harry\"};\nList<String> list = Arrays.asList(names);\nlist.set(0, \"Sue\");\nSystem.out.println(names[0]);",
    "choices": [
      {
        "key": "A",
        "text": "Sue"
      },
      {
        "key": "B",
        "text": "Tom"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 8"
      },
      {
        "key": "E",
        "text": "Exception is thrown"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Converting from an array to an ArrayList uses Arrays.asList(names). There is \nno asList() method on an array instance. If this code were corrected to compile, the \nanswer would be option A.\n"
  },
  {
    "id": "oca-68",
    "question": "What is the result of the following?\n Choose all that apply.\nList<String> hex = Arrays.asList(\"30\", \"8\", \"3A\", \"FF\");\nCollections.sort(hex);\nint x = Collections.binarySearch(hex, \"8\");\nint y = Collections.binarySearch(hex, \"3A\");\nint z = Collections.binarySearch(hex, \"4F\");\nSystem.out.println(x + \" \" + y + \" \" + z);",
    "choices": [
      {
        "key": "A",
        "text": "0 1 –2"
      },
      {
        "key": "B",
        "text": "0 1 –3"
      },
      {
        "key": "C",
        "text": "2 1 –2"
      },
      {
        "key": "D",
        "text": "2 1 –3"
      },
      {
        "key": "E",
        "text": "None of the above"
      },
      {
        "key": "F",
        "text": "The code doesn't compile"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before \nletters and strings sort alphabetically. This makes 30 come before 8. A binary search \ncorrectly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should \nbe at index 2. The rule when an item isn’t found is to negate that index and subtract 1. \nTherefore, we get –2–1, which is –3.\n"
  },
  {
    "id": "oca-69",
    "question": "Which of the following are true about this code?\n Choose all that apply.\nList<Integer> ages = new ArrayList<>();\nages.add(Integer.parseInt(\"5\"));\nages.add(Integer.valueOf(\"6\"));\nages.add(7);\nages.add(null);\nfor (int age : ages) System.out.print(age);",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles"
      },
      {
        "key": "B",
        "text": "The code throws a runtime exception"
      },
      {
        "key": "C",
        "text": "Exactly one add uses autoboxing"
      },
      {
        "key": "D",
        "text": "Exactly two adds use autoboxing"
      },
      {
        "key": "E",
        "text": "Exactly three adds use autoboxing"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Lines 5 and 7 use autoboxing to convert an int to an Integer. Line 6 does \nnot because valueOf() returns an Integer. Line 8 does not because null is not an int. \nThe code does not compile. However, when the for loop tries to unbox null into an \nint, it fails and throws a NullPointerException.\n"
  },
  {
    "id": "oca-70",
    "question": "What is the result of the following?\n Choose all that apply.\nList<String> one = new ArrayList<>();\none.add(\"abc\");\nList<String> two = new ArrayList<>();\ntwo.add(\"abc\");\n\nif (one == two)\n    System.out.println(\"A\");\nelse if (one.equals(two))\n    System.out.println(\"B\");\nelse\n    System.out.println(\"C\");",
    "choices": [
      {
        "key": "A",
        "text": "A"
      },
      {
        "key": "B",
        "text": "B"
      },
      {
        "key": "C",
        "text": "C"
      },
      {
        "key": "D",
        "text": "Exception is thrown"
      },
      {
        "key": "E",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first if statement is false because the variables do not point to the same object. \nThe second if statement is true because ArrayList implements equality to mean the \nsame elements in the same order.\n"
  },
  {
    "id": "oca-71",
    "question": "Which of the following can replace the blank to create a date of June 21, 2014?\n Choose all that apply.\nLocalDate date = _______________________",
    "choices": [
      {
        "key": "A",
        "text": "new LocalDate(2014, 5, 21);"
      },
      {
        "key": "B",
        "text": "new LocalDate(2014, 6, 21);"
      },
      {
        "key": "C",
        "text": "LocalDate.of(2014, 5, 21);"
      },
      {
        "key": "D",
        "text": "LocalDate.of(2014, 6, 21);"
      },
      {
        "key": "E",
        "text": "LocalDate.of(2014, Calendar.JUNE, 21);"
      },
      {
        "key": "F",
        "text": "LocalDate.of(2014, Month.JUNE, 21);"
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "Options A and B are incorrect because LocalDate does not have a public con\u0002structor. Option C is incorrect because months start counting with 1 rather than 0. \nOption E is incorrect because it uses the old pre–Java 8 way of counting months, again \nbeginning with 0. Options D and F are both correct ways of specifying the desired \ndate.\n"
  },
  {
    "id": "oca-72",
    "question": "What is the output of the following?\n Choose all that apply.\nLocalDate date = LocalDate.parse(\"2018-04-30\", DateTimeFormatter.ISO_LOCAL_DATE);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 2"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 2"
      },
      {
        "key": "D",
        "text": "Code does not compile"
      },
      {
        "key": "E",
        "text": "Runtime exception is thrown"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "A LocalDate does not have a time element. Therefore, it has no method to add \nhours and the code does not compile.\n"
  },
  {
    "id": "oca-73",
    "question": "What is the output of the following?\n Choose all that apply.\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 4"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 10"
      },
      {
        "key": "D",
        "text": "Another date"
      },
      {
        "key": "E",
        "text": "Code does not compile"
      },
      {
        "key": "F",
        "text": "Runtime exception is thrown"
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "Java throws an exception if invalid date values are passed. There is no 40th day in \nApril—or any other month for that matter.\n"
  },
  {
    "id": "oca-74",
    "question": "What is the output of the following?\n Choose all that apply.\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 2"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 2"
      },
      {
        "key": "D",
        "text": "2021 APRIL 2"
      },
      {
        "key": "E",
        "text": "2021 APRIL 30"
      },
      {
        "key": "F",
        "text": "2021 MAY 2"
      },
      {
        "key": "G",
        "text": "Runtime exception is thrown"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The date starts out as April 30, 2018. Since dates are immutable and the plus meth\u0002ods have their return values ignored, the result is unchanged. Therefore, option B is \ncorrect.\n"
  },
  {
    "id": "oca-75",
    "question": "What is the output of the following?\n Choose all that apply.\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.of(1, 2, 3);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);\nSystem.out.println(d.format(f));",
    "choices": [
      {
        "key": "A",
        "text": "3/7/14 11:22 AM"
      },
      {
        "key": "B",
        "text": "5/10/15 11:22 AM"
      },
      {
        "key": "C",
        "text": "3/7/14"
      },
      {
        "key": "D",
        "text": "5/10/15"
      },
      {
        "key": "E",
        "text": "11:22 AM"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      },
      {
        "key": "G",
        "text": "Runtime exception is thrown"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Even though d has both date and time, the formatter only outputs time.\n"
  },
  {
    "id": "oca-76",
    "question": "What is the output of the following?\n Choose all that apply.\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.ofDays(1).ofYears(2);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);\nSystem.out.println(f.format(d));",
    "choices": [
      {
        "key": "A",
        "text": "5/9/13 11:22 AM"
      },
      {
        "key": "B",
        "text": "5/10/13 11:22 AM"
      },
      {
        "key": "C",
        "text": "5/9/14"
      },
      {
        "key": "D",
        "text": "5/10/14"
      },
      {
        "key": "E",
        "text": "Code does not compile"
      },
      {
        "key": "F",
        "text": "Runtime exception is thrown"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Period does not allow chaining. Only the last Period method called counts, so only \nthe two years are subtracted.\n"
  },
  {
    "id": "oca-77",
    "question": "Which of the following can fill in the blank in this code to make it compile? (Choose all that apply.)\npublic class Ant {\n  _____ void method() { }\n}",
    "choices": [
      {
        "key": "A",
        "text": "default"
      },
      {
        "key": "B",
        "text": "final"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "Public"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "zzz:"
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "void is a return type. Only the access modifier or optional specifiers are allowed \nbefore the return type. Option C is correct, creating a method with private access. \nOption B is correct, creating a method with default access and the optional specifier \nfinal. Since default access does not require a modifier, we get to jump right to final. \nOption A is incorrect because default access omits the access modifier rather than spec\u0002ifying default. Option D is incorrect because Java is case sensitive. It would have been \ncorrect if public were the choice. Option E is incorrect because the method already has \na void return type. Option F is incorrect because labels are not allowed for methods.\n"
  },
  {
    "id": "oca-78",
    "question": "Which of the following compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "final static void method4() { }"
      },
      {
        "key": "B",
        "text": "public final int void method() { }"
      },
      {
        "key": "C",
        "text": "private void int method() { }"
      },
      {
        "key": "D",
        "text": "static final void method3() { }"
      },
      {
        "key": "E",
        "text": "void final method() {}"
      },
      {
        "key": "F",
        "text": "void public method() { }"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Options A and D are correct because the optional specifiers are allowed in any \norder. Options B and C are incorrect because they each have two return types. Options \nE and F are incorrect because the return type is before the optional specifier and access \nmodifier, respectively.\n"
  },
  {
    "id": "oca-79",
    "question": "Which of the following methods compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void methodA() { return; }"
      },
      {
        "key": "B",
        "text": "public void methodB() { return null; }"
      },
      {
        "key": "C",
        "text": "public void methodD() {}"
      },
      {
        "key": "D",
        "text": "public int methodD() { return 9; }"
      },
      {
        "key": "E",
        "text": "public int methodE() { return 9.0; }"
      },
      {
        "key": "F",
        "text": "public int methodF() { return; }"
      },
      {
        "key": "G",
        "text": "public int methodG() { return null; }"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Options A and C are correct because a void method is allowed to have a \nreturn statement as long as it doesn’t try to return a value. Options B and G do not \ncompile because null requires a reference object as the return type. void is not a refer\u0002ence object since it is a marker for no return type. int is not a reference object since it \nis a primitive. Option D is correct because it returns an int value. Option E does not \ncompile because it tries to return a double when the return type is int. Since a double\ncannot be assigned to an int, it cannot be returned as one either. Option F does not \ncompile because no value is actually returned.\n"
  },
  {
    "id": "oca-80",
    "question": "Which of the following compile? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public void moreA(int... nums) {}"
      },
      {
        "key": "B",
        "text": "public void moreB(String values, int... nums) {}"
      },
      {
        "key": "C",
        "text": "public void moreC(int... nums, String values) {}"
      },
      {
        "key": "D",
        "text": "public void moreD(String... values, int... nums) {}"
      },
      {
        "key": "E",
        "text": "public void moreE(String[] values, ...int nums) {}"
      },
      {
        "key": "F",
        "text": "public void moreF(String... values, int[] nums) {}"
      },
      {
        "key": "G",
        "text": "public void moreG(String[] values, int[] nums) {}"
      }
    ],
    "answer": [
      "A",
      "B",
      "G"
    ],
    "explanation": "Options A and B are correct because the single vararg parameter is the last \nparameter declared. Option G is correct because it doesn’t use any vararg parameters \nat all. Options C and F are incorrect because the vararg parameter is not last. Option \nD is incorrect because two vararg parameters are not allowed in the same method. \nOption E is incorrect because the ... for a vararg must be after the type, not before it.\n"
  },
  {
    "id": "oca-81",
    "question": "Given the following method, which of the method calls return 2? (Choose all that apply.)\npublic int howMany(boolean b, boolean... b2) {\n  return b2.length;\n}",
    "choices": [
      {
        "key": "A",
        "text": "howMany();"
      },
      {
        "key": "B",
        "text": "howMany(true);"
      },
      {
        "key": "C",
        "text": "howMany(true, true);"
      },
      {
        "key": "D",
        "text": "howMany(true, true, true);"
      },
      {
        "key": "E",
        "text": "howMany(true, {true});"
      },
      {
        "key": "F",
        "text": "howMany(true, {true, true});"
      },
      {
        "key": "G",
        "text": "howMany(true, new boolean[2]);"
      }
    ],
    "answer": [
      "D",
      "G"
    ],
    "explanation": "Option D passes the initial parameter plus two more to turn into a vararg array \nof size 2. Option G passes the initial parameter plus an array of size 2. Option A does \nnot compile because it does not pass the initial parameter. Options E and F do not \ncompile because they do not declare an array properly. It should be new boolean[] \n{true}. Option B creates a vararg array of size 0 and option C creates a vararg array of \nsize 1.\n"
  },
  {
    "id": "oca-82",
    "question": "Which of the following are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Package-private access is more lenient than protected access."
      },
      {
        "key": "B",
        "text": "A public class that has private fields and package-private methods is not visible to classes outside the package."
      },
      {
        "key": "C",
        "text": "You can use access modifiers so only some classes in a package see a particular package-private class."
      },
      {
        "key": "D",
        "text": "You can use access modifiers to allow read access to all methods, but not any instance variables."
      },
      {
        "key": "E",
        "text": "You can use access modifiers to restrict read access to all classes that begin with the word Test."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Option D is correct. This is the common implementation for encapsulation by set\u0002ting all fields to be private and all methods to be public. Option A is incorrect because \nprotected access allows everything that package private access allows and additionally \nallows subclasses access. Option B is incorrect because the class is public. This means \nthat other classes can see the class. However, they cannot call any of the methods or \nread any of the fields. It is essentially a useless class. Option C is incorrect because \npackage private access applies to the whole package. Option E is incorrect because Java \nhas no such capability.\n"
  },
  {
    "id": "oca-83",
    "question": "Which lines in main() generate a compiler error? (Choose all that apply.)\n// In package my.school\npublic class Classroom {\n  private int roomNumber;\n  protected String teacherName;\n  static int globalKey = 54321;\n  public int floor = 3;\n  Classroom(int r, String t) {\n    roomNumber = r;\n    teacherName = t;\n  }\n}\n\n// In package my.city\nimport my.school.*;\npublic class School {\n  public static void main(String[] args) {\n    System.out.println(Classroom.globalKey);       // Line 5\n    Classroom room = new Classroom(101, \"Mrs.\");   // Line 6\n    System.out.println(room.roomNumber);           // Line 7\n    System.out.println(room.floor);                // Line 8\n    System.out.println(room.teacherName);          // Line 9\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "None, the code compiles fine"
      },
      {
        "key": "B",
        "text": "Line 5"
      },
      {
        "key": "C",
        "text": "Line 6"
      },
      {
        "key": "D",
        "text": "Line 7"
      },
      {
        "key": "E",
        "text": "Line 8"
      },
      {
        "key": "F",
        "text": "Line 9"
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The two classes are in different packages, which means private access and \ndefault (package private) access will not compile. Additionally, protected access will \nnot compile since School does not inherit from Classroom. Therefore, only line 8 will \ncompile because it uses public access.\n"
  },
  {
    "id": "oca-84",
    "question": "Which of the following are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Encapsulation uses package-private instance variables"
      },
      {
        "key": "B",
        "text": "Encapsulation uses private instance variables"
      },
      {
        "key": "C",
        "text": "Encapsulation allows setters"
      },
      {
        "key": "D",
        "text": "Immutability uses package-private instance variables"
      },
      {
        "key": "E",
        "text": "Immutability uses private instance variables"
      },
      {
        "key": "F",
        "text": "Immutability allows setters"
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "Encapsulation requires using methods to get and set instance variables so \nother classes are not directly using them. Instance variables must be private for this \nto work. Immutability takes this a step further, allowing only getters, so the instance \nvariables do not change state.\n"
  },
  {
    "id": "oca-85",
    "question": "Which are valid JavaBeans accessor/mutator method names? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public boolean getCanSwim() { return canSwim; }"
      },
      {
        "key": "B",
        "text": "public boolean canSwim() { return numberWings; }"
      },
      {
        "key": "C",
        "text": "public int getNumWings() { return numberWings; }"
      },
      {
        "key": "D",
        "text": "public int numWings() { return numberWings; }"
      },
      {
        "key": "E",
        "text": "public void setCanSwim(boolean b) { canSwim = b; }"
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Option A is incorrect because the property is of type boolean and getters must \nbegin with is for booleans. Options B and D are incorrect because they don’t follow \nthe naming convention of beginning with get/is/set. Options C and E follow normal \ngetter and setter conventions. \n"
  },
  {
    "id": "oca-86",
    "question": "What is the output of the following code?\n Choose all that apply.\npackage rope;\npublic class Rope {\n  public static int LENGTH = 5;\n  static { LENGTH = 10; }\n  public static void swing() {\n    System.out.print(\"swing \");\n  }\n}\n Choose all that apply.\nimport rope.*;\nimport static rope.Rope.*;\npublic class Chimp {\n  public static void main(String[] args) {\n    Rope.swing();\n    new Rope().swing();\n    System.out.println(LENGTH);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "swing swing 5"
      },
      {
        "key": "B",
        "text": "swing swing 10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 2 of Chimp"
      },
      {
        "key": "D",
        "text": "Compiler error on line 5 of Chimp"
      },
      {
        "key": "E",
        "text": "Compiler error on line 6 of Chimp"
      },
      {
        "key": "F",
        "text": "Compiler error on line 7 of Chimp"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initial\u0002izer, which sets it to 10. Line 5 calls the static method normally and prints swing. \nLine 6 also calls the static method. Java allows calling a static method through an \ninstance variable. Line 7 uses the static import on line 2 to reference LENGTH.\n"
  },
  {
    "id": "oca-87",
    "question": "Which are true of the following code? (Choose all that apply.)\npublic class Rope {\n  public static void swing() {\n    System.out.print(\"swing \");\n  }\n  public void climb() {\n    System.out.print(\"climb \");\n  }\n  public static void play() {\n    swing();\n    climb();\n  }\n  public static void main(String[] args) {\n    Rope rope = new Rope();\n    rope.play();\n    Rope rope2 = null;\n    rope2.play();\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles as is"
      },
      {
        "key": "B",
        "text": "There is exactly one compiler error"
      },
      {
        "key": "C",
        "text": "There are two compiler errors"
      },
      {
        "key": "D",
        "text": "If compiler error lines are removed, output is climb climb"
      },
      {
        "key": "E",
        "text": "If compiler error lines are removed, output is swing swing"
      },
      {
        "key": "F",
        "text": "If compiler error lines are removed, code throws NullPointerException"
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Line 10 does not compile because static methods are not allowed to call instance \nmethods. Even though we are calling play() as if it were an instance method and an \ninstance exists, Java knows play() is really a static method and treats it as such. If line \n10 is removed, the code works. It does not throw a NullPointerException on line 16 \nbecause play() is a static method. Java looks at the type of the reference for rope2 and \ntranslates the call to Rope.play().\n"
  },
  {
    "id": "oca-88",
    "question": "What is the output of the following code?\n Choose all that apply.\nimport rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n  private static Rope rope1 = new Rope();\n  private static Rope rope2 = new Rope();\n  {\n    System.out.println(rope1.length);\n  }\n  public static void main(String[] args) {\n    rope1.length = 2;\n    rope2.length = 8;\n    System.out.println(rope1.length);\n  }\n}\n Choose all that apply.\npackage rope;\npublic class Rope {\n  public static int length = 0;\n}",
    "choices": [
      {
        "key": "A",
        "text": "02"
      },
      {
        "key": "B",
        "text": "08"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "Code does not compile"
      },
      {
        "key": "F",
        "text": "Exception is thrown"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "There are two details to notice in this code. First, note that RopeSwing has an \ninstance initializer and not a static initializer. Since RopeSwing is never constructed, \nthe instance initializer does not run. The other detail is that length is static. Changes \nfrom one object update this common static variable.\n"
  },
  {
    "id": "oca-89",
    "question": "How many compiler errors are in the following code?\n Choose all that apply.\npublic class RopeSwing {\n  private static final String leftRope;\n  private static final String rightRope;\n  private static final String bench;\n  private static final String name = \"name\";\n  static {\n    leftRope = \"left\";\n    rightRope = \"right\";\n  }\n  static {\n    name = \"name\";\n    rightRope = \"right\";\n  }\n  public static void main(String[] args) {\n    bench = \"bench\";\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "static final variables must be set exactly once, and it must be in the declaration \nline or in a static initialization block. Line 4 doesn’t compile because bench is not set \nin either of these locations. Line 15 doesn’t compile because final variables are not \nallowed to be set after that point. Line 11 doesn’t compile because name is set twice: \nonce in the declaration and again in the static block. Line 12 doesn’t compile because \nrightRope is set twice as well. Both are in static initialization blocks.\n"
  },
  {
    "id": "oca-90",
    "question": "Which of the following can replace line 2 to make this code compile? (Choose all that apply.)\nimport java.util.*;\n// INSERT CODE HERE\npublic class Imports {\n  public void method(ArrayList<String> list) {\n    sort(list);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "import static java.util.Collections;"
      },
      {
        "key": "B",
        "text": "import static java.util.Collections.*;"
      },
      {
        "key": "C",
        "text": "import static java.util.Collections.sort(ArrayList<String>);"
      },
      {
        "key": "D",
        "text": "static import java.util.Collections;"
      },
      {
        "key": "E",
        "text": "static import java.util.Collections.*;"
      },
      {
        "key": "F",
        "text": "static import java.util.Collections.sort(ArrayList<String>);"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The two valid ways to do this are import static java.util.Collections.*; and \nimport static java.util.Collections.sort;. Option A is incorrect because you \ncan only do a static import on static members. Classes such as Collections require \na regular import. Option C is nonsense as method parameters have no business in \nan import. Options D, E, and F try to trick you into reversing the syntax of import \nstatic.\n"
  },
  {
    "id": "oca-91",
    "question": "What is the result of the following statements?\n Choose all that apply.\npublic class Test {\n  public void print(byte x) {\n    System.out.print(\"byte\");\n  }\n  public void print(int x) {\n    System.out.print(\"int\");\n  }\n  public void print(float x) {\n    System.out.print(\"float\");\n  }\n  public void print(Object x) {\n    System.out.print(\"Object\");\n  }\n\n  public static void main(String[] args) {\n    Test t = new Test();\n    short s = 123;\n    t.print(s);\n    t.print(true);\n    t.print(6.789);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "bytefloatObject"
      },
      {
        "key": "B",
        "text": "intfloatObject"
      },
      {
        "key": "C",
        "text": "byteObjectfloat"
      },
      {
        "key": "D",
        "text": "intObjectfloat"
      },
      {
        "key": "E",
        "text": "intObjectObject"
      },
      {
        "key": "F",
        "text": "byteObjectObject"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The argument on line 17 is a short. It can be promoted to an int, so print() on \nline 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a bool\u0002ean, so print() on line 11 is invoked. The argument on line 19 is a double. It can \nbe autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is \nintObjectObject and the correct answer is option E. \n"
  },
  {
    "id": "oca-92",
    "question": "What is the result of the following program?\n Choose all that apply.\npublic class Squares {\n  public static long square(int x) {\n    long y = x * (long) x;\n    x = -1;\n    return y;\n  }\n\n  public static void main(String[] args) {\n    int value = 9;\n    long result = square(value);\n    System.out.println(value);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "-1"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "81"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9"
      },
      {
        "key": "E",
        "text": "Compiler error on a different line"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays \nas 9. In the method square, x starts as 9. y becomes 81 and then x gets set to –1. Line 9 \ndoes set result to 81. However, we are printing out value and that is still 9.\n"
  },
  {
    "id": "oca-93",
    "question": "Which of the following are output by this code? (Choose all that apply.)\npublic class StringBuilders {\n  public static StringBuilder work(StringBuilder a, StringBuilder b) {\n    a = new StringBuilder(\"a\");\n    b.append(\"b\");\n    return a;\n  }\n\n  public static void main(String[] args) {\n    StringBuilder s1 = new StringBuilder(\"s1\");\n    StringBuilder s2 = new StringBuilder(\"s2\");\n    StringBuilder s3 = work(s1, s2);\n    System.out.println(\"s1 = \" + s1);\n    System.out.println(\"s2 = \" + s2);\n    System.out.println(\"s3 = \" + s3);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "s1 = a"
      },
      {
        "key": "B",
        "text": "s1 = s1"
      },
      {
        "key": "C",
        "text": "s2 = s2"
      },
      {
        "key": "D",
        "text": "s2 = s2b"
      },
      {
        "key": "E",
        "text": "s3 = a"
      },
      {
        "key": "F",
        "text": "s3 = null"
      },
      {
        "key": "G",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Since Java is pass-by-reference, assigning a new object to a does not change the \ncaller. Calling append() does affect the caller because both the method parameter and \ncaller have a reference to the same object. Finally, returning a value does pass the refer\u0002ence to the caller for assignment to s3.\n"
  },
  {
    "id": "oca-94",
    "question": "Which of the following are true? (Choose 2)",
    "choices": [
      {
        "key": "A",
        "text": "this() can be called from anywhere in a constructor"
      },
      {
        "key": "B",
        "text": "this() can be called from any instance method in the class"
      },
      {
        "key": "C",
        "text": "this.variableName can be called from any instance method in the class"
      },
      {
        "key": "D",
        "text": "this.variableName can be called from any static method in the class"
      },
      {
        "key": "E",
        "text": "You must include a default constructor if the compiler does not generate one"
      },
      {
        "key": "F",
        "text": "You can call the default constructor created by the compiler using this()"
      },
      {
        "key": "G",
        "text": "You can access a private constructor using main() method"
      }
    ],
    "answer": [
      "C",
      "G"
    ],
    "explanation": "Since the main() method is in the same class, it can call private methods in the \nclass. this() may only be called as the first line of a constructor. this.variableName\ncan be called from any instance method to refer to an instance variable. It cannot be \ncalled from a static method because there is no instance of the class to refer to. Option \nF is tricky. The default constructor is only written by the compiler if no user-defined \nconstructors were provided. this() can only be called from a constructor in the same \nclass. Since there can be no user-defined constructors in the class if a default construc\u0002tor was created, it is impossible for option F to be true. \n"
  },
  {
    "id": "oca-95",
    "question": "Which of these classes compile and use a default constructor? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public class Bird { }"
      },
      {
        "key": "B",
        "text": "public class Bird { public bird() {} }"
      },
      {
        "key": "C",
        "text": "public class Bird { public bird(String name) {} }"
      },
      {
        "key": "D",
        "text": "public class Bird { public Bird() {} }"
      },
      {
        "key": "E",
        "text": "public class Bird { Bird(String name) {} }"
      },
      {
        "key": "F",
        "text": "public class Bird { private Bird(int age) {} }"
      },
      {
        "key": "G",
        "text": "public class Bird { void Bird() {} }"
      }
    ],
    "answer": [
      "A",
      "G"
    ],
    "explanation": "Options B and C don’t compile because the constructor name must match the \nclassname. Since Java is case sensitive, these don’t match. Options D, E, and F all com\u0002pile and provide one user-defined constructor. Since a constructor is coded, a default \nconstructor isn’t supplied. Option G defines a method, but not a constructor. Option A \ndoes not define a constructor, either. Since no constructor is coded, a default construc\u0002tor is provided for options A and G.\n"
  },
  {
    "id": "oca-96",
    "question": "Which code can be inserted to have the code print 2?\n Choose all that apply.\npublic class BirdSeed {\n  private int numberBags;\n  boolean call;\n\n  public BirdSeed() {\n    // LINE 1\n    call = false;\n    // LINE 2\n  }\n\n  public BirdSeed(int numberBags) {\n    this.numberBags = numberBags;\n  }\n\n  public static void main(String[] args) {\n    BirdSeed seed = new BirdSeed();\n    System.out.println(seed.numberBags);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Replace line 1 with BirdSeed(2);"
      },
      {
        "key": "B",
        "text": "Replace line 2 with BirdSeed(2);"
      },
      {
        "key": "C",
        "text": "Replace line 1 with new BirdSeed(2);"
      },
      {
        "key": "D",
        "text": "Replace line 2 with new BirdSeed(2);"
      },
      {
        "key": "E",
        "text": "Replace line 1 with this(2);"
      },
      {
        "key": "F",
        "text": "Replace line 2 with this(2);"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Options A and B will not compile because constructors cannot be called without \nnew. Options C and D will compile but will create a new object rather than setting the \nfields in this one. Option F will not compile because this() must be the first line of a \nconstructor. Option E is correct.\n"
  },
  {
    "id": "oca-97",
    "question": "Which of the following complete the constructor so this code prints out 50? (Choose all that apply.)\npublic class Cheetah {\n  int numSpots;\n\n  public Cheetah(int numSpots) {\n    // INSERT CODE HERE\n  }\n\n  public static void main(String[] args) {\n    System.out.println(new Cheetah(50).numSpots);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "numSpots = numSpots;"
      },
      {
        "key": "B",
        "text": "numSpots = this.numSpots;"
      },
      {
        "key": "C",
        "text": "this.numSpots = numSpots;"
      },
      {
        "key": "D",
        "text": "numSpots = super.numSpots;"
      },
      {
        "key": "E",
        "text": "super.numSpots = numSpots;"
      },
      {
        "key": "F",
        "text": "None of the above"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Within the constructor numSpots refers to the constructor parameter. The instance \nvariable is hidden because they have the same name. this.numSpots tells Java to use \nthe instance variable. In the main() method, numSpots refers to the instance variable. \nOption A sets the constructor parameter to itself, leaving the instance variable as 0. \nOption B sets the constructor parameter to the value of the instance variable, making \nthem both 0. Option C is correct, setting the instance variable to the value of the con\u0002structor parameter. Options D and E do not compile.\n"
  },
  {
    "id": "oca-98",
    "question": "What is the result of the following?\n Choose all that apply.\npublic class Order {\n  static String result = \"\";\n  { result += \"c\"; }\n  static { result += \"u\"; }\n  { result += \"r\"; }\n}\n Choose all that apply.\npublic class OrderDriver {\n  public static void main(String[] args) {\n    System.out.print(Order.result + \" \");\n    System.out.print(Order.result + \" \");\n    new Order();\n    new Order();\n    System.out.print(Order.result + \" \");\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "curur"
      },
      {
        "key": "B",
        "text": "ucrcr"
      },
      {
        "key": "C",
        "text": "u ucrcr"
      },
      {
        "key": "D",
        "text": "u u curcur"
      },
      {
        "key": "E",
        "text": "u u ucrcr"
      },
      {
        "key": "F",
        "text": "ur ur urc"
      },
      {
        "key": "G",
        "text": "Code does not compile"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "On line 3 of OrderDriver, we refer to Order for the first time. At this point the stat\u0002ics in Order get initialized. In this case, the statics are the static declaration of result\nand the static initializer. result is u at this point. On line 4, result is the same \nbecause the static initialization is only run once. On line 5, we create a new Order, \nwhich triggers the instance initializers in the order they appear in the file. Now result\nis ucr. Line 6 creates another Order, triggering another set of initializers. Now result\nis ucrcr. Notice how the static is on a different line than the initialization code in \nlines 4–5 of Order. The exam may try to trick you by formatting the code like this to \nconfuse you.\n"
  },
  {
    "id": "oca-99",
    "question": "What is the result of the following?\n Choose all that apply.\npublic class Order {\n  String value = \"t\";\n  { value += \"a\"; }\n  { value += \"c\"; }\n\n  public Order() {\n    value += \"b\";\n  }\n\n  public Order(String s) {\n    value += s;\n  }\n\n  public static void main(String[] args) {\n    Order order = new Order(\"f\");\n    order = new Order();\n    System.out.println(order.value);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "tacb"
      },
      {
        "key": "B",
        "text": "tacf"
      },
      {
        "key": "C",
        "text": "tacbf"
      },
      {
        "key": "D",
        "text": "tacfb"
      },
      {
        "key": "E",
        "text": "tacftacb"
      },
      {
        "key": "F",
        "text": "Code does not compile"
      },
      {
        "key": "G",
        "text": "Exception is thrown"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Line 4 instantiates an Order. Java runs the declarations and instance initializers first \nin the order they appear. This sets value to tacf. Line 5 creates another Order and \ninitializes value to tacb. The object on line 5 is stored in the same variable line 4 used. \nThis makes the object created on line 4 unreachable. When value is printed, it is the \ninstance variable in the object created on line 5.\n"
  },
  {
    "id": "oca-100",
    "question": "Which of the following will compile in the code below? (Choose all that apply.)\npublic class Order3 {\n  final String value1 = \"1\";\n  static String value2 = \"2\";\n  String value3 = \"3\";\n\n  {\n    // CODE SNIPPET 1\n  }\n\n  static {\n    // CODE SNIPPET 2\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "value1 = \"d\"; // at CODE SNIPPET 1"
      },
      {
        "key": "B",
        "text": "value2 = \"e\"; // at CODE SNIPPET 1"
      },
      {
        "key": "C",
        "text": "value3 = \"f\"; // at CODE SNIPPET 1"
      },
      {
        "key": "D",
        "text": "value1 = \"g\"; // at CODE SNIPPET 2"
      },
      {
        "key": "E",
        "text": "value2 = \"h\"; // at CODE SNIPPET 2"
      },
      {
        "key": "F",
        "text": "value3 = \"i\"; // at CODE SNIPPET 2"
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "value1 is a final instance variable. It can only be set once: in the variable dec\u0002laration, an instance initializer, or a constructor. Option A does not compile because \nthe final variable was already set in the declaration. value2 is a static variable. Both \ninstance and static initializers are able to access static variables, making options B \nand E correct. value3 is an instance variable. Options D and F do not compile because \na static initializer does not have access to instance variables. \n"
  },
  {
    "id": "oca-101",
    "question": "Which are true about the following code? (Choose all that apply.)\npublic class Create {\n  Create() { System.out.print(\"1 \"); }\n  Create(int num) { System.out.print(\"2 \"); }\n  Create(Integer num) { System.out.print(\"3 \"); }\n  Create(Object num) { System.out.print(\"4 \"); }\n  Create(int... nums) { System.out.print(\"5 \"); }\n\n  public static void main(String[] args) {\n    new Create(100);\n    new Create(1000L);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Prints: 2 4"
      },
      {
        "key": "B",
        "text": "Prints: 3 4"
      },
      {
        "key": "C",
        "text": "Prints: 4 2"
      },
      {
        "key": "D",
        "text": "Prints: 4 4"
      },
      {
        "key": "E",
        "text": "Prints: 3 4 if Create(int) is removed"
      },
      {
        "key": "F",
        "text": "Prints: 4 4 if Create(int) is removed"
      },
      {
        "key": "G",
        "text": "Prints: 5 4 if Create(int) is removed"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The 100 parameter is an int and so calls the matching int constructor. When \nthis constructor is removed, Java looks for the next most specific constructor. Java pre\u0002fers autoboxing to varargs, and so chooses the Integer constructor. The 100L param\u0002eter is a long. Since it can’t be converted into a smaller type, it is autoboxed into a Long\nand then the constructor for Object is called. \n"
  },
  {
    "id": "oca-102",
    "question": "What is the result of the following class?\n Choose all that apply.\nimport java.util.function.*;\n\npublic class Panda {\n  int age;\n\n  public static void main(String[] args) {\n    Panda p1 = new Panda();\n    p1.age = 1;\n    check(p1, p -> p.age < 5);\n  }\n\n  private static void check(Panda panda, Predicate<Panda> pred) {\n    String result = pred.test(panda) ? \"match\" : \"not match\";\n    System.out.print(result);\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on line 11"
      },
      {
        "key": "F",
        "text": "Runtime exception"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "This code is correct. Line 8 creates a lambda expression that checks if the age is less \nthan 5. Since there is only one parameter and it does not specify a type, the parentheses \naround the type parameter are optional. Line 10 uses the Predicate interface, which \ndeclares a test() method.\n"
  },
  {
    "id": "oca-103",
    "question": "What is the result of the following code?\n Choose all that apply.\ninterface Climb {\n  boolean isTooHigh(int height, int limit);\n}\n\npublic class Climber {\n  public static void main(String[] args) {\n    check((h, l) -> h.append(l).isEmpty(), 5);\n  }\n\n  private static void check(Climb climb, int height) {\n    if (climb.isTooHigh(height, 10))\n      System.out.println(\"too high\");\n    else\n      System.out.println(\"ok\");\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "ok"
      },
      {
        "key": "B",
        "text": "too high"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7"
      },
      {
        "key": "D",
        "text": "Compiler error on line 10"
      },
      {
        "key": "E",
        "text": "Compiler error on different line"
      },
      {
        "key": "F",
        "text": "Runtime exception"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The interface takes two int parameters. The code on line 7 attempts to use them as \nif one is a StringBuilder. It is tricky to use types in a lambda when they are implicitly \nspecified. Remember to check the interface for the real type.\n"
  },
  {
    "id": "oca-104",
    "question": "Which of the following lambda expressions can fill in the blank? (Choose all that apply.)\nList<String> list = new ArrayList<>();\nlist.removeIf(_________________);",
    "choices": [
      {
        "key": "A",
        "text": "s -> s.isEmpty()"
      },
      {
        "key": "B",
        "text": "s -> {s.isEmpty()}"
      },
      {
        "key": "C",
        "text": "s -> {s.isEmpty();}"
      },
      {
        "key": "D",
        "text": "s -> { return s.isEmpty(); }"
      },
      {
        "key": "E",
        "text": "String s -> s.isEmpty()"
      },
      {
        "key": "F",
        "text": "(String s) -> s.isEmpty()"
      }
    ],
    "answer": [
      "A",
      "D",
      "F"
    ],
    "explanation": "removeIf() expects a Predicate, which takes a parameter list of one param\u0002eter using the specified type. Options B and C are incorrect because they do not use the \nreturn keyword. It is required inside braces for lambda bodies. Option E is incorrect \nbecause it is missing the parentheses around the parameter list. This is only optional \nfor a single parameter with an inferred type.\n"
  },
  {
    "id": "oca-105",
    "question": "Which lambda can replace the MySecret class to return the same value? (Choose all that apply.)\ninterface Secret {\n  String magic(double d);\n}\n\nclass MySecret implements Secret {\n  public String magic(double d) {\n    return \"Poof\";\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "caller((e) -> \"Poof\");"
      },
      {
        "key": "B",
        "text": "caller((e) -> {\"Poof\"});"
      },
      {
        "key": "C",
        "text": "caller((e) -> { String e = \"\"; \"Poof\" });"
      },
      {
        "key": "D",
        "text": "caller((e) -> { String e = \"\"; return \"Poof\"; });"
      },
      {
        "key": "E",
        "text": "caller((e) -> { String e = \"\"; return \"Poof\" });"
      },
      {
        "key": "F",
        "text": "caller((e) -> { String f = \"\"; return \"Poof\"; });"
      }
    ],
    "answer": [
      "A",
      "F"
    ],
    "explanation": "Option B is incorrect because it does not use the return keyword. Options C, D, \nand E are incorrect because the variable e is already in use from the lambda and can\u0002not be redefined. Additionally, option C is missing the return keyword and option E is \nmissing the semicolon.\n"
  },
  {
    "id": "oca-106",
    "question": "What modifiers are implicitly applied to all interface methods?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "protected"
      },
      {
        "key": "B",
        "text": "public"
      },
      {
        "key": "C",
        "text": "static"
      },
      {
        "key": "D",
        "text": "void"
      },
      {
        "key": "E",
        "text": "abstract"
      },
      {
        "key": "F",
        "text": "default"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "All interface methods are implicitly public, so option B is correct and option A is \nnot. Interface methods may be declared as static or default but are never implicitly \nadded, so options C and F are incorrect. Option D is incorrect—void is not a modifier; \nit is a return type. Option E is a tricky one, because prior to Java 8 all interface meth\u0002ods would be assumed to be abstract. Since Java 8 now includes default and static \nmethods and they are never abstract, you cannot assume the abstract modifier will be \nimplicitly applied to all methods by the compiler.\n"
  },
  {
    "id": "oca-107",
    "question": "What is the output of the following code?\n\nclass Mammal {\n    public Mammal(int age) {\n        System.out.print(\"Mammal\");\n    }\n}\npublic class Platypus extends Mammal {\n    public Platypus() {\n        System.out.print(\"Platypus\");\n    }\n    public static void main(String[] args) {\n        new Mammal(5);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Platypus"
      },
      {
        "key": "B",
        "text": "Mammal"
      },
      {
        "key": "C",
        "text": "PlatypusMammal"
      },
      {
        "key": "D",
        "text": "MammalPlatypus"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 11."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code will not compile because the parent class Mammal doesn’t define a no-argu\u0002ment constructor, so the first line of a Platypus constructor should be an explicit call \nto super(int age). If there was such a call, then the output would be MammalPlatypus, \nsince the super constructor is executed before the child constructor.\n"
  },
  {
    "id": "oca-108",
    "question": "Which statements can be inserted in the blank line so that the code will compile?\n(Choose all that apply.)\n\n\npublic interface CanHop {}\npublic class Frog implements CanHop {\n    public static void main(String[] args) {\n        frog = new TurtleFrog();\n    }\n}\npublic class BrazilianHornedFrog extends Frog {}\npublic class TurtleFrog extends Frog {}",
    "choices": [
      {
        "key": "A",
        "text": "Frog"
      },
      {
        "key": "B",
        "text": "TurtleFrog"
      },
      {
        "key": "C",
        "text": "BrazilianHornedFrog"
      },
      {
        "key": "D",
        "text": "CanHop"
      },
      {
        "key": "E",
        "text": "Object"
      },
      {
        "key": "F",
        "text": "Long"
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "The blank can be filled with any class or interface that is a supertype of \nTurtleFrog. Option A is a superclass of TurtleFrog, and option B is the same class, \nso both are correct. BrazilianHornedFrog is not a superclass of TurtleFrog, so option \nC is incorrect. TurtleFrog inherits the CanHope interface, so option D is correct. All \nclasses inherit Object, so option E is correct. Finally, Long is an unrelated class that is \nnot a superclass of TurtleFrog, and is therefore incorrect.\n"
  },
  {
    "id": "oca-109",
    "question": "Which statements are correct about the following code?\n(Choose all that apply.)\n\n\npublic class Rodent {\n    protected static Integer chew() throws Exception {\n        System.out.println(\"Rodent is chewing\");\n        return 1;\n    }\n}\npublic class Beaver extends Rodent {\n    public Number chew() throws RuntimeException {\n        System.out.println(\"Beaver is chewing on wood\");\n        return 2;\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "It will compile without issue."
      },
      {
        "key": "B",
        "text": "It fails to compile because the exception type is incorrect."
      },
      {
        "key": "C",
        "text": "It fails to compile because return types are not covariant."
      },
      {
        "key": "D",
        "text": "It fails due to visibility mismatch."
      },
      {
        "key": "E",
        "text": "It fails to compile because of a static modifier mismatch."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The code doesn’t compile, so option A is incorrect. Option B is also not correct \nbecause the rules for overriding a method allow a subclass to define a method with an \nexception that is a subclass of the exception in the parent method. Option C is cor\u0002rect because the return types are not covariant; in particular, Number is not a subclass \nof Integer. Option D is incorrect because the subclass defines a method that is more \naccessible than the method in the parent class, which is allowed. Finally, option E is \ncorrect because the method is declared as static in the parent class and not so in the \nchild class. For nonprivate methods in the parent class, both methods must use static\n(hide) or neither should use static (override).\n"
  },
  {
    "id": "oca-110",
    "question": "Which of the following may only be hidden and not overridden?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "private instance methods"
      },
      {
        "key": "B",
        "text": "protected instance methods"
      },
      {
        "key": "C",
        "text": "public instance methods"
      },
      {
        "key": "D",
        "text": "static methods"
      },
      {
        "key": "E",
        "text": "public variables"
      },
      {
        "key": "F",
        "text": "private variables"
      }
    ],
    "answer": [
      "A",
      "D",
      "E",
      "F"
    ],
    "explanation": "First off, options B and C are incorrect because protected and public meth\u0002ods may be overridden, not hidden. Option A is correct because private methods are \nalways hidden in a subclass. Option D is also correct because static methods cannot \nbe overridden, only hidden. Options E and F are correct because variables may only be \nhidden, regardless of the access modifier.\n"
  },
  {
    "id": "oca-111",
    "question": "Choose the correct statement about this code:\n\ninterface HasExoskeleton {\n    abstract int getNumberOfSections();\n}\nabstract class Insect implements HasExoskeleton {\n    abstract int getNumberOfLegs();\n}\npublic class Beetle extends Insect {\n    int getNumberOfLegs() { return 6; }\n}",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "It compiles but throws exception at runtime."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code fails to compile because Beetle, the first concrete subclass, doesn’t imple\u0002ment getNumberOfSections(), which is inherited as an abstract method; therefore, \noption D is correct. Option B is incorrect because there is nothing wrong with this \ninterface method definition. Option C is incorrect because an abstract class is not \nrequired to implement any abstract methods, including those inherited from an inter\u0002face. Option E is incorrect because the code fails at compilation-time.\n"
  },
  {
    "id": "oca-112",
    "question": "Which of the following statements about polymorphism are true?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A reference may be cast to a subclass without explicit cast."
      },
      {
        "key": "B",
        "text": "If a method takes a superclass, any subclass can be passed."
      },
      {
        "key": "C",
        "text": "A method with Object parameter can accept any reference."
      },
      {
        "key": "D",
        "text": "All cast exceptions can be detected at compile-time."
      },
      {
        "key": "E",
        "text": "Defining a method in superclass ensures parent method is called at runtime."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "A reference to an object requires an explicit cast if referenced with a subclass, \nso option A is incorrect. If the cast is to a superclass reference, then an explicit cast is \nnot required. Because of polymorphic parameters, if a method takes the superclass of \nan object as a parameter, then any subclass references may be used without a cast, so \noption B is correct. All objects extend java.lang.Object, so if a method takes that \ntype, any valid object, including null, may be passed; therefore, option C is correct. \nSome cast exceptions can be detected as errors at compile-time, but others can only be \ndetected at runtime, so D is incorrect. Due to the nature of polymorphism, a public\ninstance method can be overridden in a subclass and calls to it will be replaced even in \nthe superclass it was defined, so E is incorrect.\n"
  },
  {
    "id": "oca-113",
    "question": "Choose the correct statement about this code:\n\npublic interface Herbivore {\n    int amount = 10;\n    public static void eatGrass();\n    public int chew() {\n        return 13;\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "E",
        "text": "The code will not compile because of lines 2 and 3."
      },
      {
        "key": "F",
        "text": "The code will not compile because of lines 3 and 4."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The interface variable amount is correctly declared, with public and static being \nassumed and automatically inserted by the compiler, so option B is incorrect. The \nmethod declaration for eatGrass() on line 3 is incorrect because the method has been \nmarked as static but no method body has been provided. The method declaration for \nchew() on line 4 is also incorrect, since an interface method that provides a body must \nbe marked as default or static explicitly. Therefore, option F is the correct answer \nsince this code contains two compile-time errors.\n"
  },
  {
    "id": "oca-114",
    "question": "Choose the correct statement about this code:\n\npublic interface CanFly {\n    void fly();\n}\ninterface HasWings {\n    public abstract Object getWindSpan();\n}\nabstract class Falcon implements CanFly, HasWings {}",
    "choices": [
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "Compilation error due to line 2"
      },
      {
        "key": "C",
        "text": "Compilation error due to line 4"
      },
      {
        "key": "D",
        "text": "Compilation error due to line 5"
      },
      {
        "key": "E",
        "text": "Compilation error due to lines 2 and 5"
      },
      {
        "key": "F",
        "text": "Class Falcon must implement interface methods"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Although the definition of methods on lines 2 and 5 vary, both will be converted to \npublic abstract by the compiler. Line 4 is fine, because an interface can have pub\u0002lic or default access. Finally, the class Falcon doesn’t need to implement the interface \nmethods because it is marked as abstract. Therefore, the code will compile without \nissue.\n"
  },
  {
    "id": "oca-115",
    "question": "Which statements are true for both abstract classes and interfaces?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "All methods are assumed abstract"
      },
      {
        "key": "B",
        "text": "Both can contain public static final variables"
      },
      {
        "key": "C",
        "text": "Both can be extended using extends"
      },
      {
        "key": "D",
        "text": "Both can contain default methods"
      },
      {
        "key": "E",
        "text": "Both can contain static methods"
      },
      {
        "key": "F",
        "text": "Neither can be instantiated directly"
      },
      {
        "key": "G",
        "text": "Both inherit from java.lang.Object"
      }
    ],
    "answer": [
      "B",
      "C",
      "E",
      "F"
    ],
    "explanation": "Option A is wrong, because an abstract class may contain concrete meth\u0002ods. Since Java 8, interfaces may also contain concrete methods in form of static or \ndefault methods. Although all variables in interfaces are assumed to be public static \nfinal, abstract classes may contain them as well, so option B is correct. Both abstract \nclasses and interfaces can be extended with the extends keyword, so option C is cor\u0002rect. Only interfaces can contain default methods, so option D is incorrect. Both \nabstract classes and interfaces can contain static methods, so option E is correct. Both \nstructures require a concrete subclass to be instantiated, so option F is correct. Finally, \nthough an instance of an object that implements an interface inherits java.lang.\nObject, the interface itself doesn’t; otherwise, Java would support multiple inheritance \nfor objects, which it doesn’t. Therefore, option G is incorrect.\n"
  },
  {
    "id": "oca-116",
    "question": "What modifiers are assumed for all interface variables?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "public"
      },
      {
        "key": "B",
        "text": "protected"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "static"
      },
      {
        "key": "E",
        "text": "final"
      },
      {
        "key": "F",
        "text": "abstract"
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "Interface variables are assumed to be public static final; therefore, options \nA, D, and E are correct. Options B and C are incorrect because interface variables must \nbe public—interfaces are implemented by classes, not inherited by interfaces. Option F \nis incorrect because variables can never be abstract.\n"
  },
  {
    "id": "oca-117",
    "question": "What is the output of the following code?\n\ninterface Nocturnal {\n    default boolean isBlind() { return true; }\n}\npublic class Owl implements Nocturnal {\n    public boolean isBlind() { return false; }\n    public static void main(String[] args) {\n        Nocturnal nocturnal = (Nocturnal) new Owl();\n        System.out.println(nocturnal.isBlind());\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "true"
      },
      {
        "key": "B",
        "text": "false"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This code compiles and runs without issue, outputting false, so option B is the \ncorrect answer. The first declaration of isBlind() is as a default interface method, \nassumed public. The second declaration of isBlind() correctly overrides the default \ninterface method. Finally, the newly created Owl instance may be automatically cast to \na Nocturnal reference without an explicit cast, although adding it doesn’t break the \ncode.\n"
  },
  {
    "id": "oca-118",
    "question": "What is the output of the following code?\n\nclass Arthropod {\n    public void printName(double input) {\n        System.out.print(\"Arthropod\");\n    }\n}\npublic class Spider extends Arthropod {\n    public void printName(int input) {\n        System.out.print(\"Spider\");\n    }\n    public static void main(String[] args) {\n        Spider spider = new Spider();\n        spider.printName(4);\n        spider.printName(9.0);\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "SpiderArthropod"
      },
      {
        "key": "B",
        "text": "ArthropodSpider"
      },
      {
        "key": "C",
        "text": "SpiderSpider"
      },
      {
        "key": "D",
        "text": "ArthropodArthropod"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 9"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so options E and F are incorrect. The \nprintName() method is an overload in Spider, not an override, so both methods may \nbe called. The call on line 8 references the version that takes an int as input defined \nin the Spider class, and the call on line 9 references the version in the Arthropod class \nthat takes a double. Therefore, SpiderArthropod is output and option A is the correct \nanswer.\n"
  },
  {
    "id": "oca-119",
    "question": "Which statements are true about the following code?\n(Choose all that apply.)\n\n\ninterface HasVocalCords {\n    public abstract void makeSound();\n}\npublic interface CanBark extends HasVocalCords {\n    public void bark();\n}",
    "choices": [
      {
        "key": "A",
        "text": "The CanBark interface doesn’t compile"
      },
      {
        "key": "B",
        "text": "A class implementing HasVocalCords must override makeSound()"
      },
      {
        "key": "C",
        "text": "A class implementing CanBark inherits both methods"
      },
      {
        "key": "D",
        "text": "A class implementing CanBark only inherits bark()"
      },
      {
        "key": "E",
        "text": "An interface cannot extend another interface"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles without issue, so option A is wrong. Option B is incorrect, since \nan abstract class could implement HasVocalCords without the need to override the \nmakeSound() method. Option C is correct; any class that implements CanBark auto\u0002matically inherits its methods, as well as any inherited methods defined in the parent \ninterface. Because option C is correct, it follows that option D is incorrect. Finally, an \ninterface can extend multiple interfaces, so option E is incorrect.\n"
  },
  {
    "id": "oca-120",
    "question": "Which of the following is true about a concrete subclass?\n(Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "A concrete subclass can be declared as abstract"
      },
      {
        "key": "B",
        "text": "Must implement all inherited abstract methods"
      },
      {
        "key": "C",
        "text": "Must implement all interface methods"
      },
      {
        "key": "D",
        "text": "Cannot be marked as final"
      },
      {
        "key": "E",
        "text": "Abstract methods cannot be overridden"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Concrete classes are, by definition, not abstract, so option A is incorrect. A concrete \nclass must implement all inherited abstract methods, so option B is correct. Option C \nis incorrect; a superclass may have already implemented an inherited interface, so the \nconcrete subclass would not need to implement the method. Concrete classes can be \nboth final and not final, so option D is incorrect. Finally, abstract methods must be \noverridden by a concrete subclass, so option E is incorrect.\n"
  },
  {
    "id": "oca-121",
    "question": "What is the output of the following code?\n\nabstract class Reptile {\n    public final void layEggs() {\n        System.out.println(\"Reptile laying eggs\");\n    }\n    public static void main(String[] args) {\n        Reptile reptile = new Lizard();\n        reptile.layEggs();\n    }\n}\npublic class Lizard extends Reptile {\n    public void layEggs() {\n        System.out.println(\"Lizard laying eggs\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Reptile laying eggs"
      },
      {
        "key": "B",
        "text": "Lizard laying eggs"
      },
      {
        "key": "C",
        "text": "Compilation error at line 4"
      },
      {
        "key": "D",
        "text": "Compilation error at line 5"
      },
      {
        "key": "E",
        "text": "Compilation error at line 9"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code doesn’t compile, so options A and B are incorrect. The issue with line 9 is \nthat layEggs() is marked as final in the superclass Reptile, which means it cannot be \noverridden. There are no errors on any other lines, so options C and D are incorrect.\n"
  },
  {
    "id": "oca-122",
    "question": "What is the output of the following code?\n\npublic abstract class Whale {\n    public abstract void dive() {};\n    public static void main(String[] args) {\n        Whale whale = new Orca();\n        whale.dive();\n    }\n}\nclass Orca extends Whale {\n    public void dive(int depth) {\n        System.out.println(\"Orca diving\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Orca diving"
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 8"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 9"
      },
      {
        "key": "E",
        "text": "Output cannot be determined"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This may look like a complex question, but it is actually quite easy. Line 2 contains \nan invalid definition of an abstract method. Abstract methods cannot contain a body, \nso the code will not compile and option B is the correct answer. If the body {} was \nremoved from line 2, the code would still not compile, although it would be line 8 that \nwould throw the compilation error. Since dive() in Whale is abstract and Orca extends \nWhale, then it must implement an overridden version of dive(). The method on line \n9 is an overloaded version of dive(), not an overridden version, so Orca is an invalid \nsubclass and will not compile.\n"
  },
  {
    "id": "oca-123",
    "question": "What is the output of the following code?\n\ninterface Aquatic {\n    public default int getNumberOfGills(int input) { return 2; }\n}\npublic class ClownFish implements Aquatic {\n    public String getNumberOfGills() { return \"4\"; }\n    public String getNumberOfGills(int input) { return \"6\"; }\n    public static void main(String[] args) {\n        System.out.println(new ClownFish().getNumberOfGills(-1));\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "Compilation error at line 5"
      },
      {
        "key": "E",
        "text": "Compilation error at line 6"
      },
      {
        "key": "F",
        "text": "Compilation error at line 8"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code doesn’t compile because line 6 contains an incompatible override of the \ngetNumberOfGills(int input) method defined in the Aquatic interface. In particular, \nint and String are not covariant returns types, since int is not a subclass of String. \nNote that line 5 compiles without issue; getNumberOfGills() is an overloaded method \nthat is not related to the parent interface method that takes an int value.\n"
  },
  {
    "id": "oca-124",
    "question": "Which statements can be inserted in the blank so that the code compiles?\n(Choose all that apply.)\n\n\npublic class Snake {}\npublic class Cobra extends Snake {}\npublic class GardenSnake {}\npublic class SnakeHandler {\n    private Snake snake;\n    public void setSnake(Snake snake) {\n        this.snake = snake;\n    }\n    public static void main(String[] args) {\n        new SnakeHandler().setSnake( );\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "new Cobra()"
      },
      {
        "key": "B",
        "text": "new GardenSnake()"
      },
      {
        "key": "C",
        "text": "new Snake()"
      },
      {
        "key": "D",
        "text": "new Object()"
      },
      {
        "key": "E",
        "text": "new String(\"Snake\")"
      },
      {
        "key": "F",
        "text": "null"
      }
    ],
    "answer": [
      "A",
      "C",
      "F"
    ],
    "explanation": "First off, Cobra is a subclass of Snake, so option A can be used. GardenSnake is \nnot defined as a subclass of Snake, so it cannot be used and option B is incorrect. The \nclass Snake is not marked as abstract, so it can be instantiated and passed, so option \nC is correct. Next, Object is a superclass of Snake, not a subclass, so it also cannot be \nused and option D is incorrect. The class String is unrelated in this example, so option \nE is incorrect. Finally, a null value can always be passed as an object value, regardless \nof type, so option F is correct.\n"
  },
  {
    "id": "oca-125",
    "question": "What is the result of the following code?\n\npublic abstract class Bird {\n    private void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n    public static void main(String[] args) {\n        Bird bird = new Pelican();\n        bird.fly();\n    }\n}\nclass Pelican extends Bird {\n    protected void fly() {\n        System.out.println(\"Pelican is flying\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Bird is flying"
      },
      {
        "key": "B",
        "text": "Pelican is flying"
      },
      {
        "key": "C",
        "text": "Compilation error at line 4"
      },
      {
        "key": "D",
        "text": "Compilation error at line 5"
      },
      {
        "key": "E",
        "text": "Compilation error at line 9"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so options C, D, and E are incorrect. \nThe trick here is that the method fly() is marked as private in the parent class Bird, \nwhich means it may only be hidden, not overridden. With hidden methods, the specific \nmethod used depends on where it is referenced. Since it is referenced within the Bird\nclass, the method declared on line 2 was used, and option A is correct. Alternatively, \nif the method was referenced within the Pelican class, or if the method in the parent \nclass was marked as protected and overridden in the subclass, then the method on line \n9 would have been used.\n"
  },
  {
    "id": "oca-126",
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Runtime exceptions are the same thing as checked exceptions."
      },
      {
        "key": "B",
        "text": "Runtime exceptions are the same thing as unchecked exceptions."
      },
      {
        "key": "C",
        "text": "You can declare only checked exceptions."
      },
      {
        "key": "D",
        "text": "You can declare only unchecked exceptions."
      },
      {
        "key": "E",
        "text": "You can handle only Exception subclasses."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Runtime exceptions are also known as unchecked exceptions. They are allowed \nto be declared, but they don’t have to be. Checked exceptions must be handled or \ndeclared. Legally, you can handle java.lang.Error subclasses, but it’s not a good idea.\n"
  },
  {
    "id": "oca-127",
    "question": "Which of the following pairs fill in the blanks to make this code compile? (Choose all that apply.)\n\n7: public void ohNo() _____ Exception {\n8: _____________ Exception();\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "On line 7, fill in throw"
      },
      {
        "key": "B",
        "text": "On line 7, fill in throws"
      },
      {
        "key": "C",
        "text": "On line 8, fill in throw"
      },
      {
        "key": "D",
        "text": "On line 8, fill in throw new"
      },
      {
        "key": "E",
        "text": "On line 8, fill in throws"
      },
      {
        "key": "F",
        "text": "On line 8, fill in throws new"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "In a method declaration, the keyword throws is used. To actually throw an \nexception, the keyword throw is used and a new exception is created.\n"
  },
  {
    "id": "oca-128",
    "question": "When are you required to use a finally block in a regular try statement (not a try-with-resources)?",
    "choices": [
      {
        "key": "A",
        "text": "Never."
      },
      {
        "key": "B",
        "text": "When the program code doesn’t terminate on its own."
      },
      {
        "key": "C",
        "text": "When there are no catch blocks in a try statement."
      },
      {
        "key": "D",
        "text": "When there is exactly one catch block in a try statement."
      },
      {
        "key": "E",
        "text": "When there are two or more catch blocks in a try statement."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A try statement is required to have a catch clause and/or finally clause. If it goes \nthe catch route, it is allowed to have multiple catch clauses.\n"
  },
  {
    "id": "oca-129",
    "question": "Which exception will the following throw?\n\nObject obj = new Integer(3);\nString str = (String) obj;\nSystem.out.println(str);",
    "choices": [
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "ClassCastException"
      },
      {
        "key": "C",
        "text": "IllegalArgumentException"
      },
      {
        "key": "D",
        "text": "NumberFormatException"
      },
      {
        "key": "E",
        "text": "None of the above."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The second line tries to cast an Integer to a String. Since String does not extend \nInteger, this is not allowed and a ClassCastException is thrown.\n"
  },
  {
    "id": "oca-130",
    "question": "Which of the following exceptions are thrown by the JVM? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "ExceptionInInitializerError"
      },
      {
        "key": "C",
        "text": "java.io.IOException"
      },
      {
        "key": "D",
        "text": "NullPointerException"
      },
      {
        "key": "E",
        "text": "NumberFormatException"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "java.io.IOException is thrown by many methods in the java.io package, \nbut it is always thrown programmatically. The same is true for NumberFormatExcep\u0002tion; it is thrown programmatically by the wrapper classes of java.lang. The other \nthree exceptions are all thrown by the JVM when the corresponding problem arises.\n"
  },
  {
    "id": "oca-131",
    "question": "What will happen if you add the statement System.out.println(5 / 0); to a working main() method?",
    "choices": [
      {
        "key": "A",
        "text": "It will not compile."
      },
      {
        "key": "B",
        "text": "It will not run."
      },
      {
        "key": "C",
        "text": "It will run and throw an ArithmeticException."
      },
      {
        "key": "D",
        "text": "It will run and throw an IllegalArgumentException."
      },
      {
        "key": "E",
        "text": "None of the above."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The compiler tests the operation for a valid type but not a valid result, so the code \nwill still compile and run. At runtime, evaluation of the parameter takes place before \npassing it to the print() method, so an ArithmeticException object is raised.\n"
  },
  {
    "id": "oca-132",
    "question": "What is printed besides the stack trace caused by the NullPointerException from line 16?\n\npublic class DoSomething {\n    public void go() {\n        System.out.print(\"A\");\n        try {\n            stop();\n        } catch (ArithmeticException e) {\n            System.out.print(\"B\");\n        } finally {\n            System.out.print(\"C\");\n        }\n        System.out.print(\"D\");\n    }\n    public void stop() {\n        System.out.print(\"E\");\n        Object x = null;\n        x.toString();\n        System.out.print(\"F\");\n    }\n    public static void main(String[] args) {\n        new DoSomething().go();\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "AE"
      },
      {
        "key": "B",
        "text": "AEBCD"
      },
      {
        "key": "C",
        "text": "AEC"
      },
      {
        "key": "D",
        "text": "AECD"
      },
      {
        "key": "E",
        "text": "No output appears other than the stack trace."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The main() method invokes go and A is printed on line 3. The stop method is \ninvoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop\nimmediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the \ngo method ends as well, but not before its finally block executes and C is printed on \nline 9. Because main() doesn’t catch the exception, the stack trace displays and no fur\u0002ther output occurs, so AEC was the output printed before the stack trace. \n"
  },
  {
    "id": "oca-133",
    "question": "What is the output of the following snippet, assuming a and b are both 0?\n\ntry {\n    return a / b;\n} catch (RuntimeException e) {\n    return -1;\n} catch (ArithmeticException e) {\n    return 0;\n} finally {\n    System.out.print(\"done\");\n}",
    "choices": [
      {
        "key": "A",
        "text": "-1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "done-1"
      },
      {
        "key": "D",
        "text": "done0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The order of catch blocks is important because they’re checked in the order they \nappear after the try block. Because ArithmeticException is a child class of Runtime\u0002Exception, the catch block on line 7 is unreachable. (If an ArithmeticException is \nthrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error \nbecause it is unreachable code.\n"
  },
  {
    "id": "oca-134",
    "question": "What is the output of the following program?\n\npublic class Laptop {\n    public void start() {\n        try {\n            System.out.print(\"Starting up \");\n            throw new Exception();\n        } catch (Exception e) {\n            System.out.print(\"Problem \");\n            System.exit(0);\n        } finally {\n            System.out.print(\"Shutting down \");\n        }\n    }\n    public static void main(String[] args) {\n        new Laptop().start();\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Starting up"
      },
      {
        "key": "B",
        "text": "Starting up Problem"
      },
      {
        "key": "C",
        "text": "Starting up Problem Shutting down"
      },
      {
        "key": "D",
        "text": "Starting up Shutting down"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The main() method invokes start on a new Laptop object. Line 4 prints Starting \nup; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints \nProblem, and then line 8 calls System.exit, which terminates the JVM. The finally\nblock does not execute because the JVM is no longer running.\n"
  },
  {
    "id": "oca-135",
    "question": "What is the output of the following program?\n\npublic class Dog {\n    public String name;\n    public void parseName() {\n        System.out.print(\"1\");\n        try {\n            System.out.print(\"2\");\n            int x = Integer.parseInt(name);\n            System.out.print(\"3\");\n        } catch (NumberFormatException e) {\n            System.out.print(\"4\");\n        }\n    }\n    public static void main(String[] args) {\n        Dog leroy = new Dog();\n        leroy.name = \"Leroy\";\n        leroy.parseName();\n        System.out.print(\"5\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "1234"
      },
      {
        "key": "C",
        "text": "1235"
      },
      {
        "key": "D",
        "text": "124"
      },
      {
        "key": "E",
        "text": "1245"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The parseName method is invoked within main() on a new Dog object. Line 4 prints \n\"1\". The try block executes and 2 is printed. Line 7 throws a NumberFormatException, so \nline 8 doesn’t execute. The exception is caught on line 9, and line 10 prints 4. Because the \nexception is handled, execution resumes normally. parseName runs to completion, and \nline 17 executes, printing 5. That’s the end of the program, so the output is 1245.\n"
  },
  {
    "id": "oca-136",
    "question": "What is the output of the following program?\n\npublic class Cat {\n    public String name;\n    public void parseName() {\n        System.out.print(\"1\");\n        try {\n            System.out.print(\"2\");\n            int x = Integer.parseInt(name);\n            System.out.print(\"3\");\n        } catch (NullPointerException e) {\n            System.out.print(\"4\");\n        }\n        System.out.print(\"5\");\n    }\n    public static void main(String[] args) {\n        Cat leo = new Cat();\n        leo.name = \"Leo\";\n        leo.parseName();\n        System.out.print(\"6\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "12, followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "B",
        "text": "124, followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "C",
        "text": "12456"
      },
      {
        "key": "D",
        "text": "12456"
      },
      {
        "key": "E",
        "text": "1256, followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The parseName method is invoked on a new Cat object. Line 4 prints 1. The try\nblock is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t \ncaught, so parseName ends. main() doesn’t catch the exception either, so the program \nterminates and the stack trace for the NumberFormatException is printed.\n"
  },
  {
    "id": "oca-137",
    "question": "What is printed by the following? (Choose all that apply.)\n\npublic class Mouse {\n    public String name;\n    public void run() {\n        System.out.print(\"1\");\n        try {\n            System.out.print(\"2\");\n            name.toString();\n            System.out.print(\"3\");\n        } catch (NullPointerException e) {\n            System.out.print(\"4\");\n            throw e;\n        }\n        System.out.print(\"5\");\n    }\n    public static void main(String[] args) {\n        Mouse jerry = new Mouse();\n        jerry.run();\n        System.out.print(\"6\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The stack trace for a NullPointerException"
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "G"
    ],
    "explanation": "The main() method invokes run on a new Mouse object. Line 4 prints 1 and \nline 6 prints 2, so options A and B are correct. Line 7 throws a NullPointerException, \nwhich causes line 8 to be skipped, so C is incorrect. The exception is caught on line 9 \nand line 10 prints 4, so option D is correct. Line 11 throws the exception again, which \ncauses run() to immediately end, so line 13 doesn’t execute and option E is incorrect. \nThe main() method doesn’t catch the exception either, so line 18 doesn’t execute and \noption F is incorrect. The uncaught NullPointerException causes the stack trace to be \nprinted, so option G is correct. \n"
  },
  {
    "id": "oca-138",
    "question": "Which of the following statements are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "You can declare a method with Exception as the return type."
      },
      {
        "key": "B",
        "text": "You can declare any subclass of Error in the throws part of a method declaration."
      },
      {
        "key": "C",
        "text": "You can declare any subclass of Exception in the throws part of a method declaration."
      },
      {
        "key": "D",
        "text": "You can declare any subclass of Object in the throws part of a method declaration."
      },
      {
        "key": "E",
        "text": "You can declare any subclass of RuntimeException in the throws part of a method declaration."
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "Classes listed in the throws part of a method declaration must extend \njava.lang.Throwable. This includes Error, Exception, and RuntimeException. Arbi\u0002trary classes such as String can’t go there. Any Java type, including Exception, can \nbe declared as the return type. However, this will simply return the object rather than \nthrow an exception.\n"
  },
  {
    "id": "oca-139",
    "question": "Which of the following can be inserted on line 8 to make this code compile? (Choose all that apply.)\n\npublic void ohNo() throws IOException {\n    // INSERT CODE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "System.out.println(\"it's ok\");"
      },
      {
        "key": "B",
        "text": "throw new Exception();"
      },
      {
        "key": "C",
        "text": "throw new IllegalArgumentException();"
      },
      {
        "key": "D",
        "text": "throw new java.io.IOException();"
      },
      {
        "key": "E",
        "text": "throw new RuntimeException();"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "A method that declares an exception isn’t required to throw one, making \noption A correct. Runtime exceptions can be thrown in any method, making options \nC and E correct. Option D matches the exception type declared and so is also correct. \nOption B is incorrect because a broader exception is not allowed.\n"
  },
  {
    "id": "oca-140",
    "question": "Which of the following are unchecked exceptions? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "IllegalArgumentException"
      },
      {
        "key": "C",
        "text": "IOException"
      },
      {
        "key": "D",
        "text": "NumberFormatException"
      },
      {
        "key": "E",
        "text": "Any exception that extends RuntimeException"
      },
      {
        "key": "F",
        "text": "Any exception that extends Exception"
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "ArrayIndexOutOfBoundsException, IllegalArgumentException, and Num\u0002berFormatException are runtime exceptions. Sorry, you have to memorize them. Any \nclass that extends RuntimeException is a runtime (unchecked) exception. Classes that \nextend Exception but not RuntimeException are checked exceptions.\n"
  },
  {
    "id": "oca-141",
    "question": "Which scenario is the best use of an exception?",
    "choices": [
      {
        "key": "A",
        "text": "An element is not found when searching a list."
      },
      {
        "key": "B",
        "text": "An unexpected parameter is passed into a method."
      },
      {
        "key": "C",
        "text": "The computer caught fire."
      },
      {
        "key": "D",
        "text": "You want to loop through a list."
      },
      {
        "key": "E",
        "text": "You don’t know how to code a method."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "IllegalArgumentException is used when an unexpected parameter is passed into a \nmethod. Option A is incorrect because returning null or -1 is a common return value \nfor this scenario. Option D is incorrect because a for loop is typically used for this \nscenario. Option E is incorrect because you should find out how to code the method \nand not leave it for the unsuspecting programmer who calls your method. Option C is \nincorrect because you should run! \n"
  },
  {
    "id": "oca-142",
    "question": "Which of the following can be inserted into Lion to make this code compile? (Choose all that apply.)\n\nclass HasSoreThroatException extends Exception {}\nclass TiredException extends RuntimeException {}\ninterface Roar {\n    void roar() throws HasSoreThroatException;\n}\nclass Lion implements Roar { \n    // INSERT CODE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "public void roar() {}"
      },
      {
        "key": "B",
        "text": "public void roar() throws Exception {}"
      },
      {
        "key": "C",
        "text": "public void roar() throws HasSoreThroatException {}"
      },
      {
        "key": "D",
        "text": "public void roar() throws IllegalArgumentException {}"
      },
      {
        "key": "E",
        "text": "public void roar() throws TiredException {}"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "The method is allowed to throw no exceptions at all, making option A cor\u0002rect. It is also allowed to throw runtime exceptions, making options D and E correct. \nOption C is also correct since it matches the signature in the interface.\n"
  },
  {
    "id": "oca-143",
    "question": "Which of the following are true? (Choose all that apply.)",
    "choices": [
      {
        "key": "A",
        "text": "Checked exceptions are allowed to be handled or declared."
      },
      {
        "key": "B",
        "text": "Checked exceptions are required to be handled or declared."
      },
      {
        "key": "C",
        "text": "Errors are allowed to be handled or declared."
      },
      {
        "key": "D",
        "text": "Errors are required to be handled or declared."
      },
      {
        "key": "E",
        "text": "Runtime exceptions are allowed to be handled or declared."
      },
      {
        "key": "F",
        "text": "Runtime exceptions are required to be handled or declared."
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "Checked exceptions are required to be handled or declared. Runtime \nexceptions are allowed to be handled or declared. Errors are allowed to be handled or \ndeclared, but this is bad practice.\n"
  },
  {
    "id": "oca-144",
    "question": "Which of the following can be inserted in the blank to make the code compile? (Choose all that apply.)\n\npublic static void main(String[] args) {\n    try {\n        System.out.println(\"work real hard\");\n    } catch ( e) {\n    } catch (RuntimeException e) {\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Exception"
      },
      {
        "key": "B",
        "text": "IOException"
      },
      {
        "key": "C",
        "text": "IllegalArgumentException"
      },
      {
        "key": "D",
        "text": "RuntimeException"
      },
      {
        "key": "E",
        "text": "StackOverflowError"
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Option C is allowed because it is a more specific type than RuntimeException. \nOption E is allowed because it isn’t in the same inheritance tree as RuntimeExcep\u0002tion. It’s not a good idea to catch either of these. Option B is not allowed because the \nmethod called inside the try block doesn’t declare an IOException to be thrown. The \ncompiler realizes that IOException would be an unreachable catch block. Option D \nis not allowed because the same exception can’t be specified in two different catch\nblocks. Finally, option A is not allowed because it’s more general than RuntimeExcep\u0002tion and would make that block unreachable.\n"
  },
  {
    "id": "oca-145",
    "question": "What does the output of the following contain? (Choose all that apply.)\n\npublic static void main(String[] args) {\n    System.out.print(\"a\");\n    try {\n        System.out.print(\"b\");\n        throw new IllegalArgumentException();\n    } catch (IllegalArgumentException e) {\n        System.out.print(\"c\");\n        throw new RuntimeException(\"1\");\n    } catch (RuntimeException e) {\n        System.out.print(\"d\");\n        throw new RuntimeException(\"2\");\n    } finally {\n        System.out.print(\"e\");\n        throw new RuntimeException(\"3\");\n    }\n}",
    "choices": [
      {
        "key": "A",
        "text": "abce"
      },
      {
        "key": "B",
        "text": "abde"
      },
      {
        "key": "C",
        "text": "An exception with the message set to \"1\""
      },
      {
        "key": "D",
        "text": "An exception with the message set to \"2\""
      },
      {
        "key": "E",
        "text": "An exception with the message set to \"3\""
      },
      {
        "key": "F",
        "text": "Nothing; the code does not compile."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The code begins normally and prints a on line 13, followed by b on line 15. On \nline 16, it throws an exception that’s caught on line 17. Remember, only the most spe\u0002cific matching catch is run. Line 18 prints c, and then line 19 throws another excep\u0002tion. Regardless, the finally block runs, printing e. Since the finally block also \nthrows an exception, that’s the one printed."
  }
]