[
  {
    "id": "oca-1",
    "question": "Which of the following are valid Java identifiers? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "A$B"
      },
      {
        "key": "B",
        "text": "_helloWorld"
      },
      {
        "key": "C",
        "text": "true"
      },
      {
        "key": "D",
        "text": "java.lang"
      },
      {
        "key": "E",
        "text": "Public"
      },
      {
        "key": "F",
        "text": "1980 _s"
      }
    ],
    "answer": [
      "A",
      "B",
      "E"
    ],
    "explanation": "Option A is valid because you can use the dollar sign in identifiers. Option B is \nvalid because you can use an underscore in identifiers. Option C is not a valid identifier \nbecause true is a Java reserved word. Option D is not valid because the dot (.) is not \nallowed in identifiers. Option E is valid because Java is case sensitive, so Public is not \na reserved word and therefore a valid identifier. Option F is not valid because the first \ncharacter is not a letter, $, or _.\n"
  },
  {
    "id": "oca-2",
    "question": "What is the output of the following program?\n1: public class WaterBottle {\n2: private String brand;\n3: private boolean empty;\n4: public static void main(String[] args) {\n5:   WaterBottle wb = new WaterBottle();\n6:   System. out.print(\"Empty = \" + wb.empty);\n7:   System. out.print(\", Brand = \" + wb.brand);\n8:  } }",
    "choices": [
      {
        "key": "A",
        "text": "Line 6 generates a compiler error. "
      },
      {
        "key": "B",
        "text": "Line 7 generates a compiler error. "
      },
      {
        "key": "C",
        "text": "There is no output."
      },
      {
        "key": "D",
        "text": "Empty = false, Brand = null"
      },
      {
        "key": "E",
        "text": "Empty = false, Brand = "
      },
      {
        "key": "F",
        "text": "Empty = null, Brand = null"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Boolean fields initialize to false and references initialize to null, so empty is false\nand brand is null. Brand = null is output. \n"
  },
  {
    "id": "oca-3",
    "question": "Which of the following are true? (Choose all that apply)\n4: short numPets = 5;\n5: int numGrains = 5.6;\n6: String name = \"Scruffy\";\n7: numPets.length();\n8: numGrains.length();\n9: name.length();",
    "choices": [
      {
        "key": "A",
        "text": "Line 4 generates a compiler error."
      },
      {
        "key": "B",
        "text": "Line 5 generates a compiler error."
      },
      {
        "key": "C",
        "text": "Line 6 generates a compiler error."
      },
      {
        "key": "D",
        "text": "Line 7 generates a compiler error."
      },
      {
        "key": "E",
        "text": "Line 8 generates a compiler error."
      },
      {
        "key": "F",
        "text": "Line 9 generates a compiler error."
      },
      {
        "key": "G",
        "text": "The code compiles as is."
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Option A (line 4) compiles because short is an integral type. Option B (line \n5) generates a compiler error because int is an integral type, but 5.6 is a floating-point \ntype. Option C (line 6) compiles because it is assigned a String. Options D and E (lines \n7 and 8) do not compile because short and int are primitives. Primitives do not allow \nmethods to be called on them. Option F (line 9) compiles because length() is defined \non String.\n"
  },
  {
    "id": "oca-4",
    "question": "Given the following class, which of the following is true? (Choose all that apply)\n 1: public class Snake {\n 2:  \n 3:  public void shed(boolean time) {\n 4:\n 5:    if (time) {\n 6:\n 7:    }\n 8:    System. out.println(result);\n 9:\n10:  }\n11: }",
    "choices": [
      {
        "key": "A",
        "text": "If String result = \"done\";  is inserted on line 2, the code will compile."
      },
      {
        "key": "B",
        "text": "If String result = \"done\";  is inserted on line 4, the code will compile."
      },
      {
        "key": "C",
        "text": "If String result = \"done\";  is inserted on line 6, the code will compile."
      },
      {
        "key": "D",
        "text": "If String result = \"done\";  is inserted on line 9, the code will compile."
      },
      {
        "key": "E",
        "text": "None of the above changes will make the code compile."
      }
    ],
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Adding the variable at line 2 makes result an instance variable. Since instance \nvariables are in scope for the entire life of the object, option A is correct. Option B is \ncorrect because adding the variable at line 4 makes result a local variable with a scope \nof the whole method. Adding the variable at line 6 makes result a local variable with \na scope of lines 6–7. Since it is out of scope on line 8, the println does not compile and \noption C is incorrect. Adding the variable at line 9 makes result a local variable with \na scope of lines 9 and 10. Since line 8 is before the declaration, it does not compile and \noption D is incorrect. Finally, option E is incorrect because the code can be made to \ncompile.\n"
  },
  {
    "id": "oca-5",
    "question": "Given the following classes, which of the following can independently replace INSERT \nIMPORTS HERE  to make the code compile? (Choose all that apply)\npackage aquarium;\npublic class Tank { }\npackage aquarium.jellies;\npublic class Jelly { }\npackage visitor;\nINSERT IMPORTS HERE\npublic class AquariumVisitor {\n  public void admire(Jelly jelly) { } }",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.*.Jelly;"
      },
      {
        "key": "C",
        "text": "import aquarium.jellies.Jelly ;"
      },
      {
        "key": "D",
        "text": "import aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.jellies.Jelly.*;"
      },
      {
        "key": "F",
        "text": "None of these can make the code compile."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Option C is correct because it imports Jelly by classname. Option D is cor\u0002rect because it imports all the classes in the jellies package, which includes Jelly. \nOption A is incorrect because it only imports classes in the aquarium package—Tank\nin this case—and not those in lower-level packages. Option B is incorrect because you \ncannot use wildcards anyplace other than the end of an import statement. Option E is \nincorrect because you cannot import parts of a class with a regular import statement. \nOption F is incorrect because options C and D do make the code compile.\n"
  },
  {
    "id": "oca-6",
    "question": "Given the following classes, what is the maximum number of imports that can be removed \nand have the code still compile?\npackage aquarium; public class Water { }\npackage aquarium;\nimport java.lang.*;\nimport java.lang.System;\nimport aquarium.Water;\nimport aquarium.*;\npublic class Tank {\n  public void print(Water water) {\n   System. out.println(water); } }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "Does not compile."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The first two imports can be removed because java.lang is automatically imported. \nThe second two imports can be removed because Tank and Water are in the same pack\u0002age, making the correct answer E. If Tank and Water were in different packages, one of \nthese two imports could be removed. In that case, the answer would be option D. \n"
  },
  {
    "id": "oca-7",
    "question": "Given the following classes, which of the following snippets can be inserted in place of \nINSERT IMPORTS HERE  and have the code compile? (Choose all that apply)\npackage aquarium;\npublic class Water {\n  boolean salty = false;\n}\npackage aquarium.jellies;\npublic class Water {\n  boolean salty = true;\n}\npackage employee;\n INSERT IMPORTS HERE\npublic class WaterFiller {\n  Water water;\n}",
    "choices": [
      {
        "key": "A",
        "text": "import aquarium.*;"
      },
      {
        "key": "B",
        "text": "import aquarium.Water;\nimport aquarium.jellies.*;"
      },
      {
        "key": "C",
        "text": "import aquarium.*;\nimport aquarium.jellies.Water;\nimport aquarium.*;\nimport aquarium.jellies.*;"
      },
      {
        "key": "E",
        "text": "import aquarium.Water;\nimport aquarium.jellies.Water;"
      },
      {
        "key": "F",
        "text": "None of these imports can make the code compile."
      }
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Option A is correct because it imports all the classes in the aquarium package \nincluding aquarium.Water. Options B and C are correct because they import Water by \nclassname. Since importing by classname takes precedence over wildcards, these com\u0002pile. Option D is incorrect because Java doesn’t know which of the two wildcard Water\nclasses to use. Option E is incorrect because you cannot specify the same classname in \ntwo imports. \n"
  },
  {
    "id": "oca-8",
    "question": "Given the following class, which of the following calls print out Blue Jay ? (Choose all that \napply)\npublic class BirdDisplay {\n  public static void main(String[] name) {             \n    System. out.println(name[1]);\n} }",
    "choices": [
      {
        "key": "A",
        "text": "java BirdDisplay Sparrow Blue Jay"
      },
      {
        "key": "B",
        "text": "java BirdDisplay Sparrow \"Blue Jay\""
      },
      {
        "key": "C",
        "text": "java BirdDisplay Blue Jay Sparrow"
      },
      {
        "key": "D",
        "text": "java BirdDisplay \"Blue Jay\" Sparrow"
      },
      {
        "key": "E",
        "text": "java BirdDisplay.class Sparrow \"Blue Jay\""
      },
      {
        "key": "F",
        "text": "java BirdDisplay.class \"Blue Jay\" Sparrow"
      },
      {
        "key": "G",
        "text": "Does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Option B is correct because arrays start counting from zero and strings with spaces \nmust be in quotes. Option A is incorrect because it outputs Blue. C is incorrect because \nit outputs Jay. Option D is incorrect because it outputs Sparrow. Options E and F are \nincorrect because they output Error: Could not find or load main class Bird\u0002Display.class.\n"
  },
  {
    "id": "oca-9",
    "question": "Which of the following legally fill in the blank so you can run the main()  method from the \ncommand line? (Choose all that apply)\npublic static void main( )",
    "choices": [
      {
        "key": "A",
        "text": "String[] _names"
      },
      {
        "key": "B",
        "text": "String[] 123"
      },
      {
        "key": "C",
        "text": "String abc[]"
      },
      {
        "key": "D",
        "text": "String _Names[]"
      },
      {
        "key": "E",
        "text": "String... $n"
      },
      {
        "key": "F",
        "text": "String names"
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "Option A is correct because it is the traditional main() method signature \nand variables may begin with underscores. Options C and D are correct because the \narray operator may appear after the variable name. Option E is correct because \nvarargs are allowed in place of an array. Option B is incorrect because variables are \nnot allowed to begin with a digit. Option F is incorrect because the argument must be \nan array or varargs. Option F is a perfectly good method. However, it is not one that \ncan be run from the command line because it has the wrong parameter type. \n"
  },
  {
    "id": "oca-10",
    "question": "Which of the following are legal entry point methods that can be run from the command \nline? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "private static void main(String[] args) "
      },
      {
        "key": "B",
        "text": "public static final main(String[] args) "
      },
      {
        "key": "C",
        "text": "public void main(String[] args) "
      },
      {
        "key": "D",
        "text": "public static void test(String[] args) "
      },
      {
        "key": "E",
        "text": "public static void main(String[] args) "
      },
      {
        "key": "F",
        "text": "public static main(String[] args) "
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Option E is the canonical main() method signature. You need to memorize it. \nOption A is incorrect because the main() method must be public. Options B and F \nare incorrect because the main() method must have a void return type. Option C is \nincorrect because the main() method must be static. Option D is incorrect because the \nmain() method must be named main. \n"
  },
  {
    "id": "oca-11",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "An instance variable of type double  defaults to null ."
      },
      {
        "key": "B",
        "text": "An instance variable of type int defaults to null ."
      },
      {
        "key": "C",
        "text": "An instance variable of type String  defaults to null ."
      },
      {
        "key": "D",
        "text": "An instance variable of type double  defaults to 0.0."
      },
      {
        "key": "E",
        "text": "An instance variable of type int defaults to 0.0."
      },
      {
        "key": "F",
        "text": "An instance variable of type String  defaults to 0.0."
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Option C is correct because all non-primitive values default to null. Option D is \ncorrect because float and double primitives default to 0.0. Options B and E are incor\u0002rect because int primitives default to 0.\n"
  },
  {
    "id": "oca-12",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "A local variable of type boolean  defaults to null ."
      },
      {
        "key": "B",
        "text": "A local variable of type float  defaults to 0."
      },
      {
        "key": "C",
        "text": "A local variable of type Object  defaults to null ."
      },
      {
        "key": "D",
        "text": "A local variable of type boolean  defaults to false ."
      },
      {
        "key": "E",
        "text": "A local variable of type boolean  defaults to true ."
      },
      {
        "key": "F",
        "text": "A local variable of type float  defaults to 0.0."
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "Option G is correct because local variables do not get assigned default values. The \ncode fails to compile if a local variable is not explicitly initialized. If this question \nwere about instance variables, options D and F would be correct. A boolean primitive \ndefaults to false and a float primitive defaults to 0.0.\n"
  },
  {
    "id": "oca-13",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "An instance variable of type boolean  defaults to false ."
      },
      {
        "key": "B",
        "text": "An instance variable of type boolean  defaults to true ."
      },
      {
        "key": "C",
        "text": "An instance variable of type boolean  defaults to null ."
      },
      {
        "key": "D",
        "text": "An instance variable of type int defaults to 0."
      },
      {
        "key": "E",
        "text": "An instance variable of type int defaults to 0.0."
      },
      {
        "key": "F",
        "text": "An instance variable of type int defaults to null ."
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Options A and D are correct because boolean primitives default to false and \nint primitives default to 0. \n"
  },
  {
    "id": "oca-14",
    "question": "Given the following class in the file /my/directory/named/A/Bird.java :\nINSERT CODE HERE\npublic class Bird { }\n Which of the following replaces  INSERT CODE HERE  if we compile from  /my/directory ? \n(Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "package my.directory.named.a;"
      },
      {
        "key": "B",
        "text": "package my.directory.named.A;"
      },
      {
        "key": "C",
        "text": "package named.a;"
      },
      {
        "key": "D",
        "text": "package named.A;"
      },
      {
        "key": "E",
        "text": "package a;"
      },
      {
        "key": "F",
        "text": "package A;"
      },
      {
        "key": "G",
        "text": "Does not compile."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The package name represents any folders underneath the current path, which is \nnamed.A in this case. Option B is incorrect because package names are case sensitive, \njust like variable names and other identifiers.\n"
  },
  {
    "id": "oca-15",
    "question": "Which of the following lines of code compile? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "int i1 = 1_234;"
      },
      {
        "key": "B",
        "text": "double d1 = 1_234_.0;"
      },
      {
        "key": "C",
        "text": "double d2 = 1_234._0;"
      },
      {
        "key": "D",
        "text": "double d3 = 1_234.0_;"
      },
      {
        "key": "E",
        "text": "double d4 = 1_234.0;"
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Underscores are allowed as long as they are directly between two other digits. \nThis means options A and E are correct. Options B and C are incorrect because the \nunderscore is adjacent to the decimal point. Option D is incorrect because the under\u0002score is the last character. \n"
  },
  {
    "id": "oca-16",
    "question": "Given the following class, which of the following lines of code can replace INSERT CODE \nHERE  to make the code compile? (Choose all that apply)\npublic class Price {\n      public void admission() {\n                INSERT CODE HERE\n             System. out.println(amount);\n      } }",
    "choices": [
      {
        "key": "A",
        "text": "int amount = 9L;"
      },
      {
        "key": "B",
        "text": "int amount = 0b101;"
      },
      {
        "key": "C",
        "text": "int amount = 0xE;"
      },
      {
        "key": "D",
        "text": "double amount = 0xE;"
      },
      {
        "key": "E",
        "text": "double amount = 1_2_.0_0;"
      },
      {
        "key": "F",
        "text": "int amount = 1_2_;"
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "B",
      "C",
      "D"
    ],
    "explanation": "0b is the prefix for a binary value and is correct. 0x is the prefix for a hexa\u0002decimal value. This value can be assigned to many primitive types, including int and \ndouble, making options C and D correct. Option A is incorrect because 9L is a long \nvalue. long amount = 9L would be allowed. Option E is incorrect because the under\u0002score is immediately before the decimal. Option F is incorrect because the underscore is \nthe very last character.\n336 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 336\n"
  },
  {
    "id": "oca-17",
    "question": "Which of the following are true? (Choose all that apply)\npublic class Bunny {\n       public static void main(String[] args) {\n            Bunny bun = new Bunny();\n} }",
    "choices": [
      {
        "key": "A",
        "text": "Bunny  is a class."
      },
      {
        "key": "B",
        "text": "bun is a class."
      },
      {
        "key": "C",
        "text": "main  is a class."
      },
      {
        "key": "D",
        "text": "Bunny  is a reference to an object."
      },
      {
        "key": "E",
        "text": "bun is a reference to an object."
      },
      {
        "key": "F",
        "text": "main  is a reference to an object."
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "Bunny is a class, which can be seen from the declaration: public class Bunny. bun\nis a reference to an object. main() is a method.\n"
  },
  {
    "id": "oca-18",
    "question": "Which represent the order in which the following statements can be assembled into a pro-\ngram that will compile successfully? (Choose all that apply)\nA: class Rabbit {} \nB: import java.util.*; \nC: package animals;",
    "choices": [
      {
        "key": "A",
        "text": "A, B, C"
      },
      {
        "key": "B",
        "text": "B, C, A"
      },
      {
        "key": "C",
        "text": "C, B, A"
      },
      {
        "key": "D",
        "text": "B, A"
      },
      {
        "key": "E",
        "text": "C, A"
      },
      {
        "key": "F",
        "text": "A, C"
      },
      {
        "key": "G",
        "text": "A, B"
      }
    ],
    "answer": [
      "C",
      "D",
      "E"
    ],
    "explanation": "package and import are both optional. If both are present, the order must \nbe package, then import, then class. Option A is incorrect because class is before \npackage and import. Option B is incorrect because import is before package. Option \nF is incorrect because class is before package. Option G is incorrect because class is \nbefore import.\n"
  },
  {
    "id": "oca-19",
    "question": "Suppose we have a class named Rabbit . Which of the following statements are true? \n(Choose all that apply)\n1:  public class Rabbit {\n2:   public static void main(String[] args) {\n3:    Rabbit one = new Rabbit();\n4:    Rabbit two = new Rabbit();\n5:    Rabbit three = one;\n6:    one = null;\n7:    Rabbit four = one;\n8:    three = null;\n9:    two = null;\n10:   two = new Rabbit();\n11:   System.gc();\n12: } }",
    "choices": [
      {
        "key": "A",
        "text": "The Rabbit  object from line 3 is first eligible for garbage collection immediately \nfollowing line 6."
      },
      {
        "key": "B",
        "text": "The Rabbit  object from line 3 is first eligible for garbage collection immediately \nfollowing line 8."
      },
      {
        "key": "C",
        "text": "The Rabbit  object from line 3 is first eligible for garbage collection immediately \nfollowing line 12."
      },
      {
        "key": "D",
        "text": "The Rabbit  object from line 4 is first eligible for garbage collection immediately \nfollowing line 9."
      },
      {
        "key": "E",
        "text": "The Rabbit  object from line 4 is first eligible for garbage collection immediately \nfollowing line 11."
      },
      {
        "key": "F",
        "text": "The Rabbit  object from line 4 is first eligible for garbage collection immediately \nfollowing line 12."
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "The Rabbit object from line 3 has two references to it: one and three. The ref\u0002erences are nulled out on lines 6 and 8, respectively. Option B is correct because this \nmakes the object eligible for garbage collection after line 8. Line 7 sets the reference \nfour to the now null one, which means it has no effect on garbage collection. The Rab\u0002bit object from line 4 only has a single reference to it: two. Option D is correct because \nthis single reference becomes null on line 9. The Rabbit object declared on line 10 \nbecomes eligible for garbage collection at the end of the method on line 12. Calling \nSystem.gc() has no effect on eligibility for garbage collection.\n"
  },
  {
    "id": "oca-20",
    "question": "What is true about the following code? (Choose all that apply)\npublic class Bear {\n  protected void finalize() {\n    System. out.println(\"Roar!\");\n}\npublic static void main(String[] args) {\n  Bear bear = new Bear();\n  bear = null;\n  System. gc();\n} }",
    "choices": [
      {
        "key": "A",
        "text": "finalize() is guaranteed to be called."
      },
      {
        "key": "B",
        "text": "finalize() might or might not be called"
      },
      {
        "key": "C",
        "text": "finalize() is guaranteed not to be called."
      },
      {
        "key": "D",
        "text": "Garbage collection is guaranteed to run."
      },
      {
        "key": "E",
        "text": "Garbage collection might or might not run."
      },
      {
        "key": "F",
        "text": "Garbage collection is guaranteed not to run."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Calling System.gc() suggests that Java might wish to run the garbage collector. \nJava is free to ignore the request, making option E correct. finalize() runs if an object \nattempts to be garbage collected, making option B correct.\n"
  },
  {
    "id": "oca-21",
    "question": "What does the following code output?\n1: public class Salmon {\n2:  int count;\n3:  public void Salmon() {\n4:    count = 4;\n5:  }\n6: public static void main(String[] args) {\n7:  Salmon s = new Salmon();\n8:  System. out.println(s.count);\n9: } }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "Compilation fails on line 3."
      },
      {
        "key": "D",
        "text": "Compilation fails on line 4."
      },
      {
        "key": "E",
        "text": "Compilation fails on line 7."
      },
      {
        "key": "F",
        "text": "Compilation fails on line 8."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "While the code on line 3 does compile, it is not a constructor because it has a return \ntype. It is a method that happens to have the same name as the class. When the code \nruns, the default constructor is called and count has the default value (0) for an int.\n"
  },
  {
    "id": "oca-22",
    "question": "Which of the following are true statements? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Java allows operator overloading."
      },
      {
        "key": "B",
        "text": "Java code compiled on Windows can run on Linux."
      },
      {
        "key": "C",
        "text": "Java has pointers to specific locations in memory."
      },
      {
        "key": "D",
        "text": "Java is a procedural language."
      },
      {
        "key": "E",
        "text": "Java is an object-oriented language."
      },
      {
        "key": "F",
        "text": "Java is a functional programming language."
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "C++ has operator overloading and pointers. Java made a point of not having \neither. Java does have references to objects, but these are pointing to an object that can \nmove around in memory. Option B is correct because Java is platform independent. \nOption E is correct because Java is object oriented. While it does support some parts of \nfunctional programming, these occur within a class.\n"
  },
  {
    "id": "oca-23",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "javac  compiles a .class  file into a .java  file."
      },
      {
        "key": "B",
        "text": "javac  compiles a .java  file into a  .bytecode  file."
      },
      {
        "key": "C",
        "text": "javac  compiles a .java  file into a .class  file."
      },
      {
        "key": "D",
        "text": "Java takes the name of the class as a parameter."
      },
      {
        "key": "E",
        "text": "Java takes the name of the .bytecode  file as a parameter."
      },
      {
        "key": "F",
        "text": "Java takes the name of the .class  file as a parameter."
      }
    ],
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Java puts source code in .java files and bytecode in .class files. It does not use \na .bytecode file. When running a Java program, you pass just the name of the class \nwithout the .class extension.\n"
  },
  {
    "id": "oca-24",
    "question": "Which of the following Java operators can be used with boolean  variables? (Choose all that \napply)",
    "choices": [
      {
        "key": "A",
        "text": "=="
      },
      {
        "key": "B",
        "text": "+"
      },
      {
        "key": "C",
        "text": "--"
      },
      {
        "key": "D",
        "text": "!"
      },
      {
        "key": "E",
        "text": "%"
      },
      {
        "key": "F",
        "text": "<="
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Option A is the equality operator and can be used on numeric primitives, bool\u0002ean values, and object references. Options B and C are both arithmetic operators and \ncannot be applied to a boolean value. Option D is the logical complement operator \nand is used exclusively with boolean values. Option E is the modulus operator, which \ncan only be used with numeric primitives. Finally, option F is a relational operator that \ncompares the values of two numbers.\n"
  },
  {
    "id": "oca-25",
    "question": "What data type (or types) will allow the following code snippet to compile? (Choose all that \napply)\nbyte x = 5;\nbyte y = 10;\n_____ z = x + y;",
    "choices": [
      {
        "key": "A",
        "text": "int"
      },
      {
        "key": "B",
        "text": "long"
      },
      {
        "key": "C",
        "text": "boolean"
      },
      {
        "key": "D",
        "text": "double"
      },
      {
        "key": "E",
        "text": "short"
      },
      {
        "key": "F",
        "text": "byte"
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "The value x + y is automatically promoted to int, so int and data types that \ncan be promoted automatically from int will work. Options A, B, D are such data \ntypes. Option C will not work because boolean is not a numeric data type. Options E \nand F will not work without an explicit cast to a smaller data type.\n"
  },
  {
    "id": "oca-26",
    "question": "What is the output of the following application?\n1: public class CompareValues {\n2:   public static void main(String[] args) {\n3:     int x = 0;\n4:     while(x++ < 10) {}\n5:     String message = x > 10 ? \"Greater than\" : false;\n6:     System.out.println(message+\",\"+x);\n7:   }\n8: }",
    "choices": [
      {
        "key": "A",
        "text": "Greater than,10"
      },
      {
        "key": "B",
        "text": "false,10"
      },
      {
        "key": "C",
        "text": "Greater than,11"
      },
      {
        "key": "D",
        "text": "false,11"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 5.Review Questions  95\n3: long x = 10;\n4: int y = 2 * x;"
      },
      {
        "key": "A",
        "text": "No change; it compiles as is."
      },
      {
        "key": "B",
        "text": "Cast x on line 4 to int."
      },
      {
        "key": "C",
        "text": "Change the data type of x on line 3 to short ."
      },
      {
        "key": "D",
        "text": "Cast 2 * x  on line 4 to int."
      },
      {
        "key": "E",
        "text": "Change the data type of y on line 4 to short ."
      },
      {
        "key": "F",
        "text": "Change the data type of y on line 4 to long ."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "In this example, the ternary operator has two expressions, one of them a String and \nthe other a boolean value. The ternary operator is permitted to have expressions that \ndon’t have matching types, but the key here is the assignment to the String reference. \nThe compiler knows how to assign the first expression value as a String, but the sec\u0002ond boolean expression cannot be set as a String; therefore, this line will not compile.\n"
  },
  {
    "id": "oca-27",
    "question": "What is the output of the following code snippet?\n3: java.util.List<Integer> list = new java.util.ArrayList<Integer>();\n4: list.add(10);\n5: list.add(14);\n6: for(int x : list) {\n7:   System.out.print(x + \", \");\n8:   break;\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "10, 14,"
      },
      {
        "key": "B",
        "text": "10, 14"
      },
      {
        "key": "C",
        "text": "10,"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The code will not compile as is, so option A is not correct. The value 2 * x\nis automatically promoted to long and cannot be automatically stored in y, which is \nin an int value. Options B, C, and D solve this problem by reducing the long value to \nint. Option E does not solve the problem and actually makes it worse by attempting \nto place the value in a smaller data type. Option F solves the problem by increasing the \ndata type of the assignment so that long is allowed.\n"
  },
  {
    "id": "oca-28",
    "question": "What is the output of the following code snippet?\n3: int x = 4;\n4: long y = x * 4 - x++;\n5: if(y<10) System.out.println(\"Too Low\");\n6: else System.out.println(\"Just right\");\n7: else System.out.println(\"Too High\");",
    "choices": [
      {
        "key": "A",
        "text": "Too Low"
      },
      {
        "key": "B",
        "text": "Just Right"
      },
      {
        "key": "C",
        "text": "Too High"
      },
      {
        "key": "D",
        "text": "Compiles but throws a NullPointerException."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 7.\n1: public class TernaryTester {\n2:   public static void main(String[] args) {\n3:     int x = 5;\n4:     System.out.println(x > 2 ? x < 4 ? 10 : 8 : 7);\n5: }}"
      },
      {
        "key": "A",
        "text": "5"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "7"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 4."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This code does not contain any compilation errors or an infinite loop, so options D, \nE, and F are incorrect. The break statement on line 8 causes the loop to execute once \nand finish, so option C is the correct answer.\n"
  },
  {
    "id": "oca-29",
    "question": "What is the output of the following code snippet?\n3: boolean x = true, z = true;\n4: int y = 20;\n5: x = (y != 10) ^ (z=false);\n6: System.out.println(x+\", \"+y+\", \"+z);",
    "choices": [
      {
        "key": "A",
        "text": "true, 10, true"
      },
      {
        "key": "B",
        "text": "true, 20, false"
      },
      {
        "key": "C",
        "text": "false, 20, true"
      },
      {
        "key": "D",
        "text": "false, 20, false"
      },
      {
        "key": "E",
        "text": "false, 20, true"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 5."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The code does not compile because two else statements cannot be chained together \nwithout additional if-then statements, so the correct answer is option F. Option E is \nincorrect as Line 6 by itself does not cause a problem, only when it is paired with Line 7.\nOne way to fix this code so it compiles would be to add an if-then statement on \nline 6. The other solution would be to remove line 7.\n"
  },
  {
    "id": "oca-30",
    "question": "How many times will the following code print \"Hello World\" ?\n3: for(int i=0; i<10 ; ) {\n4:   i = i++;\n5:   System.out.println(\"Hello World\");\n6: }",
    "choices": [
      {
        "key": "A",
        "text": "9"
      },
      {
        "key": "B",
        "text": "10"
      },
      {
        "key": "C",
        "text": "11"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "As you learned in the section “Ternary Operator,” although parentheses are not \nrequired, they do greatly increase code readability, such as the following equivalent \nstatement:\nSystem.out.println((x > 2) ? ((x < 4) ? 10 : 8) : 7)\nWe apply the outside ternary operator fi rst, as it is possible the inner ternary expression \nmay never be evaluated. Since (x>2) is true, this reduces the problem to:\nSystem.out.println((x < 4) ? 10 : 8)\nSince x is greater than 2, the answer is 8, or option D in this case.\n"
  },
  {
    "id": "oca-31",
    "question": "What is the output of the following code?\n3: byte a = 40, b = 50;\n4: byte sum = (byte) a + b;\n5: System.out.println(sum);Review Questions  97",
    "choices": [
      {
        "key": "B",
        "text": "50"
      },
      {
        "key": "C",
        "text": "90"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "E",
        "text": "An undefined value."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This example is tricky because of the second assignment operator embedded in line 5.\nThe expression (z=false) assigns the value false to z and returns false for the \nentire expression. Since y does not equal 10, the left-hand side returns true; therefore, \nthe exclusive or (^) of the entire expression assigned to x is true. The output reflects \nthese assignments, with no change to y, so option B is the only correct answer. The \ncode compiles and runs without issue, so option F is not correct.\n"
  },
  {
    "id": "oca-32",
    "question": "What is the output of the following code?\n1: public class ArithmeticSample {\n2:   public static void main(String[] args) {\n3:     int x = 5 * 4 % 3;\n4:     System.out.println(x);\n5: }}",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "3"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "6"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 3."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "In this example, the update statement of the for loop is missing, which is fine as the \nstatement is optional, so option D is incorrect. The expression inside the loop incre\u0002ments i but then assigns i the old value. Therefore, i ends the loop with the same value \n338 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 338\nthat it starts with: 0. The loop will repeat infinitely, outputting the same statement over \nand over again because i remains 0 after every iteration of the loop.\n"
  },
  {
    "id": "oca-33",
    "question": "What is the output of the following code snippet?\n3: int x = 0;\n4: String s = null;\n5: if(x == s) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Line 4 generates a possible loss of precision compiler error. The cast operator has \nthe highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is \nevaluated, causing both a and b to be promoted to int values. The value 90 is an int\nand cannot be assigned to the byte sum without an explicit cast, so the code does not \ncompile. The code could be corrected with parentheses around (a + b), in which case \noption C would be the correct answer.\n"
  },
  {
    "id": "oca-34",
    "question": "What is the output of the following code snippet?\n3: int x1 = 50, x2 = 75;\n4: boolean b = x1 >= x2;\n5: if(b = true) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
    "choices": [
      {
        "key": "A",
        "text": "Success"
      },
      {
        "key": "B",
        "text": "Failure"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The * and % have the same operator precedence, so the expression is evaluated \nfrom left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the \nremainder is 2). The output is 2 and option A is the correct answer.\n"
  },
  {
    "id": "oca-35",
    "question": "What is the output of the following code snippet?\n3: int c = 7;\n4: int result = 4;\n6: System.out.println(result);",
    "choices": [
      {
        "key": "A",
        "text": "8"
      },
      {
        "key": "B",
        "text": "11"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "15"
      },
      {
        "key": "E",
        "text": "16"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 5."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The variable x is an int and s is a reference to a String object. The two data types \nare incomparable because neither variable can be converted to the other variable’s type. \nThe compiler error occurs on line 5 when the comparison is attempted, so the answer \nis option D.\n"
  },
  {
    "id": "oca-36",
    "question": "What is the output of the following code snippet?\n3: int x = 1, y = 15;\n4: while x < 10\n5:   y––;\n6:   x++;\n7: System.out.println(x+\", \"+y);",
    "choices": [
      {
        "key": "A",
        "text": "10, 5"
      },
      {
        "key": "B",
        "text": "10, 6"
      },
      {
        "key": "C",
        "text": "11, 5"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "F",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles successfully, so options C and D are incorrect. The value of b\nafter line 4 is false. However, the if-then statement on line 5 contains an assignment, \nnot a comparison. The variable b is assigned true on line 3, and the assignment opera\u0002tor returns true, so line 5 executes and displays Success, so the answer is option A.\n"
  },
  {
    "id": "oca-37",
    "question": "What is the output of the following code snippet?\n3: do {\n4:   int y = 1;\n5:   System.out.print(y++ + \" \");\n6: } while(y <= 10);",
    "choices": [
      {
        "key": "A",
        "text": "1 2 3 4 5 6 7 8 9"
      },
      {
        "key": "B",
        "text": "1 2 3 4 5 6 7 8 9 10"
      },
      {
        "key": "C",
        "text": "1 2 3 4 5 6 7 8 9 10 11"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "E",
        "text": "The code contains an infinite loop and does not terminate."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles successfully, so option F is incorrect. On line 5, the pre-incre\u0002ment operator is used, so c is incremented to 4 and the new value is returned to the \nexpression. The value of result is computed by adding 4 to the original value of 8, \nresulting in a new value of 12, which is output on line 6. Therefore, option C is the \ncorrect answer.\n"
  },
  {
    "id": "oca-38",
    "question": "What is the output of the following code snippet?\n3: boolean keepGoing = true;\n4: int result = 15, i = 10;\n5: do {\n6:   i--;\n7:   if(i==8) keepGoing = false;\n8:   result -= 2;\n9: } while(keepGoing);Review Questions  99",
    "choices": [
      {
        "key": "A",
        "text": "7"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "10"
      },
      {
        "key": "D",
        "text": "11"
      },
      {
        "key": "E",
        "text": "15"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "This is actually a much simpler problem than it appears to be. The while statement \non line 4 is missing parentheses, so the code will not compile, and option E is the cor\u0002rect answer. If the parentheses were added, though, option F would be the correct \nanswer since the loop does not use curly braces to include x++ and the boolean expres\u0002sion never changes. Finally, if curly braces were added around both expressions, the \noutput would be 10, 6 and option B would be correct.\n"
  },
  {
    "id": "oca-39",
    "question": "What is the output of the following code snippet?\n3: int count = 0;\n4: ROW_LOOP: for(int row = 1; row <=3; row++)\n5:   for(int col = 1; col <=2 ; col++) {\n6:     if(row * col % 2 == 0) continue ROW_LOOP;\n7:     count++;\n8:   }\n9: System.out.println(count);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "6"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 6."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The variable y is declared within the body of the do-while statement, so it is out of \nscope on line 6. Line 6 generates a compiler error, so option D is the correct answer.\n"
  },
  {
    "id": "oca-40",
    "question": "What is the result of the following code snippet?\n3: int m = 9, n = 1, x = 0;\n4: while(m > n) {\n5:   m--;\n6:   n += 2;\n7:   x += m + n;\n8: }\n9: System.out.println(x);",
    "choices": [
      {
        "key": "A",
        "text": "11"
      },
      {
        "key": "B",
        "text": "13"
      },
      {
        "key": "C",
        "text": "23"
      },
      {
        "key": "D",
        "text": "36"
      },
      {
        "key": "E",
        "text": "50"
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 7."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles without issue, so option F is incorrect. After the first execu\u0002tion of the loop, i is decremented to 9 and result to 13. Since i is not 8, keepGoing is \nfalse, and the loop continues. On the next iteration, i is decremented to 8 and result\nto 11. On the second execution, i does equal 8, so keepGoing is set to false. At the \nconclusion of the loop, the loop terminates since keepGoing is no longer true. The \nvalue of result is 11, and the correct answer is option D.\n"
  },
  {
    "id": "oca-41",
    "question": "What is the result of the following code snippet?\n3: final char a = 'A', d = 'D';\n4: char grade = 'B';\n6:   case a:\n7:   case 'B': System.out.print(\"great\");\n8:   case 'C': System.out.print(\"good\"); break;\n9:   case d:\n10:  case 'F': System.out.print(\"not good\");\n11: }",
    "choices": [
      {
        "key": "A",
        "text": "great"
      },
      {
        "key": "B",
        "text": "greatgood "
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "E",
        "text": "The code will not compile because of lines 6 and 9."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The expression on line 5 is true when row * col is an even number. On the first \niteration, row = 1 and col = 1, so the expression on line 6 is false, the continue is \nskipped, and count is incremented to 1. On the second iteration, row = 1 and \ncol = 2, so the expression on line 6 is true and the continue ends the outer loop with \ncount still at 1. On the third iteration, row = 2 and col = 1, so the expression on line \n6 is true and the continue ends the outer loop with count still at 1. On the fourth \niteration, row = 3 and col = 1, so the expression on line 6 is false, the continue is \nskipped, and count is incremented to 2. Finally, on the fifth and final iteration, row \n= 3 and col = 2, so the expression on line 6 is true and the continue ends the outer \nloop with count still at 2. The result of 2 is displayed, so the answer is option B.\n"
  },
  {
    "id": "oca-42",
    "question": "What is output by the following code? (Choose all that apply)\n1: public class Fish {\n2:  public static void main(String[] args) {\n3:    int numFish = 4;\n4:    String fishType = \"tuna\";\n5:    String anotherFish = numFish + 1;\n6:    System.out.println(anotherFish + \" \" + fishType);\n7:    System.out.println(numFish + \" \" + 1);\n8:  } }",
    "choices": [
      {
        "key": "A",
        "text": "4 1"
      },
      {
        "key": "B",
        "text": "41"
      },
      {
        "key": "C",
        "text": "5"
      },
      {
        "key": "D",
        "text": "5 tuna"
      },
      {
        "key": "E",
        "text": "5tuna"
      },
      {
        "key": "F",
        "text": "51tuna"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "G"
    ],
    "explanation": "Line 5 does not compile. This question is checking to see if you are paying attention \nto the types. numFish is an int and 1 is an int. Therefore, we use numeric addition and \nget 5. The problem is that we can’t store an int in a String variable. Supposing line 5 \nsaid String anotherFish = numFish + 1 + \"\";. In that case, the answer would be \noptions A and D. The variable defined on line 5 would be the string \"5\", and both out\u0002put statements would use concatenation.\n"
  },
  {
    "id": "oca-43",
    "question": "Which of the following are output by this code? (Choose all that apply)\n3: String s = \"Hello\";\n4: String t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.equals(s)) System.out.println(\"three\");\n8: if (\"Hello\" == s) System.out.println(\"four\");\n9: if (\"Hello\" == t) System.out.println(\"five\");",
    "choices": [
      {
        "key": "A",
        "text": "one"
      },
      {
        "key": "B",
        "text": "two"
      },
      {
        "key": "C",
        "text": "three"
      },
      {
        "key": "D",
        "text": "four"
      },
      {
        "key": "E",
        "text": "five"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 \ncalls the String constructor explicitly and is therefore a different object than s. Lines 5 \nand 7 check for object equality, which is true, and so print one and three. Line 6 uses \nobject reference equality, which is not true since we have different objects. Line 7 also \ncompares references but is true since both references point to the object from the string \npool. Finally, line 8 compares one object from the string pool with one that was explic\u0002itly constructed and returns false.\n"
  },
  {
    "id": "oca-44",
    "question": "Which are true statements? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "An immutable object can be modified."
      },
      {
        "key": "B",
        "text": "An immutable object cannot be modified."
      },
      {
        "key": "C",
        "text": "An immutable object can be garbage collected."
      },
      {
        "key": "E",
        "text": "String  is immutable."
      },
      {
        "key": "F",
        "text": "StringBuffer  is immutable."
      },
      {
        "key": "G",
        "text": "StringBuilder  is immutable."
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "Immutable means the state of an object cannot change once it is created. \nImmutable objects can be garbage collected just like mutable objects. String is immu\u0002table. StringBuilder can be mutated with methods like append(). Although \n340 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 340\nStringBuffer isn’t on the exam, you should know about it anyway in case older ques\u0002tions haven’t been removed.\n"
  },
  {
    "id": "oca-45",
    "question": "What is the result of the following code?\n7: StringBuilder sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
    "choices": [
      {
        "key": "A",
        "text": "abbaaccc"
      },
      {
        "key": "B",
        "text": "abbaccca"
      },
      {
        "key": "C",
        "text": "bbaaaccc"
      },
      {
        "key": "D",
        "text": "bbaaccca"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". \nThat result is passed to the first insert() call, which inserts at index 1. At this point \nsb contains abbbaa. That result is passed to the final insert(), which inserts at index \n4, resulting in abbaccca.\n"
  },
  {
    "id": "oca-46",
    "question": "What is the result of the following code?\n2: String s1 = \"java\";\n3: StringBuilder s2 = new StringBuilder(\"java\");\n4: if (s1 == s2)\n5:  System.out.print(\"1\");\n6: if (s1.equals(s2))\n7:  System.out.print(\"2\");",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "12"
      },
      {
        "key": "D",
        "text": "No output is printed."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The question is trying to distract you into paying attention to logical equality versus \nobject reference equality. It is hoping you will miss the fact that line 4 does not com\u0002pile. Java does not allow you to compare String and StringBuilder using ==.\n"
  },
  {
    "id": "oca-47",
    "question": "What is the result of the following code?\npublic class Lion {\n  public void roar(String roar1, StringBuilder roar2) {\n    roar1.concat(\"!!!\");\n    roar2.append(\"!!!\");\n  }\npublic static void main(String[] args) {\n  String roar1 = \"roar\";\n  StringBuilder roar2 = new StringBuilder(\"roar\");\n  new Lion().roar(roar1, roar2);Review Questions  155\n} }",
    "choices": [
      {
        "key": "A",
        "text": "roar roar"
      },
      {
        "key": "B",
        "text": "roar roar!!!"
      },
      {
        "key": "C",
        "text": "roar!!! roar"
      },
      {
        "key": "D",
        "text": "roar!!! roar!!!"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "A String is immutable. Calling concat() returns a new String but does not change \nthe original. A StringBuilder is mutable. Calling append() adds characters to the \nexisting character sequence along with returning a reference to the same object. \n"
  },
  {
    "id": "oca-48",
    "question": "Which are the results of the following code? (Choose all that apply)\nString letters = \"abcdef\";\nSystem.out.println(letters.length());\nSystem.out.println(letters.charAt(3));\nSystem.out.println(letters.charAt(6));",
    "choices": [
      {
        "key": "A",
        "text": "5"
      },
      {
        "key": "B",
        "text": "6"
      },
      {
        "key": "C",
        "text": "c"
      },
      {
        "key": "D",
        "text": "d"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "length() is simply a count of the number of characters in a String. In this \ncase, there are six characters. charAt() returns the character at that index. Remember \nthat indexes are zero based, which means that index 3 corresponds to d and index 6 \ncorresponds to 1 past the end of the array. A StringIndexOutOfBoundsException is \nthrown for the last line.\n"
  },
  {
    "id": "oca-49",
    "question": "Which are the results of the following code? (Choose all that apply)\nString numbers = \"012345678\";\nSystem.out.println(numbers.substring(1, 3));\nSystem.out.println(numbers.substring(7, 7));\nSystem.out.println(numbers.substring(7));",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "123"
      },
      {
        "key": "C",
        "text": "7"
      },
      {
        "key": "D",
        "text": "78"
      },
      {
        "key": "E",
        "text": "A blank line."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "substring() has two forms. The first takes the index to start with and the \nindex to stop immediately before. The second takes just the index to start with and \ngoes to the end of the String. Remember that indexes are zero based. The first call \nstarts at index 1 and ends with index 2 since it needs to stop before index 3. The sec\u0002ond call starts at index 7 and ends in the same place, resulting in an empty String. \nThis prints out a blank line. The final call starts at index 7 and goes to the end of the \nString.\n"
  },
  {
    "id": "oca-50",
    "question": "What is the result of the following code? \n3: String s = \"purr\";\n4: s.toUpperCase();\n5: s.trim();\n6: s.substring(1, 3);\n8: System.out.println(s.length());",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "8"
      },
      {
        "key": "D",
        "text": "10"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "This question is trying to see if you know that String objects are immutable. Line \n4 returns \"PURR\" but the result is ignored and not stored in s. Line 5 returns \"purr\"\nsince there is no whitespace present but the result is again ignored. Line 6 returns \"ur\"\nbecause it starts with index 1 and ends before index 3 using zero-based indexes. The \nresult is ignored again. Finally, on line 6 something happens. We concatenate four new \ncharacters to s and now have a String of length 8.\n"
  },
  {
    "id": "oca-51",
    "question": "What is the result of the following code? (Choose all that apply)\n13: String a = \"\";\n14: a += 2;\n15: a += 'c';\n16: a += false;  \n17: if ( a == \"2cfalse\") System.out.println(\"==\");\n18: if ( a.equals(\"2cfalse\")) System.out.println(\"equals\");",
    "choices": [
      {
        "key": "A",
        "text": "Compile error on line 14."
      },
      {
        "key": "B",
        "text": "Compile error on line 15."
      },
      {
        "key": "C",
        "text": "Compile error on line 16."
      },
      {
        "key": "D",
        "text": "Compile error on another line."
      },
      {
        "key": "E",
        "text": "=="
      },
      {
        "key": "F",
        "text": "equals"
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "a += 2 expands to a = a + 2. A String concatenated with any other type gives \na String. Lines 14, 15, and 16 all append to a, giving a result of \"2cfalse\". The if\nstatement on line 18 returns false because the values of the two String objects are the \nsame using object equality. The if statement on line 17 returns false because the two \nString objects are not the same in memory. One comes directly from the string pool \nand the other comes from building using String operations.\n"
  },
  {
    "id": "oca-52",
    "question": "What is the result of the following code?\n4: int total = 0;\n5: StringBuilder letters = new StringBuilder(\"abcdefg\");\n6: total += letters.substring(1, 2).length();\n7: total += letters.substring(6, 6).length();\n8: total += letters.substring(6, 5).length();\n9: System.out.println(total);",
    "choices": [
      {
        "key": "A",
        "text": "1"
      },
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "7"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile.Review Questions  157\nStringBuilder numbers = new StringBuilder(\"0123456789\");\nnumbers.delete(2,  8);\nnumbers.append(\"-\").insert(2, \"+\");\nSystem.out.println(numbers);"
      },
      {
        "key": "A",
        "text": "01+89–"
      },
      {
        "key": "B",
        "text": "012+9–"
      },
      {
        "key": "C",
        "text": "012+–9"
      },
      {
        "key": "D",
        "text": "0123456789"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Line 6 adds 1 to total because substring() includes the starting index but not \nthe ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the \nindexes to be specified in reverse order and the code throws a StringIndexOutOf\u0002BoundsException.\n"
  },
  {
    "id": "oca-53",
    "question": "What is the result of the following code?\nStringBuilder b = \"rumble\";\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);\nSystem.out.println(b);",
    "choices": [
      {
        "key": "A",
        "text": "rum"
      },
      {
        "key": "B",
        "text": "rum4"
      },
      {
        "key": "C",
        "text": "rumb4"
      },
      {
        "key": "D",
        "text": "rumble4"
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "First, we delete the characters at index 2 until the character one before index 8. At \nthis point, 0189 is in numbers. The following line uses method chaining. It appends a \ndash to the end of the characters sequence, resulting in 0189–, and then inserts a plus \nsign at index 2, resulting in 01+89–.\n"
  },
  {
    "id": "oca-54",
    "question": "Which of the following can replace line 4 to print \"avaJ\" ? (Choose all that apply)\n3: StringBuilder puzzle = new StringBuilder(\"Java\");\n4: // INSERT CODE HERE\n5: System.out.println(puzzle);",
    "choices": [
      {
        "key": "A",
        "text": "puzzle.reverse();"
      },
      {
        "key": "B",
        "text": "puzzle.append(\"vaJ$\").substring(0, 4);"
      },
      {
        "key": "C",
        "text": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() - 1);"
      },
      {
        "key": "D",
        "text": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length());"
      },
      {
        "key": "E",
        "text": "None of the above."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "This is a trick question. The first line does not compile because you cannot \nassign a String to a StringBuilder. If that line were StringBuilder b = new \nStringBuilder(\"rumble\"), the code would compile and print rum4. Watch out for this \nsort of trick on the exam. You could easily spend a minute working out the character \npositions for no reason at all.\n"
  },
  {
    "id": "oca-55",
    "question": "Which of these array declarations is not legal? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "int[][] scores = new int[5][];"
      },
      {
        "key": "B",
        "text": "Object[][][] cubbies = new Object[3][0][5];"
      },
      {
        "key": "C",
        "text": "String beans[] = new beans[6];"
      },
      {
        "key": "D",
        "text": "java.util.Date[] dates[] = new java.util.Date[2][];"
      },
      {
        "key": "E",
        "text": "int[][] types = new int[];"
      },
      {
        "key": "F",
        "text": "int[][] java = new int[][];\n7: char[]c = new char[2];\n8: // INSERT CODE HERE"
      },
      {
        "key": "A",
        "text": "int length = c.capacity;"
      },
      {
        "key": "B",
        "text": "int length = c.capacity();"
      },
      {
        "key": "C",
        "text": "int length = c.length;"
      },
      {
        "key": "D",
        "text": "int length = c.length();"
      },
      {
        "key": "E",
        "text": "int length = c.size;"
      },
      {
        "key": "F",
        "text": "int length = c.size();"
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "C"
    ],
    "explanation": "The reverse() method is the easiest way of reversing the characters in a String\u0002Builder; therefore, option A is correct. Option B is a nice distraction—it does in fact \nreturn \"avaJ\". However, substring() returns a String, which is not stored anywhere. \nOption C uses method chaining. First it creates the value \"JavavaJ$\". Then it removes \nthe first three characters, resulting in \"avaJ$\". Finally, it removes the last character, \nresulting in \"avaJ\". Option D throws an exception because you cannot delete the char\u0002acter after the last index. Remember that deleteCharAt() uses indexes that are zero \nbased and length() counts starting with 1.\n"
  },
  {
    "id": "oca-56",
    "question": "Which of these compile when replacing line 8? (Choose all that apply)\n7: ArrayList l = new ArrayList();\n8: // INSERT CODE HERE",
    "choices": [
      {
        "key": "A",
        "text": "int length = l.capacity;"
      },
      {
        "key": "B",
        "text": "int length = l.capacity();"
      },
      {
        "key": "C",
        "text": "int length = l.length;"
      },
      {
        "key": "D",
        "text": "int length = l.length();"
      },
      {
        "key": "E",
        "text": "int length = l.size;"
      },
      {
        "key": "F",
        "text": "int length = l.size();"
      },
      {
        "key": "G",
        "text": "None of the above."
      }
    ],
    "answer": [
      "C",
      "E",
      "F"
    ],
    "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. \nOptions E and F don’t specify any size. Although it is legal to leave out the size for later \ndimensions of a multidimensional array, the first one is required. Option A declares a \nlegal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. \nRemember that it is normal to see on the exam types you might not have learned. You \naren’t expected to know anything about them.\n"
  },
  {
    "id": "oca-57",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "An array has a fixed size."
      },
      {
        "key": "B",
        "text": "An ArrayList  has a fixed size."
      },
      {
        "key": "C",
        "text": "An array allows multiple dimensions."
      },
      {
        "key": "D",
        "text": "An array is ordered."
      },
      {
        "key": "E",
        "text": "An ArrayList  is ordered."
      },
      {
        "key": "F",
        "text": "An array is immutable."
      },
      {
        "key": "G",
        "text": "An ArrayList  is immutable."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Arrays define a property called length. It is not a method, so parentheses are not \nallowed.\n"
  },
  {
    "id": "oca-58",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Two arrays with the same content are equal."
      },
      {
        "key": "B",
        "text": "Two ArrayLists  with the same content are equal."
      },
      {
        "key": "C",
        "text": "If you call remove(0)  using an empty ArrayList  object, it will compile successfully."
      },
      {
        "key": "D",
        "text": "If you call remove(0)  using an empty ArrayList  object, it will run successfully."
      },
      {
        "key": "E",
        "text": "None of the above.Review Questions  159\n6:  List<String> list = new ArrayList<String>();\n7:  list.add(\"one\");\n8:  list.add(\"two\");\n9:  list.add(7);\n10: for(String s : list)  System.out.print(s);"
      },
      {
        "key": "A",
        "text": "onetwo"
      },
      {
        "key": "B",
        "text": "onetwo7"
      },
      {
        "key": "C",
        "text": "onetwo  followed by an exception"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9."
      },
      {
        "key": "E",
        "text": "Compiler error on line 10."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The ArrayList class defines a method called size().\n"
  },
  {
    "id": "oca-59",
    "question": "What is the result of the following statements?\n3: ArrayList<Integer> values = new ArrayList<>();\n4: values.add(4);\n5: values.add(5);\n6: values.set(1, 6);\n7: values.remove(0);\n8: for (Integer v : values) System.out.print(v);",
    "choices": [
      {
        "key": "A",
        "text": "4"
      },
      {
        "key": "B",
        "text": "5"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "46"
      },
      {
        "key": "E",
        "text": "45"
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "An array is not able to change size and can have multiple dimensions. Both \nan array and ArrayList are ordered and have indexes. Neither is immutable. The ele\u0002ments can change in value.\n"
  },
  {
    "id": "oca-60",
    "question": "What is the result of the following?\nint[] random = { 6, -4, 12, 0, -10 };\nint x = 12;\nint y = Arrays.binarySearch(random, x);\nSystem.out.println(y);",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "The result is undefined."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      },
      {
        "key": "F",
        "text": "The code does not compile.\n4: List<Integer> list = Arrays.asList(10, 4, -1, 5);\n5: Collections.sort(list);\n6: Integer array[] = list.toArray(new Integer[4]);\n7: System.out.println(array[0]);"
      },
      {
        "key": "A",
        "text": "–1"
      },
      {
        "key": "B",
        "text": "10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 4."
      },
      {
        "key": "D",
        "text": "Compiler error on line 5."
      },
      {
        "key": "E",
        "text": "Compiler error on line 6."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "An array does not override equals() and so uses object equality. ArrayList does \noverride equals() and defines it as the same elements in the same order. The compiler \ndoes not know when an index is out of bounds and thus can’t give you a compiler \nerror. The code will throw an exception at runtime, though.\n"
  },
  {
    "id": "oca-61",
    "question": "What is the result of the following?\n6: String [] names = {\"Tom\", \"Dick\", \"Harry\"};\n7: List<String> list = names.asList();\n8: list.set(0, \"Sue\");\n9: System.out.println(names[0]);",
    "choices": [
      {
        "key": "A",
        "text": "Sue"
      },
      {
        "key": "B",
        "text": "Tom"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7."
      },
      {
        "key": "D",
        "text": "Compiler error on line 8."
      },
      {
        "key": "E",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code does not compile because list is instantiated using generics. Only String\nobjects can be added to list and 7 is an int.\n"
  },
  {
    "id": "oca-62",
    "question": "What is the result of the following?\nList<String> hex = Arrays.asList(\"30\", \"8\", \"3A\", \"FF\");\nCollections.sort(hex);\nint x = Collections.binarySearch(hex, \"8\");\nint y = Collections.binarySearch(hex, \"3A\");\nint z = Collections.binarySearch(hex, \"4F\");\nSystem.out.println(x + \" \" + y + \" \" + z);\nA 0 1 –2",
    "choices": [
      {
        "key": "B",
        "text": "0 1 –3"
      },
      {
        "key": "C",
        "text": "2 1 –2"
      },
      {
        "key": "D",
        "text": "2 1 –3"
      },
      {
        "key": "E",
        "text": "None of the above."
      },
      {
        "key": "F",
        "text": "The code doesn’t compile."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "After line 4, values has one element (4). After line 5, values has two elements (4, \n5). After line 6, values has two elements (4, 6) because set() does a replace. After line \n7, values has only one element (6).\n"
  },
  {
    "id": "oca-63",
    "question": "Which of the following are true statements about the following code? (Choose all that \napply)\n4: List<Integer> ages = new ArrayList<>();\n5: ages.add(Integer.parseInt(\"5\"));Review Questions  161\n7: ages.add(7);\n8: ages.add(null);\n9: for (int age : ages) System.out.print(age);",
    "choices": [
      {
        "key": "A",
        "text": "The code compiles."
      },
      {
        "key": "B",
        "text": "The code throws a runtime exception."
      },
      {
        "key": "C",
        "text": "Exactly one of the add statements uses autoboxing."
      },
      {
        "key": "D",
        "text": "Exactly two of the add statements use autoboxing."
      },
      {
        "key": "E",
        "text": "Exactly three of the add statements use autoboxing."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code compiles and runs fine. However, an array must be sorted for binarySe\u0002arch() to return a meaningful result.\n342 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 342\n"
  },
  {
    "id": "oca-64",
    "question": "What is the result of the following?\nList<String> one = new ArrayList<String>();\none.add(\"abc\");\nList<String> two = new ArrayList<>();\ntwo.add(\"abc\");\nif (one == two) \n  System.out.println(\"A\");\nelse if (one.equals(two))\n  System.out.println(\"B\");\nelse \n  System.out.println(\"C\");",
    "choices": [
      {
        "key": "A",
        "text": "A"
      },
      {
        "key": "B",
        "text": "B"
      },
      {
        "key": "C",
        "text": "C"
      },
      {
        "key": "D",
        "text": "An exception is thrown."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Line 4 creates a fixed size array of size 4. Line 5 sorts it. Line 6 converts it back to \nan array. The brackets aren’t in the traditional place, but they are still legal. Line 7 \nprints the first element, which is now –1.\n"
  },
  {
    "id": "oca-65",
    "question": "Which of the following can be inserted into the blank to create a date of June 21, 2014? \n(Choose all that apply)\nimport java.time.*;\npublic class StartOfSummer {\n  public static void main(String[] args) {\n  LocalDate date = ____________________________\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "new LocalDate(2014, 5, 21);"
      },
      {
        "key": "B",
        "text": "new LocalDate(2014, 6, 21);"
      },
      {
        "key": "C",
        "text": "LocalDate.of(2014, 5, 21);"
      },
      {
        "key": "E",
        "text": "LocalDate.of(2014, Calendar.JUNE, 21);"
      },
      {
        "key": "F",
        "text": "LocalDate.of(2014, Month.JUNE, 21);"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Converting from an array to an ArrayList uses Arrays.asList(names). There is \nno asList() method on an array instance. If this code were corrected to compile, the \nanswer would be option A.\n"
  },
  {
    "id": "oca-66",
    "question": "What is the output of the following code?\nLocalDate date = LocalDate.parse(\"2018-04-30\", DateTimeFormatter.ISO_LOCAL_\nDATE);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \"\n+ date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 2"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 2"
      },
      {
        "key": "D",
        "text": "The code does not compile."
      },
      {
        "key": "E",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before \nletters and strings sort alphabetically. This makes 30 come before 8. A binary search \ncorrectly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should \nbe at index 2. The rule when an item isn’t found is to negate that index and subtract 1. \nTherefore, we get –2–1, which is –3.\n"
  },
  {
    "id": "oca-67",
    "question": "What is the output of the following code?\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \"\n+ date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 4"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 10"
      },
      {
        "key": "D",
        "text": "Another date."
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Lines 5 and 7 use autoboxing to convert an int to an Integer. Line 6 does \nnot because valueOf() returns an Integer. Line 8 does not because null is not an int. \nThe code does not compile. However, when the for loop tries to unbox null into an \nint, it fails and throws a NullPointerException.\n"
  },
  {
    "id": "oca-68",
    "question": "What is the output of the following code?\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \"\n+ date.getDayOfMonth());",
    "choices": [
      {
        "key": "A",
        "text": "2018 APRIL 2"
      },
      {
        "key": "B",
        "text": "2018 APRIL 30"
      },
      {
        "key": "C",
        "text": "2018 MAY 2"
      },
      {
        "key": "D",
        "text": "2021 APRIL 2Review Questions  163"
      },
      {
        "key": "F",
        "text": "2021 MAY 2"
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The first if statement is false because the variables do not point to the same object. \nThe second if statement is true because ArrayList implements equality to mean the \nsame elements in the same order.\n"
  },
  {
    "id": "oca-69",
    "question": "What is the output of the following code?\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.of(1, 2, 3);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);\nSystem.out.println(d.format(f));",
    "choices": [
      {
        "key": "A",
        "text": "3/7/14 11:22 AM"
      },
      {
        "key": "B",
        "text": "5/10/15 11:22 AM"
      },
      {
        "key": "C",
        "text": "3/7/14"
      },
      {
        "key": "D",
        "text": "5/10/15"
      },
      {
        "key": "E",
        "text": "11:22 AM"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "D",
      "F"
    ],
    "explanation": "Options A and B are incorrect because LocalDate does not have a public con\u0002structor. Option C is incorrect because months start counting with 1 rather than 0. \nOption E is incorrect because it uses the old pre–Java 8 way of counting months, again \nbeginning with 0. Options D and F are both correct ways of specifying the desired \ndate.\n"
  },
  {
    "id": "oca-70",
    "question": "What is the output of the following code?\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.ofDays(1).ofYears(2);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle\n.SHORT);\nSystem.out.println(f.format(d));\n A. 5/9/13 11:22 AM",
    "choices": [
      {
        "key": "B",
        "text": "5/10/13 11:22 AM"
      },
      {
        "key": "C",
        "text": "5/9/14"
      },
      {
        "key": "D",
        "text": "5/10/14"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "A LocalDate does not have a time element. Therefore, it has no method to add \nhours and the code does not compile.\n"
  },
  {
    "id": "oca-71",
    "question": "Which of the following can fill in the blank in this code to make it compile? (Choose all \nthat apply)\npublic class Ant {\n  _____ void method() { }\n}",
    "choices": [
      {
        "key": "A",
        "text": "default"
      },
      {
        "key": "B",
        "text": "final"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "Public"
      },
      {
        "key": "E",
        "text": "String"
      },
      {
        "key": "F",
        "text": "zzz:"
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "void is a return type. Only the access modifier or optional specifiers are allowed \nbefore the return type. Option C is correct, creating a method with private access. \nOption B is correct, creating a method with default access and the optional specifier \nfinal. Since default access does not require a modifier, we get to jump right to final. \nOption A is incorrect because default access omits the access modifier rather than spec\u0002ifying default. Option D is incorrect because Java is case sensitive. It would have been \ncorrect if public were the choice. Option E is incorrect because the method already has \na void return type. Option F is incorrect because labels are not allowed for methods.\n"
  },
  {
    "id": "oca-72",
    "question": "Which of the following compile? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "final static void method4() { }"
      },
      {
        "key": "B",
        "text": "public final int void method() { }"
      },
      {
        "key": "C",
        "text": "private void int method() { }"
      },
      {
        "key": "D",
        "text": "static final void method3() { }"
      },
      {
        "key": "E",
        "text": "void final method() {}"
      },
      {
        "key": "F",
        "text": "void public method() { }"
      }
    ],
    "answer": [
      "A",
      "D"
    ],
    "explanation": "Options A and D are correct because the optional specifiers are allowed in any \norder. Options B and C are incorrect because they each have two return types. Options \nE and F are incorrect because the return type is before the optional specifier and access \nmodifier, respectively.\n"
  },
  {
    "id": "oca-73",
    "question": "Which of the following methods compile? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "public void methodA() {  return;}"
      },
      {
        "key": "B",
        "text": "public void methodB() {  return null;}"
      },
      {
        "key": "C",
        "text": "public void methodD() {}"
      },
      {
        "key": "D",
        "text": "public int methodD() {  return 9;}"
      },
      {
        "key": "E",
        "text": "public int methodE() {  return 9.0;}"
      },
      {
        "key": "F",
        "text": "public int methodF() {  return;}"
      },
      {
        "key": "G",
        "text": "public int methodG() {  return null;}"
      }
    ],
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Options A and C are correct because a void method is allowed to have a \nreturn statement as long as it doesn’t try to return a value. Options B and G do not \ncompile because null requires a reference object as the return type. void is not a refer\u0002ence object since it is a marker for no return type. int is not a reference object since it \nis a primitive. Option D is correct because it returns an int value. Option E does not \ncompile because it tries to return a double when the return type is int. Since a double\ncannot be assigned to an int, it cannot be returned as one either. Option F does not \ncompile because no value is actually returned.\n"
  },
  {
    "id": "oca-74",
    "question": "Which of the following compile? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "public void moreA(int... nums) {}"
      },
      {
        "key": "B",
        "text": "public void moreB(String values, int... nums) {}"
      },
      {
        "key": "C",
        "text": "public void moreC(int... nums, String values) {}"
      },
      {
        "key": "D",
        "text": "public void moreD(String... values, int... nums) {}"
      },
      {
        "key": "E",
        "text": "public void moreE(String[] values, ...int nums) {}"
      },
      {
        "key": "F",
        "text": "public void moreF(String... values, int[] nums) {}"
      },
      {
        "key": "G",
        "text": "public void moreG(String[] values, int[] nums) {}Review Questions  219\npublic int howMany(boolean b, boolean... b2) {\n  return b2.length;\n}"
      },
      {
        "key": "A",
        "text": "howMany();"
      },
      {
        "key": "B",
        "text": "howMany(true);"
      },
      {
        "key": "C",
        "text": "howMany(true, true);"
      },
      {
        "key": "D",
        "text": "howMany(true, true, true);"
      },
      {
        "key": "E",
        "text": "howMany(true, {true});"
      },
      {
        "key": "F",
        "text": "howMany(true, {true, true});"
      },
      {
        "key": "G",
        "text": "howMany(true, new boolean[2]);"
      }
    ],
    "answer": [
      "A",
      "B",
      "G"
    ],
    "explanation": "Options A and B are correct because the single vararg parameter is the last \nparameter declared. Option G is correct because it doesn’t use any vararg parameters \nat all. Options C and F are incorrect because the vararg parameter is not last. Option \nD is incorrect because two vararg parameters are not allowed in the same method. \nOption E is incorrect because the ... for a vararg must be after the type, not before it.\n"
  },
  {
    "id": "oca-75",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Package private access is more lenient than protected access."
      },
      {
        "key": "B",
        "text": "A public  class that has private fields and package private methods is not visible to \nclasses outside the package."
      },
      {
        "key": "C",
        "text": "You can use access modifiers so only some of the classes in a package see a particular \npackage private class."
      },
      {
        "key": "D",
        "text": "You can use access modifiers to allow read access to all methods, but not any instance \nvariables."
      },
      {
        "key": "E",
        "text": "You can use access modifiers to restrict read access to all classes that begin with the \nword Test ."
      }
    ],
    "answer": [
      "D",
      "G"
    ],
    "explanation": "Option D passes the initial parameter plus two more to turn into a vararg array \nof size 2. Option G passes the initial parameter plus an array of size 2. Option A does \nnot compile because it does not pass the initial parameter. Options E and F do not \ncompile because they do not declare an array properly. It should be new boolean[] \n{true}. Option B creates a vararg array of size 0 and option C creates a vararg array of \nsize 1.\n"
  },
  {
    "id": "oca-76",
    "question": "Given the following my.school.ClassRoom  and my.city.School  class definitions, which \nline numbers in main()  generate a compiler error? (Choose all that apply)\n1: package my.school;\n2: public class Classroom {\n3:   private int roomNumber;\n4:   protected String teacherName;\n5:   static int globalKey = 54321;\n6:   public int floor = 3;\n7:   Classroom(int r, String t) {\n8:     roomNumber = r;\n9:     teacherName = t; } }\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4:   public static void main(String[] args) {\n5:     System.out.println(Classroom.globalKey);\n6:     Classroom room = new Classroom(101, \"\"Mrs. Anderson\");\n8:     System.out.println(room.floor);\n9:     System.out.println(room.teacherName); } }",
    "choices": [
      {
        "key": "A",
        "text": "None, the code compiles fine."
      },
      {
        "key": "B",
        "text": "Line 5"
      },
      {
        "key": "C",
        "text": "Line 6"
      },
      {
        "key": "D",
        "text": "Line 7"
      },
      {
        "key": "E",
        "text": "Line 8"
      },
      {
        "key": "F",
        "text": "Line 9"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "Option D is correct. This is the common implementation for encapsulation by set\u0002ting all fields to be private and all methods to be public. Option A is incorrect because \nprotected access allows everything that package private access allows and additionally \nallows subclasses access. Option B is incorrect because the class is public. This means \nthat other classes can see the class. However, they cannot call any of the methods or \nread any of the fields. It is essentially a useless class. Option C is incorrect because \npackage private access applies to the whole package. Option E is incorrect because Java \nhas no such capability.\n"
  },
  {
    "id": "oca-77",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Encapsulation uses package private instance variables."
      },
      {
        "key": "B",
        "text": "Encapsulation uses private instance variables."
      },
      {
        "key": "C",
        "text": "Encapsulation allows setters."
      },
      {
        "key": "D",
        "text": "Immutability uses package private instance variables."
      },
      {
        "key": "E",
        "text": "Immutability uses private instance variables."
      },
      {
        "key": "F",
        "text": "Immutability allows setters."
      }
    ],
    "answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "The two classes are in different packages, which means private access and \ndefault (package private) access will not compile. Additionally, protected access will \nnot compile since School does not inherit from Classroom. Therefore, only line 8 will \ncompile because it uses public access.\n"
  },
  {
    "id": "oca-78",
    "question": "Which are methods using JavaBeans naming conventions for accessors and mutators? \n(Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "public boolean getCanSwim() {  return canSwim;}"
      },
      {
        "key": "B",
        "text": "public boolean canSwim() {  return numberWings;}"
      },
      {
        "key": "C",
        "text": "public int getNumWings() {  return numberWings;}"
      },
      {
        "key": "D",
        "text": "public int numWings()    {  return numberWings;}"
      },
      {
        "key": "E",
        "text": "public void setCanSwim(boolean b) {  canSwim = b;}"
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "Encapsulation requires using methods to get and set instance variables so \nother classes are not directly using them. Instance variables must be private for this \nto work. Immutability takes this a step further, allowing only getters, so the instance \nvariables do not change state.\n344 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 344\n"
  },
  {
    "id": "oca-79",
    "question": "What is the output of the following code? \n1: package rope;\n2: public class Rope {\n3:  public static int LENGTH = 5;\n4:  static { \n5:    LENGTH = 10;\n6:  }Review Questions  221\n8:    System.out.print(\"swing \");\n9:  }\n10: }\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4:  public static void main(String[] args) {\n5:    Rope.swing();\n6:    new Rope().swing();\n7:    System.out.println(LENGTH);\n8:  } \n9: }",
    "choices": [
      {
        "key": "A",
        "text": "swing swing 5"
      },
      {
        "key": "B",
        "text": "swing swing 10"
      },
      {
        "key": "C",
        "text": "Compiler error on line 2 of Chimp."
      },
      {
        "key": "D",
        "text": "Compiler error on line 5 of Chimp."
      },
      {
        "key": "E",
        "text": "Compiler error on line 6 of Chimp."
      },
      {
        "key": "F",
        "text": "Compiler error on line 7 of Chimp."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Option A is incorrect because the property is of type boolean and getters must \nbegin with is for booleans. Options B and D are incorrect because they don’t follow \nthe naming convention of beginning with get/is/set. Options C and E follow normal \ngetter and setter conventions. \n"
  },
  {
    "id": "oca-80",
    "question": "Which are true of the following code? (Choose all that apply)\n1:  public class Rope {\n2:    public static void swing() {\n3:      System.out.print(\"swing \");\n4:    }\n5:    public void climb() {\n6:      System.out.println(\"climb \");\n7:    }\n8:    public static void play() {\n9:      swing();\n10:     climb();\n11:   }\n12:   public static void main(String[] args) {\n13:     Rope rope = new Rope();\n14:     rope.play();\n15:     Rope rope2 = null;\n16:     rope2.play();\n17:   }\n18: }",
    "choices": [
      {
        "key": "B",
        "text": "There is exactly one compiler error in the code."
      },
      {
        "key": "C",
        "text": "There are exactly two compiler errors in the code."
      },
      {
        "key": "D",
        "text": "If the lines with compiler errors are removed, the output is climb climb ."
      },
      {
        "key": "E",
        "text": "If the lines with compiler errors are removed, the output is swing swing ."
      },
      {
        "key": "F",
        "text": "If the lines with compile errors are removed, the code throws a NullPointerException ."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initial\u0002izer, which sets it to 10. Line 5 calls the static method normally and prints swing. \nLine 6 also calls the static method. Java allows calling a static method through an \ninstance variable. Line 7 uses the static import on line 2 to reference LENGTH.\n"
  },
  {
    "id": "oca-81",
    "question": "What is the output of the following code?\nimport rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n  private static Rope rope1 = new Rope();\n  private static Rope rope2 = new Rope();\n  {\n    System.out.println(rope1.length);\n  }\n  public static void main(String[] args) {\n    rope1.length = 2;\n    rope2.length = 8;\n    System.out.println(rope1.length);\n  }\n}\npackage rope;\npublic class Rope {\n  public static int length = 0;\n}",
    "choices": [
      {
        "key": "A",
        "text": "02"
      },
      {
        "key": "B",
        "text": "08"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "8"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "B",
      "E"
    ],
    "explanation": "Line 10 does not compile because static methods are not allowed to call instance \nmethods. Even though we are calling play() as if it were an instance method and an \ninstance exists, Java knows play() is really a static method and treats it as such. If line \n10 is removed, the code works. It does not throw a NullPointerException on line 16 \nbecause play() is a static method. Java looks at the type of the reference for rope2 and \ntranslates the call to Rope.play().\n"
  },
  {
    "id": "oca-82",
    "question": "How many compiler errors are in the following code?\n1: public class RopeSwing {\n2:   private static final String leftRope;\n3:   private static final String rightRope;\n4:   private static final String bench;\n5:   private static final String name = \"name\";Review Questions  223\n7:     leftRope = \"left\";\n8:     rightRope = \"right\";\n9:   }\n10:   static {\n11:     name = \"name\";\n12:     rightRope = \"right\";\n13:   }\n14:   public static void main(String[] args) {\n15:     bench = \"bench\";\n16:   }\n17: }",
    "choices": [
      {
        "key": "A",
        "text": "0"
      },
      {
        "key": "B",
        "text": "1"
      },
      {
        "key": "C",
        "text": "2"
      },
      {
        "key": "D",
        "text": "3"
      },
      {
        "key": "E",
        "text": "4"
      },
      {
        "key": "F",
        "text": "5"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "There are two details to notice in this code. First, note that RopeSwing has an \ninstance initializer and not a static initializer. Since RopeSwing is never constructed, \nthe instance initializer does not run. The other detail is that length is static. Changes \nfrom one object update this common static variable.\n"
  },
  {
    "id": "oca-83",
    "question": "Which of the following can replace line 2 to make this code compile? (Choose \nall that apply)\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4:  public void method(ArrayList<String> list) {\n5:    sort(list);\n6:  }\n7: }",
    "choices": [
      {
        "key": "A",
        "text": "import static java.util.Collections;"
      },
      {
        "key": "B",
        "text": "import static java.util.Collections.*;"
      },
      {
        "key": "C",
        "text": "import static java.util.Collections.sort(ArrayList<String>);"
      },
      {
        "key": "D",
        "text": "static import java.util.Collections;"
      },
      {
        "key": "E",
        "text": "static import java.util.Collections.*;"
      },
      {
        "key": "F",
        "text": "static import java.util.Collections.sort(ArrayList<String>);"
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "static final variables must be set exactly once, and it must be in the declaration \nline or in a static initialization block. Line 4 doesn’t compile because bench is not set \nin either of these locations. Line 15 doesn’t compile because final variables are not \nallowed to be set after that point. Line 11 doesn’t compile because name is set twice: \nonce in the declaration and again in the static block. Line 12 doesn’t compile because \nrightRope is set twice as well. Both are in static initialization blocks.\n"
  },
  {
    "id": "oca-84",
    "question": "What is the result of the following statements?\n1:  public class Test {\n2:    public void print(byte x) {\n3:      System.out.print(\"byte\");\n4:    }\n5:    public void print(int x) {\n6:      System.out.print(\"int\");\n8:    public void print(float x) {\n9:      System.out.print(\"float\");\n10:   }\n11:   public void print(Object x) {\n12:     System.out.print(\"Object\");\n13:   }\n14:   public static void main(String[] args) {\n15:     Test t = new Test();\n16:     short s = 123;\n17:     t.print(s);\n18:     t.print(true);\n19:     t.print(6.789);\n20:   }\n21: }",
    "choices": [
      {
        "key": "A",
        "text": "bytefloatObject"
      },
      {
        "key": "B",
        "text": "intfloatObject"
      },
      {
        "key": "C",
        "text": "byteObjectfloat"
      },
      {
        "key": "D",
        "text": "intObjectfloat"
      },
      {
        "key": "E",
        "text": "intObjectObject"
      },
      {
        "key": "F",
        "text": "byteObjectObject"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The two valid ways to do this are import static java.util.Collections.*; and \nimport static java.util.Collections.sort;. Option A is incorrect because you \ncan only do a static import on static members. Classes such as Collections require \na regular import. Option C is nonsense as method parameters have no business in \nan import. Options D, E, and F try to trick you into reversing the syntax of import \nstatic.\n"
  },
  {
    "id": "oca-85",
    "question": "What is the result of the following program?\n1: public class Squares {\n2:   public static long square(int x) {\n3:     long y = x * (long) x;\n4:     x = -1;\n5:     return y;\n6:   }\n7:   public static void main(String[] args) {\n8:     int value = 9;\n9:     long result = square(value);\n10:     System.out.println(value);\n11:   } }",
    "choices": [
      {
        "key": "A",
        "text": "-1"
      },
      {
        "key": "B",
        "text": "9"
      },
      {
        "key": "C",
        "text": "81"
      },
      {
        "key": "D",
        "text": "Compiler error on line 9."
      },
      {
        "key": "E",
        "text": "Compiler error on a different line.Review Questions  225\npublic class StringBuilders {\n  public static StringBuilder work(StringBuilder a, \nStringBuilder b) {\n    a = new StringBuilder(\"a\");\n    b.append(\"b\");\n    return a;\n  }\n  public static void main(String[] args) {\n    StringBuilder s1 = new StringBuilder(\"s1\");\n    StringBuilder s2 = new StringBuilder(\"s2\");\n    StringBuilder s3 = work(s1, s2);\n    System.out.println(\"s1 = \" + s1);\n    System.out.println(\"s2 = \" + s2);\n    System.out.println(\"s3 = \" + s3);\n  }\n}"
      },
      {
        "key": "A",
        "text": "s1 = a"
      },
      {
        "key": "B",
        "text": "s1 = s1"
      },
      {
        "key": "C",
        "text": "s2 = s2"
      },
      {
        "key": "D",
        "text": "s2 = s2b"
      },
      {
        "key": "E",
        "text": "s3 = a"
      },
      {
        "key": "F",
        "text": "s3 = null"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The argument on line 17 is a short. It can be promoted to an int, so print() on \nline 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a bool\u0002ean, so print() on line 11 is invoked. The argument on line 19 is a double. It can \nbe autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is \nintObjectObject and the correct answer is option E. \n"
  },
  {
    "id": "oca-86",
    "question": "Which of the following are true? (Choose 2)",
    "choices": [
      {
        "key": "A",
        "text": "this()  can be called from anywhere in a constructor."
      },
      {
        "key": "B",
        "text": "this()  can be called from any instance method in the class."
      },
      {
        "key": "C",
        "text": "this.variableName  can be called from any instance method in the class."
      },
      {
        "key": "D",
        "text": "this.variableName  can be called from any static method in the class."
      },
      {
        "key": "E",
        "text": "You must include a default constructor in the code if the compiler does not include one."
      },
      {
        "key": "F",
        "text": "You can call the default constructor written by the compiler using this() ."
      },
      {
        "key": "G",
        "text": "You can access a private constructor with the main()  method."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays \nas 9. In the method square, x starts as 9. y becomes 81 and then x gets set to –1. Line 9 \ndoes set result to 81. However, we are printing out value and that is still 9.\n"
  },
  {
    "id": "oca-87",
    "question": "Which of these classes compile and use a default constructor? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "public class Bird { }"
      },
      {
        "key": "B",
        "text": "public class Bird { public bird() {} }"
      },
      {
        "key": "C",
        "text": "public class Bird { public bird(String name) {} }"
      },
      {
        "key": "D",
        "text": "public class Bird { public Bird() {} }"
      },
      {
        "key": "F",
        "text": "public class Bird { private Bird(int age) {} }  "
      },
      {
        "key": "G",
        "text": "public class Bird { void Bird() { }"
      }
    ],
    "answer": [
      "B",
      "D",
      "E"
    ],
    "explanation": "Since Java is pass-by-reference, assigning a new object to a does not change the \ncaller. Calling append() does affect the caller because both the method parameter and \ncaller have a reference to the same object. Finally, returning a value does pass the refer\u0002ence to the caller for assignment to s3.\n"
  },
  {
    "id": "oca-88",
    "question": "Which code can be inserted to have the code print 2?\npublic class BirdSeed {\n  private int numberBags;\n  boolean call;\n  public BirdSeed() {\n    // LINE 1\n    call = false;\n    // LINE 2\n  }\n  public BirdSeed(int numberBags) {\n    this.numberBags = numberBags;\n  }\n  public static void main(String[] args) {\n    BirdSeed seed = new BirdSeed();\n    System.out.println(seed.numberBags);\n  } }",
    "choices": [
      {
        "key": "A",
        "text": "Replace line 1 with BirdSeed(2);"
      },
      {
        "key": "B",
        "text": "Replace line 2 with BirdSeed(2);"
      },
      {
        "key": "C",
        "text": "Replace line 1 with new BirdSeed(2);"
      },
      {
        "key": "D",
        "text": "Replace line 2 with new BirdSeed(2);"
      },
      {
        "key": "E",
        "text": "Replace line 1 with this(2);"
      },
      {
        "key": "F",
        "text": "Replace line 2 with this(2);"
      }
    ],
    "answer": [
      "C",
      "G"
    ],
    "explanation": "Since the main() method is in the same class, it can call private methods in the \nclass. this() may only be called as the first line of a constructor. this.variableName\ncan be called from any instance method to refer to an instance variable. It cannot be \ncalled from a static method because there is no instance of the class to refer to. Option \nF is tricky. The default constructor is only written by the compiler if no user-defined \nconstructors were provided. this() can only be called from a constructor in the same \nclass. Since there can be no user-defined constructors in the class if a default construc\u0002tor was created, it is impossible for option F to be true. \n"
  },
  {
    "id": "oca-89",
    "question": "Which of the following complete the constructor so that this code prints out 50? (Choose \nall that apply)\npublic class Cheetah { \n  int numSpots;\n  public Cheetah(int numSpots) {\n    // INSERT CODE HERE\n  } \n  public static void main(String[] args) {\n    System.out.println(new Cheetah(50).numSpots);\n  }\n}Review Questions  227",
    "choices": [
      {
        "key": "B",
        "text": "numSpots = this.numSpots;"
      },
      {
        "key": "C",
        "text": "this.numSpots = numSpots;"
      },
      {
        "key": "D",
        "text": "numSpots = super.numSpots;"
      },
      {
        "key": "E",
        "text": "super.numSpots = numSpots;"
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "G"
    ],
    "explanation": "Options B and C don’t compile because the constructor name must match the \nclassname. Since Java is case sensitive, these don’t match. Options D, E, and F all com\u0002pile and provide one user-defined constructor. Since a constructor is coded, a default \nconstructor isn’t supplied. Option G defines a method, but not a constructor. Option A \ndoes not define a constructor, either. Since no constructor is coded, a default construc\u0002tor is provided for options A and G.\n"
  },
  {
    "id": "oca-90",
    "question": "What is the result of the following?\n1:  public class Order {\n2:    static String result = \"\";\n3:    { result += \"c\"; }\n4:    static \n5:    { result += \"u\"; }\n6:    { result += \"r\"; }\n7: }\n1: public class OrderDriver {\n2:   public static void main(String[] args) {\n3:     System.out.print(Order.result + \" \");\n4:     System.out.print(Order.result + \" \");\n5:     new Order();\n6:     new Order();\n7:     System.out.print(Order.result + \" \");\n8:   }\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "curur"
      },
      {
        "key": "B",
        "text": "ucrcr"
      },
      {
        "key": "C",
        "text": "u ucrcr"
      },
      {
        "key": "D",
        "text": "u u curcur"
      },
      {
        "key": "E",
        "text": "u u ucrcr"
      },
      {
        "key": "F",
        "text": "ur ur urc"
      },
      {
        "key": "G",
        "text": "The code does not compile."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "Options A and B will not compile because constructors cannot be called without \nnew. Options C and D will compile but will create a new object rather than setting the \nfields in this one. Option F will not compile because this() must be the first line of a \nconstructor. Option E is correct.\n"
  },
  {
    "id": "oca-91",
    "question": "What is the result of the following?\n1: public class Order {\n2:   String value = \"t\";\n3:   { value += \"a\"; }\n4:   { value += \"c\"; }\n5:   public Order() {\n7:   }\n8:   public Order(String s) {\n9:     value += s;\n10:  }\n11:  public static void main(String[] args) {\n12:    Order order = new Order(\"f\");\n13:    order = new Order();\n14:    System.out.println(order.value);\n15:  } }",
    "choices": [
      {
        "key": "A",
        "text": "tacb"
      },
      {
        "key": "B",
        "text": "tacf"
      },
      {
        "key": "C",
        "text": "tacbf"
      },
      {
        "key": "D",
        "text": "tacfb"
      },
      {
        "key": "E",
        "text": "tacftacb"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "Within the constructor numSpots refers to the constructor parameter. The instance \nvariable is hidden because they have the same name. this.numSpots tells Java to use \nthe instance variable. In the main() method, numSpots refers to the instance variable. \nOption A sets the constructor parameter to itself, leaving the instance variable as 0. \nOption B sets the constructor parameter to the value of the instance variable, making \nthem both 0. Option C is correct, setting the instance variable to the value of the con\u0002structor parameter. Options D and E do not compile.\n"
  },
  {
    "id": "oca-92",
    "question": "Which of the following will compile when inserted in the following code? (Choose \nall that apply)\npublic class Order3 {\n  final String value1 = \"1\";\n  static String value2 = \"2\";\n  String value3 = \"3\";\n  {\n    // CODE SNIPPET 1\n  }\n  static {\n    // CODE SNIPPET 2\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "value1 = \"d\"; instead of // CODE SNIPPET 1"
      },
      {
        "key": "B",
        "text": "value2 = \"e\"; instead of // CODE SNIPPET 1"
      },
      {
        "key": "C",
        "text": "value3 = \"f\"; instead of // CODE SNIPPET 1"
      },
      {
        "key": "D",
        "text": "value1 = \"g\"; instead of // CODE SNIPPET 2"
      },
      {
        "key": "E",
        "text": "value2 = \"h\"; instead of // CODE SNIPPET 2"
      },
      {
        "key": "F",
        "text": "value3 = \"i\"; instead of // CODE SNIPPET 2Review Questions  229\npublic class Create {\n  Create() {\n    System.out.print(\"1 \");\n  }\n  Create(int num) {\n    System.out.print(\"2 \");\n  }\n  Create(Integer num) {\n    System.out.print(\"3 \");\n  }\n  Create(Object num) {\n    System.out.print(\"4 \");\n  }\n  Create(int... nums) {\n    System.out.print(\"5 \");\n  }\n  public static void main(String[] args) {\n    new Create(100);\n    new Create(1000L);\n  }\n}"
      },
      {
        "key": "A",
        "text": "The code prints out 2 4."
      },
      {
        "key": "B",
        "text": "The code prints out 3 4."
      },
      {
        "key": "C",
        "text": "The code prints out 4 2."
      },
      {
        "key": "D",
        "text": "The code prints out 4 4."
      },
      {
        "key": "E",
        "text": "The code prints 3 4 if you remove the constructor Create(int num) ."
      },
      {
        "key": "F",
        "text": "The code prints 4 4 if you remove the constructor Create(int num) . "
      },
      {
        "key": "G",
        "text": "The code prints 5 4 if you remove the constructor Create(int num) ."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "On line 3 of OrderDriver, we refer to Order for the first time. At this point the stat\u0002ics in Order get initialized. In this case, the statics are the static declaration of result\nand the static initializer. result is u at this point. On line 4, result is the same \nbecause the static initialization is only run once. On line 5, we create a new Order, \nwhich triggers the instance initializers in the order they appear in the file. Now result\nis ucr. Line 6 creates another Order, triggering another set of initializers. Now result\nis ucrcr. Notice how the static is on a different line than the initialization code in \nlines 4–5 of Order. The exam may try to trick you by formatting the code like this to \nconfuse you.\n"
  },
  {
    "id": "oca-93",
    "question": "What is the result of the following class?\n1: import java.util.function.*;\n2: \n3: public class Panda {\n4:   int age;\n5:   public static void main(String[] args) {\n6:     Panda p1 = new Panda();\n7:     p1.age = 1;\n8:     check(p1, p -> p.age < 5);\n10:   private static void check(Panda panda, Predicate<Panda> pred) {\n11:     String result = pred.test(panda) ? \"match\" : \"not match\"; \n12:     System.out.print(result);\n13: } }",
    "choices": [
      {
        "key": "A",
        "text": "match"
      },
      {
        "key": "B",
        "text": "not match"
      },
      {
        "key": "C",
        "text": "Compiler error on line 8."
      },
      {
        "key": "D",
        "text": "Compiler error on line 10."
      },
      {
        "key": "E",
        "text": "Compiler error on line 11."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Line 4 instantiates an Order. Java runs the declarations and instance initializers first \nin the order they appear. This sets value to tacf. Line 5 creates another Order and \ninitializes value to tacb. The object on line 5 is stored in the same variable line 4 used. \nThis makes the object created on line 4 unreachable. When value is printed, it is the \ninstance variable in the object created on line 5.\n346 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 346\n"
  },
  {
    "id": "oca-94",
    "question": "What is the result of the following code?\n1: interface Climb {\n2:   boolean isTooHigh(int height, int limit);\n3: }\n4: \n5: public class Climber {\n6:   public static void main(String[] args) {\n7:   check((h, l) -> h.append(l).isEmpty(), 5);\n8:   }\n9:   private static void check(Climb climb, int height) {\n10:    if (climb.isTooHigh(height, 10)) \n11:      System.out.println(\"too high\");\n12:    else \n13:      System.out.println(\"ok\");\n14:  }\n15: }",
    "choices": [
      {
        "key": "A",
        "text": "ok"
      },
      {
        "key": "B",
        "text": "too high"
      },
      {
        "key": "C",
        "text": "Compiler error on line 7."
      },
      {
        "key": "D",
        "text": "Compiler error on line 10."
      },
      {
        "key": "E",
        "text": "Compiler error on a different line."
      },
      {
        "key": "F",
        "text": "A runtime exception is thrown."
      }
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "explanation": "value1 is a final instance variable. It can only be set once: in the variable dec\u0002laration, an instance initializer, or a constructor. Option A does not compile because \nthe final variable was already set in the declaration. value2 is a static variable. Both \ninstance and static initializers are able to access static variables, making options B \nand E correct. value3 is an instance variable. Options D and F do not compile because \na static initializer does not have access to instance variables. \n"
  },
  {
    "id": "oca-95",
    "question": "Which of the following lambda expressions can fill in the blank? (Choose all that apply)\nList<String> list = new ArrayList<>();\nlist.removeIf(___________________);Review Questions  231",
    "choices": [
      {
        "key": "B",
        "text": "s -> {s.isEmpty()}"
      },
      {
        "key": "C",
        "text": "s -> {s.isEmpty();}"
      },
      {
        "key": "D",
        "text": "s -> {return s.isEmpty();}"
      },
      {
        "key": "E",
        "text": "String s -> s.isEmpty()"
      },
      {
        "key": "F",
        "text": "(String s) -> s.isEmpty()"
      }
    ],
    "answer": [
      "A",
      "E"
    ],
    "explanation": "The 100 parameter is an int and so calls the matching int constructor. When \nthis constructor is removed, Java looks for the next most specific constructor. Java pre\u0002fers autoboxing to varargs, and so chooses the Integer constructor. The 100L param\u0002eter is a long. Since it can’t be converted into a smaller type, it is autoboxed into a Long\nand then the constructor for Object is called. \n"
  },
  {
    "id": "oca-96",
    "question": "Which lambda can replace the MySecret  class to return the same value? (Choose \nall that apply)\ninterface Secret {\n  String magic(double d);\n}\nclass MySecret implements Secret {\n  public String magic(double d) {\n    return \"Poof\";\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "caller((e) -> \"Poof\");"
      },
      {
        "key": "B",
        "text": "caller((e) -> {\"Poof\"});"
      },
      {
        "key": "C",
        "text": "caller((e) -> { String e = \"\"; \"Poof\" });"
      },
      {
        "key": "D",
        "text": "caller((e) -> { String e = \"\"; return \"Poof\"; });"
      },
      {
        "key": "E",
        "text": "caller((e) -> { String e = \"\"; return \"Poof\" });"
      },
      {
        "key": "F",
        "text": "caller((e) -> { String f = \"\"; return \"Poof\"; });"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "This code is correct. Line 8 creates a lambda expression that checks if the age is less \nthan 5. Since there is only one parameter and it does not specify a type, the parentheses \naround the type parameter are optional. Line 10 uses the Predicate interface, which \ndeclares a test() method.\n"
  },
  {
    "id": "oca-97",
    "question": "What modifiers are implicitly applied to all interface methods? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "protected"
      },
      {
        "key": "B",
        "text": "public"
      },
      {
        "key": "C",
        "text": "static"
      },
      {
        "key": "D",
        "text": "void"
      },
      {
        "key": "E",
        "text": "abstract"
      },
      {
        "key": "F",
        "text": "default"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "All interface methods are implicitly public, so option B is correct and option A is \nnot. Interface methods may be declared as static or default but are never implicitly \nadded, so options C and F are incorrect. Option D is incorrect—void is not a modifier; \nit is a return type. Option E is a tricky one, because prior to Java 8 all interface meth\u0002ods would be assumed to be abstract. Since Java 8 now includes default and static \nmethods and they are never abstract, you cannot assume the abstract modifier will be \nimplicitly applied to all methods by the compiler.\n"
  },
  {
    "id": "oca-98",
    "question": "What is the output of the following code?\n1: class Mammal {\n2:   public Mammal(int age) {\n3:     System.out.print(\"Mammal\");\n4:   }\n5: }\n6: public class Platypus extends Mammal {\n7:   public Platypus() {\n8:     System.out.print(\"Platypus\");\n9:   }\n10:   public static void main(String[] args) {\n11:     new Mammal(5);\n12:   }\n13: }",
    "choices": [
      {
        "key": "A",
        "text": "Platypus"
      },
      {
        "key": "B",
        "text": "Mammal"
      },
      {
        "key": "C",
        "text": "PlatypusMammal"
      },
      {
        "key": "D",
        "text": "MammalPlatypus"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 11."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code will not compile because the parent class Mammal doesn’t define a no-argu\u0002ment constructor, so the first line of a Platypus constructor should be an explicit call \nto super(int age). If there was such a call, then the output would be MammalPlatypus, \nsince the super constructor is executed before the child constructor.\n"
  },
  {
    "id": "oca-99",
    "question": "Which of the following statements can be inserted in the blank line so that the code will \ncompile successfully? (Choose all that apply)\npublic interface CanHop {}\npublic class Frog implements CanHop {\n   public static void main(String[] args) {\n      frog = new TurtleFrog();\n   }\n}\npublic class TurtleFrog extends Frog {}",
    "choices": [
      {
        "key": "A",
        "text": "Frog"
      },
      {
        "key": "B",
        "text": "TurtleFrog"
      },
      {
        "key": "C",
        "text": "BrazilianHornedFrog"
      },
      {
        "key": "D",
        "text": "CanHop"
      },
      {
        "key": "E",
        "text": "Object"
      },
      {
        "key": "F",
        "text": "Long"
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "The blank can be filled with any class or interface that is a supertype of \nTurtleFrog. Option A is a superclass of TurtleFrog, and option B is the same class, \nso both are correct. BrazilianHornedFrog is not a superclass of TurtleFrog, so option \nC is incorrect. TurtleFrog inherits the CanHope interface, so option D is correct. All \nclasses inherit Object, so option E is correct. Finally, Long is an unrelated class that is \nnot a superclass of TurtleFrog, and is therefore incorrect.\n"
  },
  {
    "id": "oca-100",
    "question": "Which statement(s) are correct about the following code? (Choose all that apply)\npublic class Rodent {\n  protected static Integer chew() throws Exception {\n    System.out.println(\"Rodent is chewing\");\n    return 1;\n  }\n}\npublic class Beaver extends Rodent {\n  public Number chew() throws RuntimeException {\n    System.out.println(\"Beaver is chewing on wood\");\n    return 2;\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "It will compile without issue."
      },
      {
        "key": "B",
        "text": "It fails to compile because the type of the exception the method throws is a subclass of \nthe type of exception the parent method throws."
      },
      {
        "key": "C",
        "text": "It fails to compile because the return types are not covariant."
      },
      {
        "key": "D",
        "text": "It fails to compile because the method is protected  in the parent class and public  in \nthe subclass."
      },
      {
        "key": "E",
        "text": "It fails to compile because of a static  modifier mismatch between the two methods."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "The code doesn’t compile, so option A is incorrect. Option B is also not correct \nbecause the rules for overriding a method allow a subclass to define a method with an \nexception that is a subclass of the exception in the parent method. Option C is cor\u0002rect because the return types are not covariant; in particular, Number is not a subclass \nof Integer. Option D is incorrect because the subclass defines a method that is more \naccessible than the method in the parent class, which is allowed. Finally, option E is \ncorrect because the method is declared as static in the parent class and not so in the \nchild class. For nonprivate methods in the parent class, both methods must use static\n(hide) or neither should use static (override).\n"
  },
  {
    "id": "oca-101",
    "question": "Which of the following may only be hidden and not overridden? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "private  instance methods"
      },
      {
        "key": "B",
        "text": "protected  instance methods"
      },
      {
        "key": "C",
        "text": "public  instance methods"
      },
      {
        "key": "D",
        "text": "static  methods"
      },
      {
        "key": "E",
        "text": "public  variables"
      },
      {
        "key": "F",
        "text": "private  variablesReview Questions  293\n1: interface HasExoskeleton {\n2:   abstract int getNumberOfSections();\n3: }\n4: abstract class Insect implements HasExoskeleton {\n5:   abstract int getNumberOfLegs();\n6: }\n7: public class Beetle extends Insect {\n8:   int getNumberOfLegs() { return 6; }\n9: }"
      },
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "E",
        "text": "It compiles but throws an exception at runtime."
      }
    ],
    "answer": [
      "A",
      "D",
      "E",
      "F"
    ],
    "explanation": "First off, options B and C are incorrect because protected and public meth\u0002ods may be overridden, not hidden. Option A is correct because private methods are \nalways hidden in a subclass. Option D is also correct because static methods cannot \nbe overridden, only hidden. Options E and F are correct because variables may only be \nhidden, regardless of the access modifier.\n"
  },
  {
    "id": "oca-102",
    "question": "Which of the following statements about polymorphism are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "A reference to an object may be cast to a subclass of the object without an explicit cast."
      },
      {
        "key": "B",
        "text": "If a method takes a superclass of three objects, then any of those classes may be passed \nas a parameter to the method."
      },
      {
        "key": "C",
        "text": "A method that takes a parameter with type java.lang.Object  will take any reference."
      },
      {
        "key": "D",
        "text": "All cast exceptions can be detected at compile-time."
      },
      {
        "key": "E",
        "text": "By defining a public instance method in the superclass, you guarantee that the specific \nmethod will be called in the parent class at runtime."
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "The code fails to compile because Beetle, the first concrete subclass, doesn’t imple\u0002ment getNumberOfSections(), which is inherited as an abstract method; therefore, \noption D is correct. Option B is incorrect because there is nothing wrong with this \ninterface method definition. Option C is incorrect because an abstract class is not \nrequired to implement any abstract methods, including those inherited from an inter\u0002face. Option E is incorrect because the code fails at compilation-time.\n"
  },
  {
    "id": "oca-103",
    "question": "Choose the correct statement about the following code:\n1: public interface Herbivore {\n2:   int amount = 10;\n3:   public static void eatGrass();\n4:   public int chew() {\n5:     return 13;\n6:   }\n7: }",
    "choices": [
      {
        "key": "A",
        "text": "It compiles and runs without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 3."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "E",
        "text": "The code will not compile because of lines 2 and 3."
      },
      {
        "key": "F",
        "text": "The code will not compile because of lines 3 and 4.\n1: public interface CanFly {\n2:   void fly();\n3: }\n4: interface HasWings {\n5:   public abstract Object getWindSpan();\n6: }\n7: abstract class Falcon implements CanFly, HasWings {\n8: }"
      },
      {
        "key": "A",
        "text": "It compiles without issue."
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of lines 2 and 5."
      },
      {
        "key": "F",
        "text": "The code will not compile because the class Falcon  doesn’t implement the interface \nmethods."
      }
    ],
    "answer": [
      "B",
      "C"
    ],
    "explanation": "A reference to an object requires an explicit cast if referenced with a subclass, \nso option A is incorrect. If the cast is to a superclass reference, then an explicit cast is \nnot required. Because of polymorphic parameters, if a method takes the superclass of \nan object as a parameter, then any subclass references may be used without a cast, so \noption B is correct. All objects extend java.lang.Object, so if a method takes that \ntype, any valid object, including null, may be passed; therefore, option C is correct. \nSome cast exceptions can be detected as errors at compile-time, but others can only be \ndetected at runtime, so D is incorrect. Due to the nature of polymorphism, a public\ninstance method can be overridden in a subclass and calls to it will be replaced even in \nthe superclass it was defined, so E is incorrect.\n"
  },
  {
    "id": "oca-104",
    "question": "Which statements are true for both abstract classes and interfaces? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "All methods within them are assumed to be abstract."
      },
      {
        "key": "B",
        "text": "Both can contain public static final  variables."
      },
      {
        "key": "C",
        "text": "Both can be extended using the extend  keyword."
      },
      {
        "key": "D",
        "text": "Both can contain default methods."
      },
      {
        "key": "E",
        "text": "Both can contain static methods."
      },
      {
        "key": "F",
        "text": "Neither can be instantiated directly."
      },
      {
        "key": "G",
        "text": "Both inherit java.lang.Object ."
      }
    ],
    "answer": [
      "F"
    ],
    "explanation": "The interface variable amount is correctly declared, with public and static being \nassumed and automatically inserted by the compiler, so option B is incorrect. The \nmethod declaration for eatGrass() on line 3 is incorrect because the method has been \nmarked as static but no method body has been provided. The method declaration for \nchew() on line 4 is also incorrect, since an interface method that provides a body must \nbe marked as default or static explicitly. Therefore, option F is the correct answer \nsince this code contains two compile-time errors.\n348 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 348\n"
  },
  {
    "id": "oca-105",
    "question": "What modifiers are assumed for all interface variables? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "public"
      },
      {
        "key": "B",
        "text": "protected"
      },
      {
        "key": "C",
        "text": "private"
      },
      {
        "key": "D",
        "text": "static"
      },
      {
        "key": "E",
        "text": "final"
      },
      {
        "key": "F",
        "text": "abstract"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "Although the definition of methods on lines 2 and 5 vary, both will be converted to \npublic abstract by the compiler. Line 4 is fine, because an interface can have pub\u0002lic or default access. Finally, the class Falcon doesn’t need to implement the interface \nmethods because it is marked as abstract. Therefore, the code will compile without \nissue.\n"
  },
  {
    "id": "oca-106",
    "question": "What is the output of the following code?\n1: interface Nocturnal {\n2:   default boolean isBlind() { return true; }\n3: }\n4: public class Owl implements Nocturnal {Review Questions  295\n6:     public static void main(String[] args) {\n7:     Nocturnal nocturnal = (Nocturnal)new Owl();\n8:     System.out.println(nocturnal.isBlind());\n9:     }\n10: }",
    "choices": [
      {
        "key": "A",
        "text": "true"
      },
      {
        "key": "B",
        "text": "false"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 7."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      }
    ],
    "answer": [
      "B",
      "C",
      "E",
      "F"
    ],
    "explanation": "Option A is wrong, because an abstract class may contain concrete meth\u0002ods. Since Java 8, interfaces may also contain concrete methods in form of static or \ndefault methods. Although all variables in interfaces are assumed to be public static \nfinal, abstract classes may contain them as well, so option B is correct. Both abstract \nclasses and interfaces can be extended with the extends keyword, so option C is cor\u0002rect. Only interfaces can contain default methods, so option D is incorrect. Both \nabstract classes and interfaces can contain static methods, so option E is correct. Both \nstructures require a concrete subclass to be instantiated, so option F is correct. Finally, \nthough an instance of an object that implements an interface inherits java.lang.\nObject, the interface itself doesn’t; otherwise, Java would support multiple inheritance \nfor objects, which it doesn’t. Therefore, option G is incorrect.\n"
  },
  {
    "id": "oca-107",
    "question": "What is the output of the following code?\n1: class Arthropod \n2:   public void printName(double input) { System.out\n  .print(\"Arthropod\"); }\n3: }\n4: public class Spider extends Arthropod {\n5:   public void printName(int input) { System.out.print(\"Spider\"); }\n6:   public static void main(String[] args) {\n7:     Spider spider = new Spider();\n8:     spider.printName(4);\n9:     spider.printName(9.0);\n10:   }\n11: }",
    "choices": [
      {
        "key": "A",
        "text": "SpiderArthropod"
      },
      {
        "key": "B",
        "text": "ArthropodSpider"
      },
      {
        "key": "C",
        "text": "SpiderSpider"
      },
      {
        "key": "D",
        "text": "ArthropodArthropod"
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 9."
      }
    ],
    "answer": [
      "A",
      "D",
      "E"
    ],
    "explanation": "Interface variables are assumed to be public static final; therefore, options \nA, D, and E are correct. Options B and C are incorrect because interface variables must \nbe public—interfaces are implemented by classes, not inherited by interfaces. Option F \nis incorrect because variables can never be abstract.\n"
  },
  {
    "id": "oca-108",
    "question": "Which statements are true about the following code? (Choose all that apply)\n1: interface HasVocalCords {\n2:   public abstract void makeSound();\n3: }\n4: public interface CanBark extends HasVocalCords {\n5:   public void bark();\n6: }",
    "choices": [
      {
        "key": "B",
        "text": "A class that implements HasVocalCords  must override the makeSound()  method."
      },
      {
        "key": "C",
        "text": "A class that implements CanBark  inherits both the makeSound()  and bark()  methods."
      },
      {
        "key": "D",
        "text": "A class that implements CanBark  only inherits the bark()  method."
      },
      {
        "key": "E",
        "text": "An interface cannot extend another interface."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This code compiles and runs without issue, outputting false, so option B is the \ncorrect answer. The first declaration of isBlind() is as a default interface method, \nassumed public. The second declaration of isBlind() correctly overrides the default \ninterface method. Finally, the newly created Owl instance may be automatically cast to \na Nocturnal reference without an explicit cast, although adding it doesn’t break the \ncode.\n"
  },
  {
    "id": "oca-109",
    "question": "Which of the following is true about a concrete subclass? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "A concrete subclass can be declared as abstract ."
      },
      {
        "key": "B",
        "text": "A concrete subclass must implement all inherited abstract methods."
      },
      {
        "key": "C",
        "text": "A concrete subclass must implement all methods defined in an inherited interface."
      },
      {
        "key": "D",
        "text": "A concrete subclass cannot be marked as final ."
      },
      {
        "key": "E",
        "text": "Abstract methods cannot be overridden by a concrete subclass."
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The code compiles and runs without issue, so options E and F are incorrect. The \nprintName() method is an overload in Spider, not an override, so both methods may \nbe called. The call on line 8 references the version that takes an int as input defined \nin the Spider class, and the call on line 9 references the version in the Arthropod class \nthat takes a double. Therefore, SpiderArthropod is output and option A is the correct \nanswer.\n"
  },
  {
    "id": "oca-110",
    "question": "What is the output of the following code?\n1: abstract class Reptile {\n2:   public final void layEggs() { System.out.println(\"Reptile laying eggs\"); \n   }\n3:     public static void main(String[] args) {\n4:     Reptile reptile = new Lizard();\n5:     reptile.layEggs();\n6:     }\n7: }\n8: public class Lizard extends Reptile {\n9:   public void layEggs() { System.out.println(\"Lizard laying eggs\"); }\n10: }",
    "choices": [
      {
        "key": "A",
        "text": "Reptile laying eggs"
      },
      {
        "key": "B",
        "text": "Lizard laying eggs"
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 9."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The code compiles without issue, so option A is wrong. Option B is incorrect, since \nan abstract class could implement HasVocalCords without the need to override the \nmakeSound() method. Option C is correct; any class that implements CanBark auto\u0002matically inherits its methods, as well as any inherited methods defined in the parent \ninterface. Because option C is correct, it follows that option D is incorrect. Finally, an \ninterface can extend multiple interfaces, so option E is incorrect.\n"
  },
  {
    "id": "oca-111",
    "question": "What is the output of the following code?\n1: public abstract class Whale {\n2:   public abstract void dive() {};\n3:   public static void main(String[] args) {\n4:     Whale whale = new Orca();\n5:     whale.dive();\n6:   }\n7: }Review Questions  297\n9:   public void dive(int depth) { System.out.println(\"Orca diving\"); }\n10: }",
    "choices": [
      {
        "key": "A",
        "text": "Orca diving"
      },
      {
        "key": "B",
        "text": "The code will not compile because of line 2."
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 8."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 9."
      },
      {
        "key": "E",
        "text": "The output cannot be determined from the code provided."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Concrete classes are, by definition, not abstract, so option A is incorrect. A concrete \nclass must implement all inherited abstract methods, so option B is correct. Option C \nis incorrect; a superclass may have already implemented an inherited interface, so the \nconcrete subclass would not need to implement the method. Concrete classes can be \nboth final and not final, so option D is incorrect. Finally, abstract methods must be \noverridden by a concrete subclass, so option E is incorrect.\n"
  },
  {
    "id": "oca-112",
    "question": "What is the output of the following code? (Choose all that apply)\n1: interface Aquatic {\n2:   public default int getNumberOfGills(int input) { return 2; }\n3: }\n4: public class ClownFish implements Aquatic {\n5:   public String getNumberOfGills() { return \"4\"; }\n6:   public String getNumberOfGills(int input) { return \"6\"; }\n7:   public static void main(String[] args) {\n8:     System.out.println(new ClownFish().getNumberOfGills(-1));\n9:   }\n10: }",
    "choices": [
      {
        "key": "A",
        "text": "2"
      },
      {
        "key": "B",
        "text": "4"
      },
      {
        "key": "C",
        "text": "6"
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 6."
      },
      {
        "key": "F",
        "text": "The code will not compile because of line 8."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code doesn’t compile, so options A and B are incorrect. The issue with line 9 is \nthat layEggs() is marked as final in the superclass Reptile, which means it cannot be \noverridden. There are no errors on any other lines, so options C and D are incorrect.\n"
  },
  {
    "id": "oca-113",
    "question": "Which of the following statements can be inserted in the blank so that the code will \ncompile successfully? (Choose all that apply)\npublic class Snake {}\npublic class Cobra extends Snake {}\npublic class GardenSnake {}\npublic class SnakeHandler {\n   private Snake snake;\n   public void setSnake(Snake snake) { this.snake = snake; }\n   public static void main(String[] args) {\n     new SnakeHandler().setSnake( );\n   }\n}",
    "choices": [
      {
        "key": "B",
        "text": "new GardenSnake()"
      },
      {
        "key": "C",
        "text": "new Snake()"
      },
      {
        "key": "D",
        "text": "new Object()"
      },
      {
        "key": "E",
        "text": "new String(\"Snake\")"
      },
      {
        "key": "F",
        "text": "null"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "This may look like a complex question, but it is actually quite easy. Line 2 contains \nan invalid definition of an abstract method. Abstract methods cannot contain a body, \nso the code will not compile and option B is the correct answer. If the body {} was \nremoved from line 2, the code would still not compile, although it would be line 8 that \nwould throw the compilation error. Since dive() in Whale is abstract and Orca extends \nWhale, then it must implement an overridden version of dive(). The method on line \n9 is an overloaded version of dive(), not an overridden version, so Orca is an invalid \nsubclass and will not compile.\n"
  },
  {
    "id": "oca-114",
    "question": "What is the result of the following code?\n1: public abstract class Bird {\n2:   private void fly() { System.out.println(\"Bird is flying\"); }\n3:   public static void main(String[] args) {\n4:     Bird bird = new Pelican();\n5:     bird.fly();\n6:   }\n7: }\n8: class Pelican extends Bird {\n9:   protected void fly() { System.out.println(\"Pelican is flying\"); }\n10: }",
    "choices": [
      {
        "key": "A",
        "text": "Bird is flying"
      },
      {
        "key": "B",
        "text": "Pelican is flying "
      },
      {
        "key": "C",
        "text": "The code will not compile because of line 4."
      },
      {
        "key": "D",
        "text": "The code will not compile because of line 5."
      },
      {
        "key": "E",
        "text": "The code will not compile because of line 9."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The code doesn’t compile because line 6 contains an incompatible override of the \ngetNumberOfGills(int input) method defined in the Aquatic interface. In particular, \nint and String are not covariant returns types, since int is not a subclass of String. \nNote that line 5 compiles without issue; getNumberOfGills() is an overloaded method \nthat is not related to the parent interface method that takes an int value.\n"
  },
  {
    "id": "oca-115",
    "question": "Which of the following statements are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Runtime exceptions are the same thing as checked exceptions."
      },
      {
        "key": "B",
        "text": "Runtime exceptions are the same thing as unchecked exceptions."
      },
      {
        "key": "C",
        "text": "You can declare only checked exceptions."
      },
      {
        "key": "D",
        "text": "You can declare only unchecked exceptions."
      },
      {
        "key": "E",
        "text": "You can handle only Exception  subclasses."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Runtime exceptions are also known as unchecked exceptions. They are allowed \nto be declared, but they don’t have to be. Checked exceptions must be handled or \ndeclared. Legally, you can handle java.lang.Error subclasses, but it’s not a good idea.\n"
  },
  {
    "id": "oca-116",
    "question": "Which of the following pairs fill in the blanks to make this code compile? (Choose all that \napply)\n7: public void ohNo() _____ Exception {\n8:   _____________ Exception();\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "On line 7, fill in throw"
      },
      {
        "key": "B",
        "text": "On line 7, fill in throws"
      },
      {
        "key": "C",
        "text": "On line 8, fill in throw"
      },
      {
        "key": "D",
        "text": "On line 8, fill in throw new"
      },
      {
        "key": "E",
        "text": "On line 8, fill in throws"
      },
      {
        "key": "F",
        "text": "On line 8, fill in throws new"
      }
    ],
    "answer": [
      "B",
      "D"
    ],
    "explanation": "In a method declaration, the keyword throws is used. To actually throw an \nexception, the keyword throw is used and a new exception is created.\n"
  },
  {
    "id": "oca-117",
    "question": "When are you required to use a finally  block in a regular try statement (not a try-with-\nresources )?",
    "choices": [
      {
        "key": "A",
        "text": "Never."
      },
      {
        "key": "B",
        "text": "When the program code doesn’t terminate on its own."
      },
      {
        "key": "C",
        "text": "When there are no catch  blocks in a try statement."
      },
      {
        "key": "D",
        "text": "When there is exactly one catch  block in a try statement."
      },
      {
        "key": "E",
        "text": "When there are two or more catch  blocks in a try statement."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "A try statement is required to have a catch clause and/or finally clause. If it goes \nthe catch route, it is allowed to have multiple catch clauses.\n350 Appendix A ■ Answers to Review Questions\nbapp01.indd 1½ 4/2014 Page 350\n"
  },
  {
    "id": "oca-118",
    "question": "Which exception will the following throw?\nObject obj = new Integer(3);\nString str = (String) obj;\nSystem.out.println(str);",
    "choices": [
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "ClassCastException"
      },
      {
        "key": "C",
        "text": "IllegalArgumentException"
      },
      {
        "key": "D",
        "text": "NumberFormatException"
      },
      {
        "key": "E",
        "text": "None of the above."
      },
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "ExceptionInInitializerError"
      },
      {
        "key": "C",
        "text": "java.io.IOException"
      },
      {
        "key": "D",
        "text": "NullPointerException"
      },
      {
        "key": "E",
        "text": "NumberFormatException"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The second line tries to cast an Integer to a String. Since String does not extend \nInteger, this is not allowed and a ClassCastException is thrown.\n"
  },
  {
    "id": "oca-119",
    "question": "What will happen if you add the statement System.out.println(5 / 0);  to a working \nmain()  method?",
    "choices": [
      {
        "key": "A",
        "text": "It will not compile."
      },
      {
        "key": "B",
        "text": "It will not run."
      },
      {
        "key": "C",
        "text": "It will run and throw an ArithmeticException ."
      },
      {
        "key": "D",
        "text": "It will run and throw an IllegalArgumentException ."
      },
      {
        "key": "E",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "java.io.IOException is thrown by many methods in the java.io package, \nbut it is always thrown programmatically. The same is true for NumberFormatExcep\u0002tion; it is thrown programmatically by the wrapper classes of java.lang. The other \nthree exceptions are all thrown by the JVM when the corresponding problem arises.\n"
  },
  {
    "id": "oca-120",
    "question": "What is printed besides the stack trace caused by the NullPointerException  from line 16? \n1: public class DoSomething {\n2:   public void go() {\n3:     System.out.print(\"A\");\n4:     try {\n5:         stop();\n6:     } catch (ArithmeticException e) {\n7:         System.out.print(\"B\");\n8:     } finally {\n9:         System.out.print(\"C\");\n10:    }\n11:    System.out.print(\"D\");\n12:  }\n13:  public void stop() {\n14:    System.out.print(\"E\");\n15:    Object x = null;\n16:    x.toString();\n17:    System.out.print(\"F\");\n18:  }\n19:  public static void main(String[] args) {\n20:    new DoSomething().go();\n21:  }\n22: }",
    "choices": [
      {
        "key": "A",
        "text": "AE"
      },
      {
        "key": "B",
        "text": "AEBCDReview Questions  327"
      },
      {
        "key": "D",
        "text": "AECD"
      },
      {
        "key": "E",
        "text": "No output appears other than the stack trace."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The compiler tests the operation for a valid type but not a valid result, so the code \nwill still compile and run. At runtime, evaluation of the parameter takes place before \npassing it to the print() method, so an ArithmeticException object is raised.\n"
  },
  {
    "id": "oca-121",
    "question": "What is the output of the following snippet, assuming a and b are both 0?\n3:     try {\n4:       return a / b;\n5:     } catch (RuntimeException e) {\n6:       return -1;\n7:     } catch (ArithmeticException e) {\n8:       return 0;\n9:     } finally {\n10:      System.out.print(\"done\");\n11:    }",
    "choices": [
      {
        "key": "A",
        "text": "-1"
      },
      {
        "key": "B",
        "text": "0"
      },
      {
        "key": "C",
        "text": "done-1"
      },
      {
        "key": "D",
        "text": "done0"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "The main() method invokes go and A is printed on line 3. The stop method is \ninvoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop\nimmediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the \ngo method ends as well, but not before its finally block executes and C is printed on \nline 9. Because main() doesn’t catch the exception, the stack trace displays and no fur\u0002ther output occurs, so AEC was the output printed before the stack trace. \n"
  },
  {
    "id": "oca-122",
    "question": "What is the output of the following program?\n1: public class Laptop {\n2:   public void start() {\n3:    try {\n4:      System.out.print(\"Starting up \");\n5:      throw new Exception();\n6:    } catch (Exception e) {\n7:       System.out.print(\"Problem \");\n8:       System. exit(0);\n9:    } finally {\n10:      System.out.print(\"Shutting down \");\n11:   } \n12:  }\n13:  public static void main(String[] args) {\n14:    new Laptop().start();\n15:  } }",
    "choices": [
      {
        "key": "A",
        "text": "Starting up"
      },
      {
        "key": "B",
        "text": "Starting up Problem"
      },
      {
        "key": "C",
        "text": "Starting up Problem Shutting down"
      },
      {
        "key": "E",
        "text": "The code does not compile."
      },
      {
        "key": "F",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The order of catch blocks is important because they’re checked in the order they \nappear after the try block. Because ArithmeticException is a child class of Runtime\u0002Exception, the catch block on line 7 is unreachable. (If an ArithmeticException is \nthrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error \nbecause it is unreachable code.\n"
  },
  {
    "id": "oca-123",
    "question": "What is the output of the following program?\n1:  public class Dog {\n2:    public String name;\n3:    public void parseName() {\n4:      System.out.print(\"1\");\n5:      try {\n6:        System.out.print(\"2\");\n7:        int x = Integer. parseInt (name);\n8:        System.out.print(\"3\");\n9:      } catch (NumberFormatException e) {\n10:       System.out.print(\"4\");\n11:     }\n12:   }\n13:   public static void main(String[] args) {\n14:     Dog leroy = new Dog();\n15:     leroy.name = \"Leroy\";\n16:     leroy.parseName();\n17:     System.out.print(\"5\");\n18:   } }",
    "choices": [
      {
        "key": "A",
        "text": "12"
      },
      {
        "key": "B",
        "text": "1234"
      },
      {
        "key": "C",
        "text": "1235"
      },
      {
        "key": "D",
        "text": "124"
      },
      {
        "key": "E",
        "text": "1245"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "The main() method invokes start on a new Laptop object. Line 4 prints Starting \nup; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints \nProblem, and then line 8 calls System.exit, which terminates the JVM. The finally\nblock does not execute because the JVM is no longer running.\n"
  },
  {
    "id": "oca-124",
    "question": "What is the output of the following program?\n1:  public class Cat {\n2:    public String name;\n3:    public void parseName() {\n4:      System.out.print(\"1\");\n5:      try {\n6:        System. out.print(\"2\");\n7:        int x = Integer. parseInt (name);\n8:        System.out.print(\"3\");Review Questions  329\n10:       System.out.print(\"4\");\n11:     }\n12:     System.out.print(\"5\");\n13:   }\n14:   public static void main(String[] args) {\n15:     Cat leo = new Cat();\n16:     leo.name = \"Leo\";\n17:     leo.parseName();\n18:     System.out.print(\"6\");\n19:   }\n20: }",
    "choices": [
      {
        "key": "A",
        "text": "12, followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "B",
        "text": "124, followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "C",
        "text": "12456"
      },
      {
        "key": "D",
        "text": "12456"
      },
      {
        "key": "E",
        "text": "1256 , followed by a stack trace for a NumberFormatException"
      },
      {
        "key": "F",
        "text": "The code does not compile."
      },
      {
        "key": "G",
        "text": "An uncaught exception is thrown."
      }
    ],
    "answer": [
      "E"
    ],
    "explanation": "The parseName method is invoked within main() on a new Dog object. Line 4 prints 1.\nThe try block executes and 2 is printed. Line 7 throws a NumberFormatException, so \nline 8 doesn’t execute. The exception is caught on line 9, and line 10 prints 4. Because the \nexception is handled, execution resumes normally. parseName runs to completion, and \nline 17 executes, printing 5. That’s the end of the program, so the output is 1245.\n"
  },
  {
    "id": "oca-125",
    "question": "What is printed by the following? (Choose all that apply)\n1:  public class Mouse {\n2:    public String name;\n3:    public void run() {\n4:      System.out.print(\"1\");\n5:      try {\n6:        System.out.print(\"2\");\n7:        name.toString();\n8:        System.out.print(\"3\");\n9:      } catch (NullPointerException e) {\n10:       System.out.print(\"4\");\n11:       throw e;\n12:     }\n13:     System.out.print(\"5\");\n14:   }\n15:   public static void main(String[] args) {\n16:     Mouse jerry = new Mouse();\n17:     jerry.run();\n18:     System.out.print(\"6\");\n19:   } }",
    "choices": [
      {
        "key": "B",
        "text": "2"
      },
      {
        "key": "C",
        "text": "3"
      },
      {
        "key": "D",
        "text": "4"
      },
      {
        "key": "E",
        "text": "5"
      },
      {
        "key": "F",
        "text": "6"
      },
      {
        "key": "G",
        "text": "The stack trace for a NullPointerException"
      }
    ],
    "answer": [
      "A"
    ],
    "explanation": "The parseName method is invoked on a new Cat object. Line 4 prints 1. The try\nblock is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t \ncaught, so parseName ends. main() doesn’t catch the exception either, so the program \nterminates and the stack trace for the NumberFormatException is printed.\n"
  },
  {
    "id": "oca-126",
    "question": "Which of the following statements are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "You can declare a method with Exception  as the return type."
      },
      {
        "key": "B",
        "text": "You can declare any subclass of Error  in the throws  part of a method declaration."
      },
      {
        "key": "C",
        "text": "You can declare any subclass of Exception  in the throws  part of a method \ndeclaration."
      },
      {
        "key": "D",
        "text": "You can declare any subclass of Object  in the throws  part of a method declaration."
      },
      {
        "key": "E",
        "text": "You can declare any subclass of RuntimeException  in the throws  part of a method \ndeclaration."
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "G"
    ],
    "explanation": "The main() method invokes run on a new Mouse object. Line 4 prints 1 and \nline 6 prints 2, so options A and B are correct. Line 7 throws a NullPointerException, \nwhich causes line 8 to be skipped, so C is incorrect. The exception is caught on line 9 \nand line 10 prints 4, so option D is correct. Line 11 throws the exception again, which \ncauses run() to immediately end, so line 13 doesn’t execute and option E is incorrect. \nThe main() method doesn’t catch the exception either, so line 18 doesn’t execute and \noption F is incorrect. The uncaught NullPointerException causes the stack trace to be \nprinted, so option G is correct. \n"
  },
  {
    "id": "oca-127",
    "question": "Which of the following can be inserted on line 8 to make this code compile? (Choose all \nthat apply)\n7: public void ohNo() throws IOException {\n8:   // INSERT CODE HERE\n9: }",
    "choices": [
      {
        "key": "A",
        "text": "System.out.println(\"it's ok\");"
      },
      {
        "key": "B",
        "text": "throw new Exception();"
      },
      {
        "key": "C",
        "text": "throw new IllegalArgumentException();"
      },
      {
        "key": "D",
        "text": "throw new java.io.IOException();"
      },
      {
        "key": "E",
        "text": "throw new RuntimeException();"
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "Classes listed in the throws part of a method declaration must extend \njava.lang.Throwable. This includes Error, Exception, and RuntimeException. Arbi\u0002trary classes such as String can’t go there. Any Java type, including Exception, can \nbe declared as the return type. However, this will simply return the object rather than \nthrow an exception.\n"
  },
  {
    "id": "oca-128",
    "question": "Which of the following are unchecked exceptions? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "ArrayIndexOutOfBoundsException"
      },
      {
        "key": "B",
        "text": "IllegalArgumentException"
      },
      {
        "key": "C",
        "text": "IOException"
      },
      {
        "key": "D",
        "text": "NumberFormatException"
      },
      {
        "key": "E",
        "text": "Any exception that extends RuntimeException"
      },
      {
        "key": "F",
        "text": "Any exception that extends Exception"
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "A method that declares an exception isn’t required to throw one, making \noption A correct. Runtime exceptions can be thrown in any method, making options \nC and E correct. Option D matches the exception type declared and so is also correct. \nOption B is incorrect because a broader exception is not allowed.\n"
  },
  {
    "id": "oca-129",
    "question": "Which scenario is the best use of an exception?",
    "choices": [
      {
        "key": "A",
        "text": "An element is not found when searching a list."
      },
      {
        "key": "B",
        "text": "An unexpected parameter is passed into a method.Review Questions  331"
      },
      {
        "key": "D",
        "text": "You want to loop through a list."
      },
      {
        "key": "E",
        "text": "You don’t know how to code a method."
      }
    ],
    "answer": [
      "A",
      "B",
      "D",
      "E"
    ],
    "explanation": "ArrayIndexOutOfBoundsException, IllegalArgumentException, and Num\u0002berFormatException are runtime exceptions. Sorry, you have to memorize them. Any \nclass that extends RuntimeException is a runtime (unchecked) exception. Classes that \nextend Exception but not RuntimeException are checked exceptions.\n"
  },
  {
    "id": "oca-130",
    "question": "Which of the following can be inserted into Lion  to make this code compile? (Choose all \nthat apply)\nclass HasSoreThroatException extends Exception {}\nclass TiredException extends RuntimeException {}\ninterface Roar {\n  void roar() throws HasSoreThroatException;\n}\nclass Lion implements Roar {// INSERT CODE HERE\n}",
    "choices": [
      {
        "key": "A",
        "text": "public void roar(){} "
      },
      {
        "key": "B",
        "text": "public void roar() throws Exception{}  "
      },
      {
        "key": "C",
        "text": "public void roar() throws HasSoreThroatException{} "
      },
      {
        "key": "D",
        "text": "public void roar() throws IllegalArgumentException{} "
      },
      {
        "key": "E",
        "text": "public void roar() throws TiredException{} "
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "IllegalArgumentException is used when an unexpected parameter is passed into a \nmethod. Option A is incorrect because returning null or -1 is a common return value \nfor this scenario. Option D is incorrect because a for loop is typically used for this \nscenario. Option E is incorrect because you should find out how to code the method \nand not leave it for the unsuspecting programmer who calls your method. Option C is \nincorrect because you should run! \n"
  },
  {
    "id": "oca-131",
    "question": "Which of the following are true? (Choose all that apply)",
    "choices": [
      {
        "key": "A",
        "text": "Checked exceptions are allowed to be handled or declared."
      },
      {
        "key": "B",
        "text": "Checked exceptions are required to be handled or declared."
      },
      {
        "key": "C",
        "text": "Errors are allowed to be handled or declared."
      },
      {
        "key": "D",
        "text": "Errors are required to be handled or declared."
      },
      {
        "key": "E",
        "text": "Runtime exceptions are allowed to be handled or declared."
      },
      {
        "key": "F",
        "text": "Runtime exceptions are required to be handled or declared."
      }
    ],
    "answer": [
      "A",
      "C",
      "D",
      "E"
    ],
    "explanation": "The method is allowed to throw no exceptions at all, making option A cor\u0002rect. It is also allowed to throw runtime exceptions, making options D and E correct. \nOption C is also correct since it matches the signature in the interface.\n"
  },
  {
    "id": "oca-132",
    "question": "Which of the following can be inserted in the blank to make the code compile? (Choose all \nthat apply)\npublic static void main(String[] args) {\n  try {\n    System.out.println(\"work real hard\");\n  } catch (  e) {\n  } catch (RuntimeException e) {\n  }\n}",
    "choices": [
      {
        "key": "A",
        "text": "Exception"
      },
      {
        "key": "B",
        "text": "IOException"
      },
      {
        "key": "C",
        "text": "IllegalArgumentException"
      },
      {
        "key": "D",
        "text": "RuntimeException"
      },
      {
        "key": "F",
        "text": "None of the above."
      }
    ],
    "answer": [
      "A",
      "B",
      "C",
      "E"
    ],
    "explanation": "Checked exceptions are required to be handled or declared. Runtime \nexceptions are allowed to be handled or declared. Errors are allowed to be handled or \ndeclared, but this is bad practice.\n"
  },
  {
    "id": "oca-133",
    "question": "What does the output of the following contain? (Choose all that apply)\n12: public static void main(String[] args) {\n13:   System.out.print(\"a\");\n14:   try {\n15:     System.out.print(\"b\");\n16:     throw new IllegalArgumentException();\n17:   } catch (IllegalArgumentException e) {\n18:     System.out.print(\"c\");\n19:     throw new RuntimeException(\"1\");\n20:   } catch (RuntimeException e) {\n21:     System.out.print(\"d\");\n22:     throw new RuntimeException(\"2\");\n23:   } finally {\n24:     System.out.print(\"e\");\n25:     throw new RuntimeException(\"3\");\n26:   }\n27: }",
    "choices": [
      {
        "key": "A",
        "text": "abce"
      },
      {
        "key": "B",
        "text": "abde"
      },
      {
        "key": "C",
        "text": "An exception with the message set to \"1\""
      },
      {
        "key": "D",
        "text": "An exception with the message set to \"2\""
      },
      {
        "key": "E",
        "text": "An exception with the message set to \"3\" "
      },
      {
        "key": "F",
        "text": "Nothing; the code does not compile."
      }
    ],
    "answer": [
      "C",
      "E"
    ],
    "explanation": "Option C is allowed because it is a more specific type than RuntimeException. \nOption E is allowed because it isn’t in the same inheritance tree as RuntimeExcep\u0002tion. It’s not a good idea to catch either of these. Option B is not allowed because the \nmethod called inside the try block doesn’t declare an IOException to be thrown. The \ncompiler realizes that IOException would be an unreachable catch block. Option D \nis not allowed because the same exception can’t be specified in two different catch\nblocks. Finally, option A is not allowed because it’s more general than RuntimeExcep\u0002tion and would make that block unreachable.\n"
  }
]